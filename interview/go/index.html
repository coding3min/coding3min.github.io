<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go #  基本数据类型 #  goroutine #  框架 #  gin #  线程和协程，有什么区别，为什么协程可以创建很多 #  答者：记事本
线程由系统调度，协程由运行时调度
而为什么协程可以做到同时创建上万个，是因为go的协程初始化资源是4KB空间，比线程轻量级
网上：
区别在于
 一个线程可以多个协程，一个进程也可以单独拥有多个协程。 线程进程都是同步机制，而协程则是异步。 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。  协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：
协程的好处：
 无需线程上下文切换的开销 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型  缺点：
 无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序  最佳实践
 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。  go协程的GMP理论 #  首先协程和线程是多对多的关系，一般是多对一，只要不涉及多线程就不涉及抢占和线程上下文切换
G指goroutine M thread(machine)、P(Processor处理器)
  在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。 全局队列（Global Queue）：存放等待运行的 G。 P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。 P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。 M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。  一句话：协程创建先放入P的队列，放满了把一半放G的全局队列，M顺序取P来运行，如果M没有取到（P为空）移动全局队列到P中，或者去其他P上取，所以M有调度的作用"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="Go #  基本数据类型 #  goroutine #  框架 #  gin #  线程和协程，有什么区别，为什么协程可以创建很多 #  答者：记事本
线程由系统调度，协程由运行时调度
而为什么协程可以做到同时创建上万个，是因为go的协程初始化资源是4KB空间，比线程轻量级
网上：
区别在于
 一个线程可以多个协程，一个进程也可以单独拥有多个协程。 线程进程都是同步机制，而协程则是异步。 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。  协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：
协程的好处：
 无需线程上下文切换的开销 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型  缺点：
 无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序  最佳实践
 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。  go协程的GMP理论 #  首先协程和线程是多对多的关系，一般是多对一，只要不涉及多线程就不涉及抢占和线程上下文切换
G指goroutine M thread(machine)、P(Processor处理器)
  在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。 全局队列（Global Queue）：存放等待运行的 G。 P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。 P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。 M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。  一句话：协程创建先放入P的队列，放满了把一半放G的全局队列，M顺序取P来运行，如果M没有取到（P为空）移动全局队列到P中，或者去其他P上取，所以M有调度的作用"><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/interview/go/"><meta property="article:section" content="interview"><title>Go | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fa55d4ab6347cff8bc3ae9cefd152a646ed2f9d06f23a24af15f5f4aeb5f3414.js integrity="sha256-+lXUq2NHz/i8OunO/RUqZG7S+dBvI6JK8V9fSutfNBQ=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/>Linux</a></li><li><a href=/interview/go/ class=active><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/>Java</a></li><li><a href=/interview/redis/>Redis</a></li><li><a href=/interview/mysql/>Mysql</a></li><li><a href=/interview/queue/>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#基本数据类型>基本数据类型</a></li><li><a href=#goroutine>goroutine</a></li><li><a href=#框架>框架</a><ul><li><a href=#gin>gin</a></li></ul></li><li><a href=#线程和协程有什么区别为什么协程可以创建很多>线程和协程，有什么区别，为什么协程可以创建很多</a></li><li><a href=#go协程的gmp理论>go协程的GMP理论</a></li><li><a href=#go的切片和数组有什么区别>go的切片和数组有什么区别</a></li><li><a href=#管道chan是什么>管道chan是什么</a></li><li><a href=#管道比锁快为什么>管道比锁快？为什么</a></li><li><a href=#如果协程a创建了协程b和cb协程panic了a协程有recover会发生什么>如果协程A创建了协程B和C，B协程panic了，A协程有recover，会发生什么？</a></li><li><a href=#最后>最后</a></li></ul></nav></aside></header><article class=markdown><h1 id=go>Go
<a class=anchor href=#go>#</a></h1><h2 id=基本数据类型>基本数据类型
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>#</a></h2><h2 id=goroutine>goroutine
<a class=anchor href=#goroutine>#</a></h2><h2 id=框架>框架
<a class=anchor href=#%e6%a1%86%e6%9e%b6>#</a></h2><h3 id=gin>gin
<a class=anchor href=#gin>#</a></h3><h2 id=线程和协程有什么区别为什么协程可以创建很多>线程和协程，有什么区别，为什么协程可以创建很多
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e5%92%8c%e5%8d%8f%e7%a8%8b%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8d%8f%e7%a8%8b%e5%8f%af%e4%bb%a5%e5%88%9b%e5%bb%ba%e5%be%88%e5%a4%9a>#</a></h2><p>答者：记事本</p><p>线程由系统调度，协程由运行时调度</p><p>而为什么协程可以做到同时创建上万个，是因为go的协程初始化资源是4KB空间，比线程轻量级</p><p>网上：</p><p>区别在于</p><ol><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程。</li><li>线程进程都是同步机制，而协程则是异步。</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li><li>线程是<strong>抢占式</strong>，而协程是<strong>非抢占式的</strong>，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li><li>协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。</li><li>线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。</li></ol><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：</p><p>协程的好处：</p><ol><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销</li><li>方便切换控制流，简化编程模型</li></ol><p>缺点：</p><ol><li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li><li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</li></ol><p>最佳实践</p><ol><li>线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。</li><li>对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。</li><li>所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</li></ol><h2 id=go协程的gmp理论>go协程的GMP理论
<a class=anchor href=#go%e5%8d%8f%e7%a8%8b%e7%9a%84gmp%e7%90%86%e8%ae%ba>#</a></h2><p>首先协程和线程是多对多的关系，一般是多对一，只要不涉及多线程就不涉及抢占和线程上下文切换</p><p>G指goroutine M thread(machine)、P(Processor处理器)</p><p><img src=.gitbook/assets/2021-04-15-19-23-20.png alt></p><ul><li>在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。</li><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li><li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li></ul><p>一句话：协程创建先放入P的队列，放满了把一半放G的全局队列，M顺序取P来运行，如果M没有取到（P为空）移动全局队列到P中，或者去其他P上取，所以M有调度的作用</p><p>引用：
<a href=https://learnku.com/articles/41728>Golang 调度器 GMP 原理与调度全分析</a></p><h2 id=go的切片和数组有什么区别>go的切片和数组有什么区别
<a class=anchor href=#go%e7%9a%84%e5%88%87%e7%89%87%e5%92%8c%e6%95%b0%e7%bb%84%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab>#</a></h2><p>定长声明的是数组，不定长是切片</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr1</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span> = [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>slice1</span> []<span style=color:#66d9ef>int</span> = []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>}
</code></pre></div><p>数组拷贝后可以随便改值，不会对原数组有影响，但切片拷贝是引用，修改新切片会同时修改原切片</p><h2 id=管道chan是什么>管道chan是什么
<a class=anchor href=#%e7%ae%a1%e9%81%93chan%e6%98%af%e4%bb%80%e4%b9%88>#</a></h2><p>一个 channels 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息，可以理解为一个队列，遵循先入先出的原则，同时在代码级别线程安全</p><h2 id=管道比锁快为什么>管道比锁快？为什么
<a class=anchor href=#%e7%ae%a1%e9%81%93%e6%af%94%e9%94%81%e5%bf%ab%e4%b8%ba%e4%bb%80%e4%b9%88>#</a></h2><p>go中的chan 是用锁实现的。所以肯定不会比锁块。</p><h2 id=如果协程a创建了协程b和cb协程panic了a协程有recover会发生什么>如果协程A创建了协程B和C，B协程panic了，A协程有recover，会发生什么？
<a class=anchor href=#%e5%a6%82%e6%9e%9c%e5%8d%8f%e7%a8%8ba%e5%88%9b%e5%bb%ba%e4%ba%86%e5%8d%8f%e7%a8%8bb%e5%92%8ccb%e5%8d%8f%e7%a8%8bpanic%e4%ba%86a%e5%8d%8f%e7%a8%8b%e6%9c%89recover%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88>#</a></h2><p>无法在父协程中捕获子协程的panic</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#75715e>// 希望捕获所有所有 panic
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span> () {
    <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> recover()
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;捕获到子协程panic:&#34;</span>,<span style=color:#a6e22e>r</span>)
    }()

    <span style=color:#75715e>// 启动新协程
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span> () {
        panic(<span style=color:#ae81ff>123</span>)
    }()
    <span style=color:#75715e>// 等待一下，不然协程可能来不及执行
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;这条消息打印不出来&#34;</span>)
}
</code></pre></div><p>输出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>panic: 123

goroutine 6 [running]:
main.main.func2()
...
Process finished with exit code 2
</code></pre></div><ul><li>可以看到<code>recover</code>没有成功执行，整个进程都退出了</li><li>所以开了新协程而且忘记了在协程中捕获<code>panic</code>的话，服务的进程就会因为某个未捕获的<code>panic</code>而退出。</li><li>解决方法，使用结构体维护两个通道来处理<code>done</code>和<code>panic</code>事件,外部使用<code>select</code>来维护处理抛出<code>panic</code>，这样外部就可以<code>recover</code>了</li></ul><p>引用:
<a href=https://zhuanlan.zhihu.com/p/146472834>Go协程这样用才安全</a></p><h2 id=最后>最后
<a class=anchor href=#%e6%9c%80%e5%90%8e>#</a></h2><p>如果文中有误，欢迎提pr或者issue，<strong>一旦合并或采纳作为贡献奖励可以联系我直接无门槛</strong>加入
<a href=https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q>技术交流群</a></p><p>我是小熊，关注我，知道更多不知道的技术</p><p><img src=.gitbook/assets/2021-03-17-19-57-33.png alt></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./interview/go.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#基本数据类型>基本数据类型</a></li><li><a href=#goroutine>goroutine</a></li><li><a href=#框架>框架</a><ul><li><a href=#gin>gin</a></li></ul></li><li><a href=#线程和协程有什么区别为什么协程可以创建很多>线程和协程，有什么区别，为什么协程可以创建很多</a></li><li><a href=#go协程的gmp理论>go协程的GMP理论</a></li><li><a href=#go的切片和数组有什么区别>go的切片和数组有什么区别</a></li><li><a href=#管道chan是什么>管道chan是什么</a></li><li><a href=#管道比锁快为什么>管道比锁快？为什么</a></li><li><a href=#如果协程a创建了协程b和cb协程panic了a协程有recover会发生什么>如果协程A创建了协程B和C，B协程panic了，A协程有recover，会发生什么？</a></li><li><a href=#最后>最后</a></li></ul></nav></div></aside></main></body></html>