<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Linux #  VIM 三个模式 #   一般指令模式（默认模式） 编辑模式 指令列模式  文件属性 #   用户分为三种  文件拥有者 群组 其它人   文件类型  d：目录 -：文件 l：链接文件   文件权限：  三位一组 对文件拥有者、所属群组以及其它人的文件权限 3 位分别为 r、w、x 权限，表示可读、可写、可执行   文件时间  modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。   修改权限  chmod 左到右每个位的权值为 4、2、1   默认权限  文件默认权限666 目录默认权限777    链接 #   实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 符号链接：文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式 ln创建链接：默认是实体链接，加 -s 为符号链接   获取文件内容 #   cat、tac(从最后一行打印) more（一页一页打印）、less（增加向前翻页） head（前n行）、tail（后几行）  数据流重定向 #   一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向 输出重定向到 /dev/null（扔进垃圾箱）  排序指令（sort） #  $ sort [-fbMnrtuk] [file or stdin] -f ：忽略大小写 -b ：忽略最前面的空格 -M ：以月份的名字来排序，例如 JAN，DEC -n ：使用数字 -r ：反向排序 -u ：相当于 unique，重复的内容只出现一次 -t ：分隔符，默认为 tab -k ：指定排序的区间 $ uniq [-ic](可以将重复的数据只取一个) -i ：忽略大小写 -c ：进行计数 正则表达式(grep) #  $ grep [-acinv] [--color=auto] 搜寻字符串 filename -c ： 统计匹配到行的个数 -i ： 忽略大小写 -n ： 输出行号 -v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto ：找到的关键字加颜色显示 查看进程 #   ps -l 查看自己的进程 ps aux 查看系统所有进程 pstree 查看进程数  查看子进程的命令 #  这里的 722 是指进程 pid"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="Linux #  VIM 三个模式 #   一般指令模式（默认模式） 编辑模式 指令列模式  文件属性 #   用户分为三种  文件拥有者 群组 其它人   文件类型  d：目录 -：文件 l：链接文件   文件权限：  三位一组 对文件拥有者、所属群组以及其它人的文件权限 3 位分别为 r、w、x 权限，表示可读、可写、可执行   文件时间  modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。   修改权限  chmod 左到右每个位的权值为 4、2、1   默认权限  文件默认权限666 目录默认权限777    链接 #   实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 符号链接：文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式 ln创建链接：默认是实体链接，加 -s 为符号链接   获取文件内容 #   cat、tac(从最后一行打印) more（一页一页打印）、less（增加向前翻页） head（前n行）、tail（后几行）  数据流重定向 #   一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向 输出重定向到 /dev/null（扔进垃圾箱）  排序指令（sort） #  $ sort [-fbMnrtuk] [file or stdin] -f ：忽略大小写 -b ：忽略最前面的空格 -M ：以月份的名字来排序，例如 JAN，DEC -n ：使用数字 -r ：反向排序 -u ：相当于 unique，重复的内容只出现一次 -t ：分隔符，默认为 tab -k ：指定排序的区间 $ uniq [-ic](可以将重复的数据只取一个) -i ：忽略大小写 -c ：进行计数 正则表达式(grep) #  $ grep [-acinv] [--color=auto] 搜寻字符串 filename -c ： 统计匹配到行的个数 -i ： 忽略大小写 -n ： 输出行号 -v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto ：找到的关键字加颜色显示 查看进程 #   ps -l 查看自己的进程 ps aux 查看系统所有进程 pstree 查看进程数  查看子进程的命令 #  这里的 722 是指进程 pid"><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/interview/linux/"><meta property="article:section" content="interview"><title>Linux | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fa55d4ab6347cff8bc3ae9cefd152a646ed2f9d06f23a24af15f5f4aeb5f3414.js integrity="sha256-+lXUq2NHz/i8OunO/RUqZG7S+dBvI6JK8V9fSutfNBQ=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/ class=active>Linux</a></li><li><a href=/interview/go/><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/>Java</a></li><li><a href=/interview/redis/>Redis</a></li><li><a href=/interview/mysql/>Mysql</a></li><li><a href=/interview/queue/>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Linux</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#vim-三个模式>VIM 三个模式</a></li><li><a href=#文件属性>文件属性</a></li><li><a href=#链接>链接</a></li><li><a href=#获取文件内容>获取文件内容</a></li><li><a href=#数据流重定向>数据流重定向</a></li><li><a href=#排序指令sort>排序指令（sort）</a></li><li><a href=#正则表达式grep>正则表达式(grep)</a></li><li><a href=#查看进程>查看进程</a></li><li><a href=#查看子进程的命令>查看子进程的命令</a></li><li><a href=#查看线程号>查看线程号</a></li><li><a href=#查看线程cpu使用率>查看线程cpu使用率</a></li><li><a href=#查询linux文件被哪些pid读写>查询linux文件被哪些pid读写</a></li><li><a href=#获取url中协议域名端口和path>获取URL中协议、域名、端口和Path</a></li><li><a href=#内存>内存</a><ul><li><a href=#内存使用情况buff和cache有什么区别>内存使用情况buff和cache有什么区别？</a></li></ul></li><li><a href=#虚拟地址和物理地址有什么区别程序编译运行后首先申请到的是什么地址>虚拟地址和物理地址有什么区别，程序编译运行后首先申请到的是什么地址？</a></li><li><a href=#运维>运维</a><ul><li><a href=#怎么定位进程cpu占用大是哪一个函数导致的>怎么定位进程cpu占用大是哪一个函数导致的？</a></li></ul></li><li><a href=#什么是程序的堆空间和栈空间>什么是程序的堆空间和栈空间？</a></li><li><a href=#日志归档和清空有哪些方式>日志归档和清空有哪些方式</a></li><li><a href=#如果linux系统卡死操作系统比较慢排查思路>如果linux系统卡死，操作系统比较慢，排查思路？</a></li><li><a href=#发散问题>发散问题</a><ul><li><a href=#linux-打开文件句柄写入一个文件时mv这个文件会发生什么>Linux 打开文件句柄写入一个文件时，mv这个文件会发生什么</a></li></ul></li><li><a href=#最后>最后</a></li></ul></nav></aside></header><article class=markdown><h1 id=linux>Linux
<a class=anchor href=#linux>#</a></h1><h2 id=vim-三个模式>VIM 三个模式
<a class=anchor href=#vim-%e4%b8%89%e4%b8%aa%e6%a8%a1%e5%bc%8f>#</a></h2><ul><li>一般指令模式（默认模式）</li><li>编辑模式</li><li>指令列模式</li></ul><h2 id=文件属性>文件属性
<a class=anchor href=#%e6%96%87%e4%bb%b6%e5%b1%9e%e6%80%a7>#</a></h2><ul><li>用户分为三种<ul><li>文件拥有者</li><li>群组</li><li>其它人</li></ul></li><li>文件类型<ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul></li><li>文件权限：<ul><li>三位一组</li><li>对文件拥有者、所属群组以及其它人的文件权限</li><li>3 位分别为 <code>r、w、x</code> 权限，表示可读、可写、可执行</li></ul></li><li>文件时间<ul><li><code>modification time (mtime)</code>：文件的内容更新就会更新；</li><li><code>status time (ctime)</code>：文件的状态（权限、属性）更新就会更新；</li><li><code>access time (atime)</code>：读取文件时就会更新。</li></ul></li><li>修改权限<ul><li><code>chmod</code></li><li>左到右每个位的权值为 4、2、1</li></ul></li><li>默认权限<ul><li>文件默认权限<code>666</code></li><li>目录默认权限<code>777</code></li></ul></li></ul><h2 id=链接>链接
<a class=anchor href=#%e9%93%be%e6%8e%a5>#</a></h2><ul><li>实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</li><li>符号链接：文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式</li><li>ln创建链接：默认是实体链接，加 -s 为符号链接</li></ul><p><img src=.gitbook/assets/2021-03-26-16-29-48.png alt></p><h2 id=获取文件内容>获取文件内容
<a class=anchor href=#%e8%8e%b7%e5%8f%96%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9>#</a></h2><ul><li>cat、tac(从最后一行打印)</li><li>more（一页一页打印）、less（增加向前翻页）</li><li>head（前n行）、tail（后几行）</li></ul><h2 id=数据流重定向>数据流重定向
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%b5%81%e9%87%8d%e5%ae%9a%e5%90%91>#</a></h2><ul><li>一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向</li><li>输出重定向到 <code>/dev/null</code>（扔进垃圾箱）</li></ul><h2 id=排序指令sort>排序指令（sort）
<a class=anchor href=#%e6%8e%92%e5%ba%8f%e6%8c%87%e4%bb%a4sort>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ sort <span style=color:#f92672>[</span>-fbMnrtuk<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>file or stdin<span style=color:#f92672>]</span>
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间

$ uniq <span style=color:#f92672>[</span>-ic<span style=color:#f92672>](</span>可以将重复的数据只取一个<span style=color:#f92672>)</span>
-i ：忽略大小写
-c ：进行计数
</code></pre></div><h2 id=正则表达式grep>正则表达式(grep)
<a class=anchor href=#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8fgrep>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
</code></pre></div><h2 id=查看进程>查看进程
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b>#</a></h2><ul><li>ps -l 查看自己的进程</li><li>ps aux 查看系统所有进程</li><li>pstree 查看进程数</li></ul><h2 id=查看子进程的命令>查看子进程的命令
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e5%ad%90%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%91%bd%e4%bb%a4>#</a></h2><p>这里的 <code>722</code> 是指进程 <code>pid</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>pstree -p <span style=color:#ae81ff>722</span>
</code></pre></div><h2 id=查看线程号>查看线程号
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e7%ba%bf%e7%a8%8b%e5%8f%b7>#</a></h2><p>这里的 <code>722</code> 是指进程 <code>pid</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ps -T -p <span style=color:#ae81ff>722</span>
</code></pre></div><h2 id=查看线程cpu使用率>查看线程cpu使用率
<a class=anchor href=#%e6%9f%a5%e7%9c%8b%e7%ba%bf%e7%a8%8bcpu%e4%bd%bf%e7%94%a8%e7%8e%87>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>top -H -p <span style=color:#ae81ff>722</span>
</code></pre></div><h2 id=查询linux文件被哪些pid读写>查询linux文件被哪些pid读写
<a class=anchor href=#%e6%9f%a5%e8%af%a2linux%e6%96%87%e4%bb%b6%e8%a2%ab%e5%93%aa%e4%ba%9bpid%e8%af%bb%e5%86%99>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>lsof abc.txt 显示开启文件abc.txt的进程
lsof -i :22 知道22端口现在运行什么程序
lsof -c nsd 显示nsd进程现在打开的文件
lsof -g gid 显示归属gid的进程情况
lsof +d /usr/local/ 显示目录下被进程开启的文件
lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长
lsof -d <span style=color:#ae81ff>4</span> 显示使用fd为4的进程
lsof -i <span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> 用以显示符合条件的进程情况
</code></pre></div><h2 id=获取url中协议域名端口和path>获取URL中协议、域名、端口和Path
<a class=anchor href=#%e8%8e%b7%e5%8f%96url%e4%b8%ad%e5%8d%8f%e8%ae%ae%e5%9f%9f%e5%90%8d%e7%ab%af%e5%8f%a3%e5%92%8cpath>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e>#获取协议</span>
echo <span style=color:#e6db74>&#34;http://www.baidu.com:80/ABCD/a.txt&#34;</span> | awk -F<span style=color:#e6db74>&#39;:&#39;</span> <span style=color:#e6db74>&#39;{print $1}&#39;</span>
<span style=color:#75715e># 输出http</span>

<span style=color:#75715e>#获取域名</span>
echo <span style=color:#e6db74>&#34;http://www.baidu.com:80/ABCD/a.txt&#34;</span> | awk -F<span style=color:#e6db74>&#39;[/:]&#39;</span> <span style=color:#e6db74>&#39;{print $4}&#39;</span>
<span style=color:#75715e># 输出：www.baidu.com</span>

<span style=color:#75715e>#获取端口</span>
echo <span style=color:#e6db74>&#34;http://www.baidu.com:80/ABCD/a.txt&#34;</span> | awk -F<span style=color:#e6db74>&#39;[/:]&#39;</span> <span style=color:#e6db74>&#39;{print $5}&#39;</span>
<span style=color:#75715e># 输出 80</span>

<span style=color:#75715e>#获取Path</span>
echo <span style=color:#e6db74>&#34;http://www.baidu.com:80/ABCD/a.txt&#34;</span> | cut -d/ -f4-
<span style=color:#75715e># 输出 ABCD/a.txt</span>
</code></pre></div><h2 id=内存>内存
<a class=anchor href=#%e5%86%85%e5%ad%98>#</a></h2><h3 id=内存使用情况buff和cache有什么区别>内存使用情况buff和cache有什么区别？
<a class=anchor href=#%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5buff%e5%92%8ccache%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab>#</a></h3><ul><li>都是为了解决内存和IO设备的读写速度不对等的中间缓存，两个都是内存的一部分</li><li>cached 把读取过的数据保存起来，重新读取的时候命中就不用读磁盘了，如果没有命中就会按频率更新cached</li><li>buffers 把分散的写操作集中起来，缓存要输出到io设备的数据（写一次就存一下硬盘贼耗时间，都是缓冲一会再一起写硬盘）</li><li>拓展一个shared，是共享内存，可以ipcs来查看</li></ul><h2 id=虚拟地址和物理地址有什么区别程序编译运行后首先申请到的是什么地址>虚拟地址和物理地址有什么区别，程序编译运行后首先申请到的是什么地址？
<a class=anchor href=#%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e5%92%8c%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab%e7%a8%8b%e5%ba%8f%e7%bc%96%e8%af%91%e8%bf%90%e8%a1%8c%e5%90%8e%e9%a6%96%e5%85%88%e7%94%b3%e8%af%b7%e5%88%b0%e7%9a%84%e6%98%af%e4%bb%80%e4%b9%88%e5%9c%b0%e5%9d%80>#</a></h2><p>因为位数代表最大寻址能力，32位最大寻址能力是4G所以超过4g的内存条会造成浪费</p><p>我们知道线程是cpu调度的最小单元，进程是资源分配的最小单元，每个进程之间的资源是独立的，互不影响的，这是怎么实现的呢？</p><p>每个进程启动的时候会有独立内存空间，称为虚拟内存，启动时为给每个进程维护一个独立的页表做虚拟内存和物理内存的映射</p><p>所以不同进程之间的虚拟内存地址可能是相同的，这没关系，最终映射到的是物理内存不是一个</p><p>假如不同进程都访问某个系统的库，就不需要加载两遍到物理内存上，只要映射到同一地址范围就可以</p><p>用到了再分配这种机制叫内存的惰性加载。</p><p>虚拟内存寻址是cpu到一个叫mmu的硬件，物理内存寻址是mmu到内存条，mmu相当于是个外包</p><p>所以虚拟内存虽然大，不一定全部都存在映射，之前说的堆栈空间也是在虚拟内存中的</p><h2 id=运维>运维
<a class=anchor href=#%e8%bf%90%e7%bb%b4>#</a></h2><h3 id=怎么定位进程cpu占用大是哪一个函数导致的>怎么定位进程cpu占用大是哪一个函数导致的？
<a class=anchor href=#%e6%80%8e%e4%b9%88%e5%ae%9a%e4%bd%8d%e8%bf%9b%e7%a8%8bcpu%e5%8d%a0%e7%94%a8%e5%a4%a7%e6%98%af%e5%93%aa%e4%b8%80%e4%b8%aa%e5%87%bd%e6%95%b0%e5%af%bc%e8%87%b4%e7%9a%84>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>perf top -g -p <span style=color:#ae81ff>246</span>
</code></pre></div><p><img src=.gitbook/assets/2021-03-17-19-59-30.png alt></p><p>这里推荐</p><p><img src=.gitbook/assets/2021-03-17-19-59-39.png alt="优惠口令： Happy2021"></p><h2 id=什么是程序的堆空间和栈空间>什么是程序的堆空间和栈空间？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%a0%86%e7%a9%ba%e9%97%b4%e5%92%8c%e6%a0%88%e7%a9%ba%e9%97%b4>#</a></h2><p>回答者：海翔</p><p>栈是用来保证程序顺序执行的，后入栈的函数先出，完整记录一个函数（方法）调用从开始到结束所做的一切操作。</p><p>堆是用来保存变量和对象的，存储临时数据和部分运行时数据。包括函数调用期间产生的临时变量，程序加载启动时载入的全局变量等等。堆内存的分配，应该是在临时变量第一次被使用时分配，全局静态变量是在类加载时分配。不同的变量有不同的生命周期。而垃圾回收，主要也是针对堆内存空间的调整和释放</p><p>栈和堆都有其空间大小。</p><p>当递归层级过深时会出现栈溢出异常，就是因为要保存的方法栈超过了栈可保存的最大数量。而堆内存不足时常常会遇到OOM异常，堆内存不足以存放新生成的对象或变量了。</p><h2 id=日志归档和清空有哪些方式>日志归档和清空有哪些方式
<a class=anchor href=#%e6%97%a5%e5%bf%97%e5%bd%92%e6%a1%a3%e5%92%8c%e6%b8%85%e7%a9%ba%e6%9c%89%e5%93%aa%e4%ba%9b%e6%96%b9%e5%bc%8f>#</a></h2><p>归档：logrotate 支持归档和删除长期日志</p><p>代码级别可以使用滚动日志组件</p><p>如果是手动删除可以使用cat /dev/null > xxx.log</p><h2 id=如果linux系统卡死操作系统比较慢排查思路>如果linux系统卡死，操作系统比较慢，排查思路？
<a class=anchor href=#%e5%a6%82%e6%9e%9clinux%e7%b3%bb%e7%bb%9f%e5%8d%a1%e6%ad%bb%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%af%94%e8%be%83%e6%85%a2%e6%8e%92%e6%9f%a5%e6%80%9d%e8%b7%af>#</a></h2><ul><li>先使用top实时查看一下进程占cpu以及内存的情况，因为top是实时刷新的，比较直观</li><li>有时候刷新太快，进一步使用<code>ps -aux</code>可以查看哪些进程占cpu或者内存较高，如果需要急切恢复，可以<code>kill -9</code>杀进程来恢复。</li><li>有可能此进程只是一个子进程，那要使用<code>ps -ef | grep 进程ID</code>查找父进程</li></ul><p>看哪些日志</p><ul><li>messages日志，<code>/var/log</code>目录下，比较全，关键字<code>failed</code>、<code>error</code>、<code>false</code>，查看开机时间<code>Runtime journal</code></li><li>服务日志</li><li>dmesg日志，该日志是记录系统最近一次开机时加载的驱动信息，以及开机后键鼠等硬件的一些响应信息</li><li>如果是图形化服务器，查看<code>Xorg.0.log</code>日志，该日志是记录的图形化服务相关的一些日志信息，看一下图形化服务方面有什么异常没</li><li><code>.xsession-errors</code>日志，<code>root</code>用户在<code>/root</code>下，普通用户在<code>/home/username/</code>下），是隐藏文件，该日志信息是某用户环境下的图形化日志信息</li><li><code>lightdm.log</code>日志，该日志是和登录界面相关的一些日志信息，如果系统卡死的时候是在用户登录界面的时候卡死了，这个日志就有必要也看一眼</li><li>最后有可能是硬件问题</li></ul><h2 id=发散问题>发散问题
<a class=anchor href=#%e5%8f%91%e6%95%a3%e9%97%ae%e9%a2%98>#</a></h2><h3 id=linux-打开文件句柄写入一个文件时mv这个文件会发生什么>Linux 打开文件句柄写入一个文件时，mv这个文件会发生什么
<a class=anchor href=#linux-%e6%89%93%e5%bc%80%e6%96%87%e4%bb%b6%e5%8f%a5%e6%9f%84%e5%86%99%e5%85%a5%e4%b8%80%e4%b8%aa%e6%96%87%e4%bb%b6%e6%97%b6mv%e8%bf%99%e4%b8%aa%e6%96%87%e4%bb%b6%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88>#</a></h3><p>mv操作，目标文件的inode将等于源文件的inode；因此正在写入的文件被mv，数据仍然被写入到mv后的文件里，除非重新open</p><p>正在写入的文件被rm后，数据会被写入到系统缓存中，一直会耗尽所有可用的内存</p><h2 id=最后>最后
<a class=anchor href=#%e6%9c%80%e5%90%8e>#</a></h2><p>如果文中有误，欢迎提pr或者issue，<strong>一旦合并或采纳作为贡献奖励可以联系我直接无门槛</strong>加入
<a href=https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q>技术交流群</a></p><p>我是小熊，关注我，知道更多不知道的技术</p><p><img src=.gitbook/assets/2021-03-17-19-57-33.png alt></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./interview/linux.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#vim-三个模式>VIM 三个模式</a></li><li><a href=#文件属性>文件属性</a></li><li><a href=#链接>链接</a></li><li><a href=#获取文件内容>获取文件内容</a></li><li><a href=#数据流重定向>数据流重定向</a></li><li><a href=#排序指令sort>排序指令（sort）</a></li><li><a href=#正则表达式grep>正则表达式(grep)</a></li><li><a href=#查看进程>查看进程</a></li><li><a href=#查看子进程的命令>查看子进程的命令</a></li><li><a href=#查看线程号>查看线程号</a></li><li><a href=#查看线程cpu使用率>查看线程cpu使用率</a></li><li><a href=#查询linux文件被哪些pid读写>查询linux文件被哪些pid读写</a></li><li><a href=#获取url中协议域名端口和path>获取URL中协议、域名、端口和Path</a></li><li><a href=#内存>内存</a><ul><li><a href=#内存使用情况buff和cache有什么区别>内存使用情况buff和cache有什么区别？</a></li></ul></li><li><a href=#虚拟地址和物理地址有什么区别程序编译运行后首先申请到的是什么地址>虚拟地址和物理地址有什么区别，程序编译运行后首先申请到的是什么地址？</a></li><li><a href=#运维>运维</a><ul><li><a href=#怎么定位进程cpu占用大是哪一个函数导致的>怎么定位进程cpu占用大是哪一个函数导致的？</a></li></ul></li><li><a href=#什么是程序的堆空间和栈空间>什么是程序的堆空间和栈空间？</a></li><li><a href=#日志归档和清空有哪些方式>日志归档和清空有哪些方式</a></li><li><a href=#如果linux系统卡死操作系统比较慢排查思路>如果linux系统卡死，操作系统比较慢，排查思路？</a></li><li><a href=#发散问题>发散问题</a><ul><li><a href=#linux-打开文件句柄写入一个文件时mv这个文件会发生什么>Linux 打开文件句柄写入一个文件时，mv这个文件会发生什么</a></li></ul></li><li><a href=#最后>最后</a></li></ul></nav></div></aside></main></body></html>