<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Mysql #  数据类型 #   整型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间 浮点数：FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型 字符串： CHAR（定长） 和 VARCHAR（变长的） 时间日期：date、datetime、timestamp（比DATETIME 空间效率更高）  存储引擎：myisam和innodb的区别是什么 #  答者：狸追
 innodb 支持事务和外键，最小锁粒度是行级锁，myisam 不支持事务和外键，最小锁粒度是表级锁，间歇锁 innodb 的索引如果是聚簇索引，叶子节点上保存的是数据和索引，非聚簇索引，节点上保存的是id，而myisam保存的是数据的地址（相当于一个指针） myisam 的表可以没有索引，innodb一定要有索引 myisam 会保存总行数，innodb是全表扫描 总结：对于大量更新、插入、删除，innodb性能上更好，因为他具备的事务、行级锁、B+树等特点，更安全，因为回滚和崩溃恢复更适合大型应用 经过测试在单进程读的情况下myisam执行速度比innodb更快，但是多进程读的时候就失去优势了 mysql5.5版本之后默认innodb  展开说
 MyISAM：  拥有较高的插入，查询速度 不支持事务 支持表级锁 不支持MVCC 不支持外键 支持全文索引 内部维护了一个计数器，selectcount更快   InnoDB ：插入缓冲（insert buffer)、二次写(double write)、自适应哈希索引(ahi)、预读(read ahead)  5.5版本后Mysql的默认数据库 支持ACID事务 支持行级锁定 支持MVCC 支持外键 不支持全文索引 不建议使用过长的字段作为主键：因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。 不建议用非单调的字段作为主键：因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 特殊的功能“自适应哈希索引”：当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引（B+Tree 索引具有哈希索引的一些优点）    主从复制 #   主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中 从：sql执行线程——执行relay log中的语句  索引类型 #   普通索引 唯一索引：索引列的值必须唯一，但允许有空值 主键索引：特殊的唯一索引，一个表只能有一个主键，不允许有空值 组合索引：在查询条件中使用了创建索引时的第一个字段，索引才会被使用。遵循最左前缀集合 全文索引：主要用来查找文本中的关键字（MATCH AGAINST） Mysql8新特性降序索引  聚集索引（主键索引）和非聚集索引 #  索引按照数据结构来说主要包含B+树和Hash索引。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="Mysql #  数据类型 #   整型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间 浮点数：FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型 字符串： CHAR（定长） 和 VARCHAR（变长的） 时间日期：date、datetime、timestamp（比DATETIME 空间效率更高）  存储引擎：myisam和innodb的区别是什么 #  答者：狸追
 innodb 支持事务和外键，最小锁粒度是行级锁，myisam 不支持事务和外键，最小锁粒度是表级锁，间歇锁 innodb 的索引如果是聚簇索引，叶子节点上保存的是数据和索引，非聚簇索引，节点上保存的是id，而myisam保存的是数据的地址（相当于一个指针） myisam 的表可以没有索引，innodb一定要有索引 myisam 会保存总行数，innodb是全表扫描 总结：对于大量更新、插入、删除，innodb性能上更好，因为他具备的事务、行级锁、B+树等特点，更安全，因为回滚和崩溃恢复更适合大型应用 经过测试在单进程读的情况下myisam执行速度比innodb更快，但是多进程读的时候就失去优势了 mysql5.5版本之后默认innodb  展开说
 MyISAM：  拥有较高的插入，查询速度 不支持事务 支持表级锁 不支持MVCC 不支持外键 支持全文索引 内部维护了一个计数器，selectcount更快   InnoDB ：插入缓冲（insert buffer)、二次写(double write)、自适应哈希索引(ahi)、预读(read ahead)  5.5版本后Mysql的默认数据库 支持ACID事务 支持行级锁定 支持MVCC 支持外键 不支持全文索引 不建议使用过长的字段作为主键：因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。 不建议用非单调的字段作为主键：因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 特殊的功能“自适应哈希索引”：当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引（B+Tree 索引具有哈希索引的一些优点）    主从复制 #   主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中 从：sql执行线程——执行relay log中的语句  索引类型 #   普通索引 唯一索引：索引列的值必须唯一，但允许有空值 主键索引：特殊的唯一索引，一个表只能有一个主键，不允许有空值 组合索引：在查询条件中使用了创建索引时的第一个字段，索引才会被使用。遵循最左前缀集合 全文索引：主要用来查找文本中的关键字（MATCH AGAINST） Mysql8新特性降序索引  聚集索引（主键索引）和非聚集索引 #  索引按照数据结构来说主要包含B+树和Hash索引。"><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/interview/mysql/"><meta property="article:section" content="interview"><title>Mysql | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fa55d4ab6347cff8bc3ae9cefd152a646ed2f9d06f23a24af15f5f4aeb5f3414.js integrity="sha256-+lXUq2NHz/i8OunO/RUqZG7S+dBvI6JK8V9fSutfNBQ=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/>Linux</a></li><li><a href=/interview/go/><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/>Java</a></li><li><a href=/interview/redis/>Redis</a></li><li><a href=/interview/mysql/ class=active>Mysql</a></li><li><a href=/interview/queue/>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/ class=active><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Mysql</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#数据类型>数据类型</a></li><li><a href=#存储引擎myisam和innodb的区别是什么>存储引擎：myisam和innodb的区别是什么</a></li><li><a href=#主从复制>主从复制</a></li><li><a href=#索引类型>索引类型</a></li><li><a href=#聚集索引主键索引和非聚集索引>聚集索引（主键索引）和非聚集索引</a></li><li><a href=#索引数据结构>索引数据结构</a></li><li><a href=#索引优化>索引优化</a></li><li><a href=#索引高度有多高>索引高度有多高</a></li><li><a href=#事务的实现>事务的实现</a></li><li><a href=#autocommit>AUTOCOMMIT</a></li><li><a href=#mysql锁技术>mysql锁技术</a></li><li><a href=#mvcc基础>MVCC基础</a></li><li><a href=#并发一致性问题>并发一致性问题</a></li><li><a href=#事务的隔离级别级别由低到高>事务的隔离级别（级别由低到高）</a></li></ul></li><li><a href=#查询性能优化>查询性能优化</a></li><li><a href=#高并发架构>高并发架构</a><ul><li><a href=#演进>演进</a></li><li><a href=#数据库分库分表>数据库分库分表</a></li><li><a href=#什么是乐观锁和悲观锁>什么是乐观锁和悲观锁</a></li><li><a href=#cas与aba问题>CAS与ABA问题</a></li><li><a href=#最后>最后</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=mysql>Mysql
<a class=anchor href=#mysql>#</a></h1><h3 id=数据类型>数据类型
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>#</a></h3><ul><li>整型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间</li><li>浮点数：FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型</li><li>字符串： CHAR（定长） 和 VARCHAR（变长的）</li><li>时间日期：date、datetime、timestamp（比DATETIME 空间效率更高）</li></ul><h3 id=存储引擎myisam和innodb的区别是什么>存储引擎：myisam和innodb的区别是什么
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8emyisam%e5%92%8cinnodb%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88>#</a></h3><p>答者：狸追</p><ul><li>innodb 支持事务和外键，最小锁粒度是行级锁，myisam 不支持事务和外键，最小锁粒度是表级锁，间歇锁</li><li>innodb 的索引如果是聚簇索引，叶子节点上保存的是数据和索引，非聚簇索引，节点上保存的是id，而myisam保存的是数据的地址（相当于一个指针）</li><li>myisam 的表可以没有索引，innodb一定要有索引</li><li>myisam 会保存总行数，innodb是全表扫描</li><li>总结：对于大量更新、插入、删除，innodb性能上更好，因为他具备的事务、行级锁、B+树等特点，更安全，因为回滚和崩溃恢复更适合大型应用</li><li>经过测试在单进程读的情况下myisam执行速度比innodb更快，但是多进程读的时候就失去优势了</li><li>mysql5.5版本之后默认innodb</li></ul><p>展开说</p><ul><li>MyISAM：<ul><li>拥有较高的插入，查询速度</li><li>不支持事务</li><li>支持表级锁</li><li>不支持MVCC</li><li>不支持外键</li><li>支持全文索引</li><li>内部维护了一个计数器，selectcount更快</li></ul></li><li>InnoDB ：插入缓冲（insert buffer)、二次写(double write)、自适应哈希索引(ahi)、预读(read ahead)<ul><li>5.5版本后Mysql的默认数据库</li><li>支持ACID事务</li><li>支持行级锁定</li><li>支持MVCC</li><li>支持外键</li><li>不支持全文索引</li><li>不建议使用过长的字段作为主键：因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</li><li>不建议用非单调的字段作为主键：因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li><li>特殊的功能“自适应哈希索引”：当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引（B+Tree 索引具有哈希索引的一些优点）</li></ul></li></ul><h3 id=主从复制>主从复制
<a class=anchor href=#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6>#</a></h3><ul><li><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中</li><li><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中</li><li><strong>从</strong>：sql执行线程——执行relay log中的语句</li></ul><h3 id=索引类型>索引类型
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b>#</a></h3><ul><li>普通索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>主键索引：特殊的唯一索引，一个表只能有一个主键，不允许有空值</li><li>组合索引：在查询条件中使用了创建索引时的第一个字段，索引才会被使用。遵循最左前缀集合</li><li>全文索引：主要用来查找文本中的关键字（MATCH AGAINST）</li><li>Mysql8新特性降序索引</li></ul><h3 id=聚集索引主键索引和非聚集索引>聚集索引（主键索引）和非聚集索引
<a class=anchor href=#%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e5%92%8c%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95>#</a></h3><p>索引按照数据结构来说主要包含B+树和Hash索引。</p><ul><li><code>MyISAM</code> 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址</li><li>聚簇索引：innodb中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，也就是说节点只包含id索引，叶子节点同时保存索引和数据，这种数据和索引在一起的方式就是聚簇索引有主键使用主键，没有主键就用唯一非空索引代替，如果没有会隐式定义一个主键，一张表只能有一个聚簇索引</li><li>非聚集索引：innodb的非聚集索引的叶子节点上的<code>data</code>是主键。（为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证）</li></ul><h3 id=索引数据结构>索引数据结构
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h3><h4 id=btree-索引>B+Tree 索引
<a class=anchor href=#btree-%e7%b4%a2%e5%bc%95>#</a></h4><ul><li>MySQL 存储引擎的默认索引类型</li><li>BTREE 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问</li><li>B-tree 索引可以用于使用 =, >, >=, &lt;, &lt;= 或者 BETWEEN 运算符的列比较</li><li>B+ Tree 的有序性，可以用于排序和分组</li><li>InnoDB 的 B+Tree 索引分为主索引和辅助索引<ul><li>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引（一个表只有一个：数据行不能存放个）</li><li>辅助索引的叶子节点的 data 域记录着主键的值。使用辅助索引进行查找，先查找主键值，再到主索引中进行查找</li></ul></li><li>MyISAM的 B+Tree 索引分为主索引和辅助索引<ul><li>和InnoDB不同，data域保存数据记录的地址</li><li>主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复</li></ul></li></ul><h4 id=hash-索引>Hash 索引
<a class=anchor href=#hash-%e7%b4%a2%e5%bc%95>#</a></h4><ul><li>检索效率非常高，索引的检索可以一次定位</li><li>仅仅能满足"=",&ldquo;IN"和&rdquo;&lt;=>&ldquo;查询，不能使用范围查询。</li><li>无法用于排序与分组</li><li>Hash 索引不能利用部分索引键查询。</li><li>Hash 索引在任何时候都不能避免表扫描。</li><li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li></ul><h3 id=索引优化>索引优化
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96>#</a></h3><ul><li>独立的列：索引列不能是表达式的一部分，也不能是函数的参数</li><li>多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好</li><li>索引列的顺序：让选择性（不重复的索引值和记录总数的比值）最强的索引列放在前面</li><li>前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符</li><li>覆盖索引：索引包含所有需要查询的字段的值</li></ul><h3 id=索引高度有多高>索引高度有多高
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e9%ab%98%e5%ba%a6%e6%9c%89%e5%a4%9a%e9%ab%98>#</a></h3><h3 id=事务的实现>事务的实现
<a class=anchor href=#%e4%ba%8b%e5%8a%a1%e7%9a%84%e5%ae%9e%e7%8e%b0>#</a></h3><ul><li>事务的<strong>原子性</strong>是通过 undo log（回滚日志） 来实现的</li><li>事务的<strong>持久性</strong>是通过 redo log（重做日志） 来实现的</li><li>事务的<strong>隔离性</strong>是通过 (读写锁+MVCC)来实现的</li><li>事务的<strong>一致性</strong>是通过原子性，持久性，隔离性来实现的</li></ul><p><img src=.gitbook/assets/2021-03-26-16-33-13.png alt></p><h3 id=autocommit>AUTOCOMMIT
<a class=anchor href=#autocommit>#</a></h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p><h3 id=mysql锁技术>mysql锁技术
<a class=anchor href=#mysql%e9%94%81%e6%8a%80%e6%9c%af>#</a></h3><ul><li>读写锁</li><li>共享锁(shared lock),又叫做"读锁</li><li>排他锁(exclusive lock),又叫做"写锁&rdquo;</li></ul><h3 id=mvcc基础>MVCC基础
<a class=anchor href=#mvcc%e5%9f%ba%e7%a1%80>#</a></h3><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列， 一个保存了行的创建时间，一个保存了行的过期时间， 当然存储的并不是实际的时间值，而是系统版本号。
</code></pre></div><p>通过<strong>数据多版本</strong>来做到<strong>读写分离</strong>。从而实现不加锁读进而做到读写并行</p><h3 id=并发一致性问题>并发一致性问题
<a class=anchor href=#%e5%b9%b6%e5%8f%91%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98>#</a></h3><ul><li>丢失修改：一个事务的更新操作被另外一个事务的更新操作替换</li><li>脏读：在不同的事务下，当前事务可以读到另外事务未提交的数据</li><li>不可重复读：一个事务内多次读取同一数据集合</li><li>幻读：针对插入语句，一个update，一个insert，update之后发现有未更新数据</li></ul><h3 id=事务的隔离级别级别由低到高>事务的隔离级别（级别由低到高）
<a class=anchor href=#%e4%ba%8b%e5%8a%a1%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e7%ba%a7%e5%88%ab%e7%94%b1%e4%bd%8e%e5%88%b0%e9%ab%98>#</a></h3><ul><li><strong>READ UNCOMMITED</strong> (未提交读) ：事务中的修改，即使没有提交，对其它事务也是可见的（读的过程中写，脏读，<strong>读写并行</strong>）</li><li><strong>READ COMMITED</strong> (提交读)：一个事务只能读取已经提交的事务所做的修改（排它锁，<strong>读写分离机制</strong>，产生<strong>不可重读</strong>以及<strong>幻读</strong>问题）</li><li><strong>REPEATABLE READ</strong> (可重复读)（默认级别）：保证在同一个事务中多次读取同一数据的结果是一样的（<strong>读写锁实现</strong>or<strong>MVCC实现</strong>）</li><li><strong>SERIALIZABLE</strong> (串行)</li></ul><p><img src=.gitbook/assets/2021-03-26-16-33-38.png alt></p><h2 id=查询性能优化>查询性能优化
<a class=anchor href=#%e6%9f%a5%e8%af%a2%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96>#</a></h2><ul><li>使用 Explain分析SELECT语句<ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul></li><li>优化数据访问<ul><li>减少请求的数据量<ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据</li></ul></li><li>减少服务器端扫描的行数：索引</li></ul></li><li>重构查询方式<ul><li>切分大查询</li><li>分解大连接查询：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联</li></ul></li></ul><h2 id=高并发架构>高并发架构
<a class=anchor href=#%e9%ab%98%e5%b9%b6%e5%8f%91%e6%9e%b6%e6%9e%84>#</a></h2><p>关键字：分布式、高可用、集群、负载均衡、正/反代理</p><h3 id=演进>演进
<a class=anchor href=#%e6%bc%94%e8%bf%9b>#</a></h3><ol><li>应用与数据库分离：增加服务器资源，提高性能</li><li>本地缓存和分布式缓存：使用memcached作为本地缓存，使用Redis作为分布式缓存，减小数据库的压力</li><li>反向代理（Nginx）实现负载均衡</li><li>数据库的读写分离</li><li>数据分库（按业务）</li><li>把大表拆分为小表</li><li>使用LVS或F5来使多个Nginx负载均衡(四层的负载均衡解决方案)</li><li>通过DNS轮询实现机房间的负载均衡</li><li>引入NoSQL数据库和搜索引擎等技术</li><li>大应用拆分为小应用</li><li>复用的功能抽离成微服务</li><li>引入企业服务总线ESB屏蔽服务接口的访问差异</li><li>引入容器化技术实现运行环境隔离与动态服务管理</li><li>以云平台承载系统</li></ol><h3 id=数据库分库分表>数据库分库分表
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8>#</a></h3><h4 id=为什么要分库分表>为什么要分库分表？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8>#</a></h4><ul><li>数据量达到几千万时查询时间变多，无论表级锁还是行级锁，联合查询大概率阻塞严重(索引膨胀、查询超时)</li><li>对于大表要进行表结构DDL几乎不可能</li><li>从Innodb本身来讲数据文件的Btree上只有两个锁, 叶子节点锁和子节点锁, 可以想而知道, 当发生页拆分或是添加新叶时都会造成表里不能写入数据</li></ul><h4 id=方式>方式
<a class=anchor href=#%e6%96%b9%e5%bc%8f>#</a></h4><ul><li>垂直分表（大表拆小表）：将不经常使用或者长度较大的字段拆分出去放到“扩展表”中（设计阶段考虑）</li><li>垂直分库：按照业务模块来划分出不同的数据库</li><li>水平分表（横向分表）：降低单表数据量，优化查询性能（主键hash或取模）</li><li>水平分库分表：水平分表+分库</li></ul><h4 id=多久分一个表>多久分一个表
<a class=anchor href=#%e5%a4%9a%e4%b9%85%e5%88%86%e4%b8%80%e4%b8%aa%e8%a1%a8>#</a></h4><ul><li>大数据量并且访问频繁的表，应该拆分成多个表</li><li>经测试在单表1000万条记录以下，写入读取性能是比较好的，再留点buffer, 那么单表全是数据字型的保持在800万条记录以下, 有字符型的单表保持在500万以下。</li><li>最好是提前规划预估表数据量，方便做分页查询，减少数据清洗</li></ul><h4 id=多久分一个库>多久分一个库？
<a class=anchor href=#%e5%a4%9a%e4%b9%85%e5%88%86%e4%b8%80%e4%b8%aa%e5%ba%93>#</a></h4><ul><li>单台数据库服务器存储空间、cpu、内存、网络io等因素无法支撑，做水平拆分（分库）</li></ul><h4 id=用什么做分库分表>用什么做分库分表？
<a class=anchor href=#%e7%94%a8%e4%bb%80%e4%b9%88%e5%81%9a%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8>#</a></h4><p>使用mycat做分库分表，现在金融级别的分布式数据库可以考虑使用tidb，对水平伸缩和数据一致性有保证</p><h4 id=分表策略水平拆分>分表策略（水平拆分）
<a class=anchor href=#%e5%88%86%e8%a1%a8%e7%ad%96%e7%95%a5%e6%b0%b4%e5%b9%b3%e6%8b%86%e5%88%86>#</a></h4><ul><li>查询切分（不推荐），把ID和库的Mapping关系记录在一个单独的库中，又会引入新的单点压力问题</li><li>范围切分，按照id范围切分，单表大小可控，但集中写入会频繁操作单表</li><li>Hash切分，易于水平扩展, 例如：mod 32, 拆分32个库，每个库 div 32 mod 32 拆分32张表，就是<code>32*32=1024</code>张表，更多参考<code>(32*2^n)*(32⁄2^n)</code></li><li>其他业务相关：地理位置、时间</li></ul><p>引用
<a href=https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html>大众点评订单系统分库分表实践 - 美团技术团队</a></p><h4 id=产生的问题和解决思路>产生的问题和解决思路
<a class=anchor href=#%e4%ba%a7%e7%94%9f%e7%9a%84%e9%97%ae%e9%a2%98%e5%92%8c%e8%a7%a3%e5%86%b3%e6%80%9d%e8%b7%af>#</a></h4><ul><li>垂直分库->跨库Join<ul><li>全局表</li><li>字段冗余（数据一致性的问题）</li><li>数据同步</li><li>系统层组装（把不同的表放在不同的库，不同的库放在不同服务器上，但是联合查询无法从数据库层面做到）</li></ul></li><li>水平分库<ul><li>分布式全局唯一ID</li><li>分片规则<ul><li>随机分片和连续分片</li></ul></li><li>数据迁移，容量规划，扩容等问题</li><li>跨分片的排序分页（分别排序之后汇总再排序）</li><li>跨分片的函数处理</li><li>夸分片join</li></ul></li></ul><h4 id=怎么跨表查询还有排序和翻页怎么做的>怎么跨表查询，还有排序和翻页怎么做的？
<a class=anchor href=#%e6%80%8e%e4%b9%88%e8%b7%a8%e8%a1%a8%e6%9f%a5%e8%af%a2%e8%bf%98%e6%9c%89%e6%8e%92%e5%ba%8f%e5%92%8c%e7%bf%bb%e9%a1%b5%e6%80%8e%e4%b9%88%e5%81%9a%e7%9a%84>#</a></h4><p>issue</p><h4 id=分库分表有什么缺点怎么解决>分库分表有什么缺点？怎么解决？
<a class=anchor href=#%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%e6%9c%89%e4%bb%80%e4%b9%88%e7%bc%ba%e7%82%b9%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3>#</a></h4><ul><li>联合查询困难，关联的表可能不在同一数据库中</li><li>避免在同一个事务中修改不同库中的表，操作复杂，效率也会有影响</li><li>尽量把同一数据放在同一db服务器上，单点故障时不会影响其他数据</li></ul><h4 id=select-count-conunt1和count字段执行的效率有何不同>select count(*) conunt(1)和count(字段)执行的效率有何不同？
<a class=anchor href=#select-count-conunt1%e5%92%8ccount%e5%ad%97%e6%ae%b5%e6%89%a7%e8%a1%8c%e7%9a%84%e6%95%88%e7%8e%87%e6%9c%89%e4%bd%95%e4%b8%8d%e5%90%8c>#</a></h4><ol><li>count(primary key)。遍历整个表，把主键值拿出来，累加；</li><li>count(1)。遍历整个表，但是不取值，累加；</li><li>count(非空字段)。遍历整个表，读出这个字段，累加；</li><li>count(可以为空的字段)。遍历整个表，读出这个字段，判断不为null累加；</li><li>count(*)。遍历整个表，做了优化，不取值，累加。</li></ol><p>来自
<a href=https://www.zhihu.com/question/34781415/answer/767552025>胡慢慢滚雪球</a></p><h3 id=什么是乐观锁和悲观锁>什么是乐观锁和悲观锁
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e4%b9%90%e8%a7%82%e9%94%81%e5%92%8c%e6%82%b2%e8%a7%82%e9%94%81>#</a></h3><p>通常mysql中使用的都是悲观锁，分为共享锁和排他锁两种，共享锁也就是读锁，可以多个线程同时读，不能修改；排他锁是写锁，未获得锁的线程需要阻塞</p><p>乐观锁：假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。一般有两种实现方式<code>CAS</code>和基于版本号</p><p>引用：
<a href=https://www.jianshu.com/p/d2ac26ca6525>什么是乐观锁，什么是悲观锁</a></p><h3 id=cas与aba问题>CAS与ABA问题
<a class=anchor href=#cas%e4%b8%8eaba%e9%97%ae%e9%a2%98>#</a></h3><p><code>CAS</code>是乐观锁的实现方式之一，<code>CAS</code>操作包含三个操作数—— 内存位置的值（V）、预期原值（A）和新值（B），在更新的时候做检查，内存值必须与期望值相同。举个例子，内存值V、期望值A、更新值B，当V == A的时候将V更新为B。</p><p>ABA问题，某个值中间被改动又被改回来，<code>A-B-A</code>，用<code>CAS</code>是无法识别的，考虑通过控制变量值的版本号来保证<code>CAS</code>的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么<code>A - B - A</code>就会变成<code>1A - 2B - 3A</code>。</p><p>引用：
<a href=https://www.jianshu.com/p/db5c964a61ee>深入理解CAS</a></p><h3 id=最后>最后
<a class=anchor href=#%e6%9c%80%e5%90%8e>#</a></h3><p>如果文中有误，欢迎提pr或者issue，<strong>一旦合并或采纳作为贡献奖励可以联系我直接无门槛</strong>加入
<a href=https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q>技术交流群</a></p><p>我是小熊，关注我，知道更多不知道的技术</p><p><img src=.gitbook/assets/2021-03-17-19-57-33.png alt></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./interview/mysql.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#数据类型>数据类型</a></li><li><a href=#存储引擎myisam和innodb的区别是什么>存储引擎：myisam和innodb的区别是什么</a></li><li><a href=#主从复制>主从复制</a></li><li><a href=#索引类型>索引类型</a></li><li><a href=#聚集索引主键索引和非聚集索引>聚集索引（主键索引）和非聚集索引</a></li><li><a href=#索引数据结构>索引数据结构</a></li><li><a href=#索引优化>索引优化</a></li><li><a href=#索引高度有多高>索引高度有多高</a></li><li><a href=#事务的实现>事务的实现</a></li><li><a href=#autocommit>AUTOCOMMIT</a></li><li><a href=#mysql锁技术>mysql锁技术</a></li><li><a href=#mvcc基础>MVCC基础</a></li><li><a href=#并发一致性问题>并发一致性问题</a></li><li><a href=#事务的隔离级别级别由低到高>事务的隔离级别（级别由低到高）</a></li></ul></li><li><a href=#查询性能优化>查询性能优化</a></li><li><a href=#高并发架构>高并发架构</a><ul><li><a href=#演进>演进</a></li><li><a href=#数据库分库分表>数据库分库分表</a></li><li><a href=#什么是乐观锁和悲观锁>什么是乐观锁和悲观锁</a></li><li><a href=#cas与aba问题>CAS与ABA问题</a></li><li><a href=#最后>最后</a></li></ul></li></ul></nav></div></aside></main></body></html>