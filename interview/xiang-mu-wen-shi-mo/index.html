<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="项目一般问什么 #  项目问题因人而异，但是这些问题是共性的，可以思考一下 #   你最有成就感，或者最有挑战的项目经过，解决什么样的问题 数据量很大还是并发量很高，并发量体现在哪里？QPS是多少？ 怎么提高可用性的？ 技术难点体现在哪里？ 你的项目有没有出现什么重大事故/故障，是怎么解决的，具体是什么原因 有没有什么印象深刻的Bug  分布式锁如何实现 #  分布式锁，一般为了达到分布式加锁需要通过投票的机制，依次向所有节点申请加锁，半数以上节点投票通过完成加锁，可以避免单点故障（Redis称为Redlock算法）
 加锁的动作需要保证原子性，Redis通过Lua脚本来保证 谁加的锁谁来释放锁，所以需要标记锁来源 预防加锁程序挂掉导致的锁不释放，所以需要设置过期时间 加锁成功需要判断获取锁总耗时没有超过锁有效时间，这才判定为加锁成功  注意：假如程序处理速度比锁过期时间要长，是不合理的设计，超时时间的设置就很精细，一般都是远大于处理的时间，如果真的处理时间太长应该判定失败并告警
见 redis
如何实现一个分布式id生成器 #  首先要知道自增主键出现的问题
 在高并发的情况下加入事务执行失败回滚，会跳过当前插入ID，使ID不连续 所有数据库中的自增字段或者自增序列都要记录日志，会产生磁盘IO，会成为性能瓶颈 假如数据库使用的是Range分片，自增ID可能会集中写入集群中的一个节点，出现数据访问热地世，性能退化成单机写入  解决方案
 随机主键UUID方案（32 个的 16 进制数字，16^32 = 2^128 就是128位），虽然可以保证每次随机都不一样，但缺点是键值长度过长，存储和计算的代价增加，uuid只能保证不重复，但数据页可能会分裂，影响查询性能 号段模式，每个业务批量获取数据库中的号段，比如一次获取1000个，然后内存生成1000个自增ID，使用完再获取1000个；只需要插入一条记录，步长设置为1000，注意使用乐观锁（维护版本号），记录字段有业务类型、当前最大可用id、号段步长，version号；缺点服务重启时重新申请号段，不够随机有被猜到的风险 在TiDB 里提供了一种AutoRandom的算法，生成64位整型随机ID，1bit符号位、5bit事务开始时间，58bit自增序列号，还是有可能出现尾部热点 雪花算法Snowflake，时间戳精确到毫秒，10位长度机器码最大规模1024个节点(2^10), 12位序列代表1毫秒能产生的id数量最多4096个。所以 TPS 可以达到 419 万左右（2^22*1000）, 每秒那么多大多系统都够了   注意雪花算法，对时间的要求比较高，如果时间不同步，时钟回拨时 ID 有可能出现重复
引用： 分布式数据库30讲
如何优化雪花算法的问题 #  雪花算法的问题主要在于时间回拨出现id重复、机器id有上限
时钟回拨就是本机时间略快，完成时间服务器的校准（NTP或者闰秒回拨）以后，会出现时间倒退，导致生成ID重复
时钟回拨解决办法：
 继续在当前ID序列号最大基础上增加，方案来自 snowflake算法的时钟回拨问题如何解决 如果时间偏差比较小，<=5ms 可以等待2倍时间，牺牲很短时间的可用性，方案来自 SnowFlakeID原理和改进优化 时间回拨跨度太大时告警，并摘除本身节点，只会影响一个节点 也可以考虑直接关闭时间同步  机器id有上限的解决办法（雪花算法优化）"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="项目一般问什么 #  项目问题因人而异，但是这些问题是共性的，可以思考一下 #   你最有成就感，或者最有挑战的项目经过，解决什么样的问题 数据量很大还是并发量很高，并发量体现在哪里？QPS是多少？ 怎么提高可用性的？ 技术难点体现在哪里？ 你的项目有没有出现什么重大事故/故障，是怎么解决的，具体是什么原因 有没有什么印象深刻的Bug  分布式锁如何实现 #  分布式锁，一般为了达到分布式加锁需要通过投票的机制，依次向所有节点申请加锁，半数以上节点投票通过完成加锁，可以避免单点故障（Redis称为Redlock算法）
 加锁的动作需要保证原子性，Redis通过Lua脚本来保证 谁加的锁谁来释放锁，所以需要标记锁来源 预防加锁程序挂掉导致的锁不释放，所以需要设置过期时间 加锁成功需要判断获取锁总耗时没有超过锁有效时间，这才判定为加锁成功  注意：假如程序处理速度比锁过期时间要长，是不合理的设计，超时时间的设置就很精细，一般都是远大于处理的时间，如果真的处理时间太长应该判定失败并告警
见 redis
如何实现一个分布式id生成器 #  首先要知道自增主键出现的问题
 在高并发的情况下加入事务执行失败回滚，会跳过当前插入ID，使ID不连续 所有数据库中的自增字段或者自增序列都要记录日志，会产生磁盘IO，会成为性能瓶颈 假如数据库使用的是Range分片，自增ID可能会集中写入集群中的一个节点，出现数据访问热地世，性能退化成单机写入  解决方案
 随机主键UUID方案（32 个的 16 进制数字，16^32 = 2^128 就是128位），虽然可以保证每次随机都不一样，但缺点是键值长度过长，存储和计算的代价增加，uuid只能保证不重复，但数据页可能会分裂，影响查询性能 号段模式，每个业务批量获取数据库中的号段，比如一次获取1000个，然后内存生成1000个自增ID，使用完再获取1000个；只需要插入一条记录，步长设置为1000，注意使用乐观锁（维护版本号），记录字段有业务类型、当前最大可用id、号段步长，version号；缺点服务重启时重新申请号段，不够随机有被猜到的风险 在TiDB 里提供了一种AutoRandom的算法，生成64位整型随机ID，1bit符号位、5bit事务开始时间，58bit自增序列号，还是有可能出现尾部热点 雪花算法Snowflake，时间戳精确到毫秒，10位长度机器码最大规模1024个节点(2^10), 12位序列代表1毫秒能产生的id数量最多4096个。所以 TPS 可以达到 419 万左右（2^22*1000）, 每秒那么多大多系统都够了   注意雪花算法，对时间的要求比较高，如果时间不同步，时钟回拨时 ID 有可能出现重复
引用： 分布式数据库30讲
如何优化雪花算法的问题 #  雪花算法的问题主要在于时间回拨出现id重复、机器id有上限
时钟回拨就是本机时间略快，完成时间服务器的校准（NTP或者闰秒回拨）以后，会出现时间倒退，导致生成ID重复
时钟回拨解决办法：
 继续在当前ID序列号最大基础上增加，方案来自 snowflake算法的时钟回拨问题如何解决 如果时间偏差比较小，<=5ms 可以等待2倍时间，牺牲很短时间的可用性，方案来自 SnowFlakeID原理和改进优化 时间回拨跨度太大时告警，并摘除本身节点，只会影响一个节点 也可以考虑直接关闭时间同步  机器id有上限的解决办法（雪花算法优化）"><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/interview/xiang-mu-wen-shi-mo/"><meta property="article:section" content="interview"><title>Xiang Mu Wen Shi Mo | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.9743218a9b114aeb464b4ee93a2e447b8c9df2a07e1de157caa2f0c8a81fadb7.js integrity="sha256-l0MhipsRSutGS07pOi5Ee4yd8qB+HeFXyqLwyKgfrbc=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/ class=active>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/>Linux</a></li><li><a href=/interview/go/><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/>Java</a></li><li><a href=/interview/redis/>Redis</a></li><li><a href=/interview/mysql/>Mysql</a></li><li><a href=/interview/queue/>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Xiang Mu Wen Shi Mo</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#项目问题因人而异但是这些问题是共性的可以思考一下>项目问题因人而异，但是这些问题是共性的，可以思考一下</a></li><li><a href=#分布式锁如何实现>分布式锁如何实现</a></li><li><a href=#如何实现一个分布式id生成器>如何实现一个分布式id生成器</a></li><li><a href=#如何优化雪花算法的问题>如何优化雪花算法的问题</a></li><li><a href=#如何实现秒杀系统>如何实现秒杀系统</a></li><li><a href=#容灾>容灾</a></li><li><a href=#追踪链的traceid是怎么生成的>追踪链的traceid是怎么生成的</a></li></ul></nav></aside></header><article class=markdown><h1 id=项目一般问什么>项目一般问什么
<a class=anchor href=#%e9%a1%b9%e7%9b%ae%e4%b8%80%e8%88%ac%e9%97%ae%e4%bb%80%e4%b9%88>#</a></h1><h2 id=项目问题因人而异但是这些问题是共性的可以思考一下>项目问题因人而异，但是这些问题是共性的，可以思考一下
<a class=anchor href=#%e9%a1%b9%e7%9b%ae%e9%97%ae%e9%a2%98%e5%9b%a0%e4%ba%ba%e8%80%8c%e5%bc%82%e4%bd%86%e6%98%af%e8%bf%99%e4%ba%9b%e9%97%ae%e9%a2%98%e6%98%af%e5%85%b1%e6%80%a7%e7%9a%84%e5%8f%af%e4%bb%a5%e6%80%9d%e8%80%83%e4%b8%80%e4%b8%8b>#</a></h2><ul><li>你最有成就感，或者最有挑战的项目经过，解决什么样的问题</li><li>数据量很大还是并发量很高，并发量体现在哪里？QPS是多少？</li><li>怎么提高可用性的？</li><li>技术难点体现在哪里？</li><li>你的项目有没有出现什么重大事故/故障，是怎么解决的，具体是什么原因</li><li>有没有什么印象深刻的Bug</li></ul><h2 id=分布式锁如何实现>分布式锁如何实现
<a class=anchor href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0>#</a></h2><p>分布式锁，一般为了达到分布式加锁需要通过投票的机制，依次向所有节点申请加锁，半数以上节点投票通过完成加锁，可以避免单点故障（Redis称为Redlock算法）</p><ul><li>加锁的动作需要保证原子性，<code>Redis</code>通过<code>Lua</code>脚本来保证</li><li>谁加的锁谁来释放锁，所以需要标记锁来源</li><li>预防加锁程序挂掉导致的锁不释放，所以需要设置过期时间</li><li>加锁成功需要判断获取锁总耗时没有超过锁有效时间，这才判定为加锁成功</li></ul><p>注意：假如程序处理速度比锁过期时间要长，是不合理的设计，超时时间的设置就很精细，一般都是远大于处理的时间，如果真的处理时间太长应该判定失败并告警</p><p>见
<a href=/interview/redis/>redis</a></p><h2 id=如何实现一个分布式id生成器>如何实现一个分布式id生成器
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e5%88%86%e5%b8%83%e5%bc%8fid%e7%94%9f%e6%88%90%e5%99%a8>#</a></h2><p>首先要知道自增主键出现的问题</p><ul><li>在高并发的情况下加入事务执行失败回滚，会跳过当前插入<code>ID</code>，使<code>ID</code>不连续</li><li>所有数据库中的自增字段或者自增序列都要记录日志，会产生磁盘IO，会成为性能瓶颈</li><li>假如数据库使用的是Range分片，自增<code>ID</code>可能会集中写入集群中的一个节点，出现数据访问热地世，性能退化成单机写入</li></ul><p>解决方案</p><ul><li>随机主键<code>UUID</code>方案（32 个的 16 进制数字，16^32 = 2^128 就是128位），虽然可以保证每次随机都不一样，但缺点是键值长度过长，存储和计算的代价增加，uuid只能保证不重复，但数据页可能会分裂，影响查询性能</li><li>号段模式，每个业务批量获取数据库中的号段，比如一次获取1000个，然后内存生成1000个自增ID，使用完再获取1000个；只需要插入一条记录，步长设置为1000，注意使用乐观锁（维护版本号），记录字段有业务类型、当前最大可用id、号段步长，version号；缺点服务重启时重新申请号段，不够随机有被猜到的风险</li><li>在<code>TiDB</code> 里提供了一种<code>AutoRandom</code>的算法，生成64位整型随机<code>ID</code>，<code>1bit</code>符号位、<code>5bit</code>事务开始时间，<code>58bit</code>自增序列号，还是有可能出现尾部热点</li><li>雪花算法<code>Snowflake</code>，时间戳精确到毫秒，10位长度机器码最大规模1024个节点(2^10), 12位序列代表1毫秒能产生的id数量最多4096个。所以 <code>TPS</code> 可以达到 <code>419</code> 万左右（2^22*1000）, 每秒那么多大多系统都够了</li></ul><p><img src=.gitbook/assets/2021-04-12-15-27-47.png alt></p><p>注意雪花算法，对时间的要求比较高，如果时间不同步，时钟回拨时 <code>ID</code> 有可能出现重复</p><p>引用：
<a href=https://time.geekbang.org/column/article/285819>分布式数据库30讲</a></p><h2 id=如何优化雪花算法的问题>如何优化雪花算法的问题
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e9%9b%aa%e8%8a%b1%e7%ae%97%e6%b3%95%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h2><p>雪花算法的问题主要在于时间回拨出现<code>id</code>重复、机器id有上限</p><p>时钟回拨就是本机时间略快，完成时间服务器的校准（NTP或者闰秒回拨）以后，会出现时间倒退，导致生成ID重复</p><p>时钟回拨解决办法：</p><ul><li>继续在当前ID序列号最大基础上增加，方案来自
<a href=https://blog.csdn.net/qq_37286668/article/details/107292527>snowflake算法的时钟回拨问题如何解决</a></li><li>如果时间偏差比较小，<code>&lt;=5ms</code> 可以等待2倍时间，牺牲很短时间的可用性，方案来自
<a href=https://www.ctolib.com/topics-143347.html>SnowFlakeID原理和改进优化</a></li><li>时间回拨跨度太大时告警，并摘除本身节点，只会影响一个节点</li><li>也可以考虑直接关闭时间同步</li></ul><p>机器id有上限的解决办法（雪花算法优化）</p><ul><li>百度（uid-generator）的解决办法是可以自定义各部分的位数，工作机器<code>ID</code>需要数据库中创建一个表，插入机器相关信息（<code>host</code>和<code>port</code>），再根据表的自增<code>ID</code>作为<code>workID</code>，重启服务就另申请<code>workID</code></li><li>美团使用<code>Leaf</code>算法，可以基于号段模式或雪花算法，对号段模式优化
<a href=https://tech.meituan.com/2017/04/21/mt-leaf.html>双buffer方案</a>，提前加载下一号段；雪花算法借助<code>zookeeper</code>的持久顺序节点的特性配置<code>workID</code>(我想上容器的话直接使用hostname或者使用k8s中的sts也不错)</li></ul><p>注意雪花算法实际上是趋势递增，而不是绝对递增，这是为了保证性能</p><h2 id=如何实现秒杀系统>如何实现秒杀系统
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%a7%92%e6%9d%80%e7%b3%bb%e7%bb%9f>#</a></h2><p>漏斗的思路，是架构上设计，客户端，网关，后台服务，层层限流，保证业务处理不被流量洪峰打挂了</p><p>客户端侧降低服务端压力：</p><ul><li>动静分离，静态资源放到cdn（某些服务为了更新及时不能放cdn）、前端文件<code>webpack</code>打包减少请求量</li><li>减少后端请求数量，只保留抢按钮的请求</li><li>时间使用客户端时间，不到时候无法点击</li><li>增加互动游戏再降低并发请求量</li><li>秒杀活动一旦发起，不允许修改详情等信息</li><li>保证web安全，防止xss与重放（随机数、时间戳、序列号）、CSRF等攻击方式</li></ul><p>部署架构：</p><ul><li>后端服务部署多个可用区，防止单可用区故障导致整体不可用</li><li>需要配置安全策略：防火墙、防DDOS、API网关、WAF；接入风控挡掉不合法请求</li><li>使用负载均衡SLB，根据不同节点负载情况分发流量</li><li>硬件上使用SSD</li></ul><p>后端防护：</p><ul><li>防止超卖，推动库存确认流程到支付阶段</li><li>库存信息放到内存中(redis)</li><li>使用另外的数据库集群</li></ul><p>过载保护（有损保护）：</p><ul><li>服务降级：秒杀期间关闭某些服务，比如淘宝关闭退款流程，微信抢红包延迟到账</li><li>熔断：接入监控系统，根据系统节点的承载能力和服务质量有关，比如 CPU 的使用率超过 90%，请求错误率超过 5%，请求延迟超过 500ms， 它们中的任意一个满足条件就会出现熔断，主动拒绝请求；</li><li>限流：速度过快时加入验证码流程，接入API网关可以进行流量控制，请求过滤和控制，并过滤的请求，前端根据错误码返回友好的页面（已抢完之类）常见限流算法：漏桶>令牌桶>滑动窗口>计数器</li></ul><h2 id=容灾>容灾
<a class=anchor href=#%e5%ae%b9%e7%81%be>#</a></h2><p>假如某个节点无法拉起，或者量级大被打挂了</p><h2 id=追踪链的traceid是怎么生成的>追踪链的traceid是怎么生成的
<a class=anchor href=#%e8%bf%bd%e8%b8%aa%e9%93%be%e7%9a%84traceid%e6%98%af%e6%80%8e%e4%b9%88%e7%94%9f%e6%88%90%e7%9a%84>#</a></h2><p>traceID 一般由请求经过的第一个服务器生成，参考 <code>服务器 IP + 生成 ID 的时间 + 自增序列</code>，它的作用是把各个服务器上的调用日志串联起来</p><ul><li>前 8 位 0ad1348f 为生成 TraceId 的服务器 IP，这是一个十六进制的数字，每两位代表 IP 中的一段，把这个数字按每两位转成十进制即可得到常见的 IP 10.209.52.143，可以根据此规律来寻找请求经过的第一个服务器。</li><li>后 13 位 1403169275002 是生成 TraceId 的时间。</li><li>最后四位 1003 是一个自增序列，范围是 1000 到 9000，到达 9000 后回到 1000 再重新开始自增。</li></ul><p><a href=https://tech.antfin.com/docs/2/46947>TraceID生成规则-蚂蚁集团方案</a></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./interview/xiang-mu-wen-shi-mo.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#项目问题因人而异但是这些问题是共性的可以思考一下>项目问题因人而异，但是这些问题是共性的，可以思考一下</a></li><li><a href=#分布式锁如何实现>分布式锁如何实现</a></li><li><a href=#如何实现一个分布式id生成器>如何实现一个分布式id生成器</a></li><li><a href=#如何优化雪花算法的问题>如何优化雪花算法的问题</a></li><li><a href=#如何实现秒杀系统>如何实现秒杀系统</a></li><li><a href=#容灾>容灾</a></li><li><a href=#追踪链的traceid是怎么生成的>追踪链的traceid是怎么生成的</a></li></ul></nav></div></aside></main></body></html>