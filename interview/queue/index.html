<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="消息队列 #  如何保证队列数据一致性，防止重复消费，幂等性 #  所有的消息中间件在实际的业务场景中都逃脱不了保证消息的一致性的问题
kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，可以理解成一个自增持的序号，一个个排下来
然后消费者consumer，每隔一段时间，就把自己消费过的消息提交一下，如果说出现宕机或者重启，则会继续从上次消费的序号接着往下排，继续消费
但是有的时候，消费者consumer消费的消息，由于各种原因，比如网络、宕机、停电。。。都没来得及写offset,这个时候少数消息会再次消费一次
这个时候，我们可以用一个唯一的id标识来区分，这不是消息中间件做的事，而是开发者要做的，比如你消费一个就往数据库插入一条记录，然后下次再去消费的时候，你去查一下，看看这个消息是否被消费了，消费了那就不要重复消费了。
（补充一下：确认一条数据在百万级别海量数据里是否存在？&ndash;可以用布隆过滤器）
 根据主键查一下，如果这数据都有了，就别插入了，update一下（虽然重复插入会因为唯一键约束而报错，我觉得我们还是应该避免报错） 如果是写redis，反正每次都是set，天然幂等性 如果不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，就别处理了，保证别重复处理相同的消息即可。  引用:
  rabbitMq-kafka消息高可用，一致性  如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性  如何预防rabbitmq消息的丢失 #  情况1、生产者自己丢失了消息(网络故障/发送失败)
解决方案：
rabbitmq：一般这种都是采用回调接口的方案（confirm模式），就是说你扔一个消息过去了，对方给你一个回调接口，告诉你成功了或者失败了，失败了你可以选择继续扔消息， (重试机制等)，来保证消息一定送达
开启confirm模式（异步的）之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
引用： 如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性
情况2、消息中间件弄丢了消息
解决方案：以rabbitmq来说，开启持久化就好了，当发生宕机的时候，queue会自动从磁盘恢复数据，除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小
情况3、消费者弄丢了消息
rabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，rabbitmq认为你都消费了，这数据就丢了。
关闭rabbitmq自动ack机制，可以通过一个api来调用，每次代码里确保处理完的时候，再程序里ack。这样的话，如果还没处理完，就没有ack，那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的
如何预防kafak消息丢失 #   TODO
如何处理消息积压 #  出现场景：消费能力被阻塞（消费者挂掉或者处理速度慢），生产者还不停的往队列里扔消息
解决方法：
 快速恢复consumer服务，慢慢消费，如果积压的数据量太大的话恢复较慢 临时写脚本快速的把这批消息给消费掉，或者增加消费者数量/消费速度，要避免负载把其他服务打挂 扩容：提高相同消息的队列数量，出现问题时写脚本分发到不同队列里，再给每个队列指定消费者，消费结束后再恢复  预防：
 提前准备多个队列在投递时随机投递，存储同类型无顺序要求的消息 使用多个消费者  消息过期或者队列满了怎么办 #  消息队列TTL超时或者队列满了数据会丢失，这个时候可以自己再去找消息，然后临时写个代码，自己再手动的去把这些消息重新推送到队列里去。
另一种解决方案
 可以在 rabbitmq 中声明死信队列，死信队列为处理过期或不能正确路由的消息提供了驻留场所，可以防止消息丢失，便于分析无法消费的原因 写程序处理死信队列里的数据，并接入告警分析  如果投递不成功，需要把数据暂存内存或者暂存redis之类的数据库中，等待恢复时重试"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="消息队列 #  如何保证队列数据一致性，防止重复消费，幂等性 #  所有的消息中间件在实际的业务场景中都逃脱不了保证消息的一致性的问题
kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，可以理解成一个自增持的序号，一个个排下来
然后消费者consumer，每隔一段时间，就把自己消费过的消息提交一下，如果说出现宕机或者重启，则会继续从上次消费的序号接着往下排，继续消费
但是有的时候，消费者consumer消费的消息，由于各种原因，比如网络、宕机、停电。。。都没来得及写offset,这个时候少数消息会再次消费一次
这个时候，我们可以用一个唯一的id标识来区分，这不是消息中间件做的事，而是开发者要做的，比如你消费一个就往数据库插入一条记录，然后下次再去消费的时候，你去查一下，看看这个消息是否被消费了，消费了那就不要重复消费了。
（补充一下：确认一条数据在百万级别海量数据里是否存在？&ndash;可以用布隆过滤器）
 根据主键查一下，如果这数据都有了，就别插入了，update一下（虽然重复插入会因为唯一键约束而报错，我觉得我们还是应该避免报错） 如果是写redis，反正每次都是set，天然幂等性 如果不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，就别处理了，保证别重复处理相同的消息即可。  引用:
  rabbitMq-kafka消息高可用，一致性  如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性  如何预防rabbitmq消息的丢失 #  情况1、生产者自己丢失了消息(网络故障/发送失败)
解决方案：
rabbitmq：一般这种都是采用回调接口的方案（confirm模式），就是说你扔一个消息过去了，对方给你一个回调接口，告诉你成功了或者失败了，失败了你可以选择继续扔消息， (重试机制等)，来保证消息一定送达
开启confirm模式（异步的）之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
引用： 如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性
情况2、消息中间件弄丢了消息
解决方案：以rabbitmq来说，开启持久化就好了，当发生宕机的时候，queue会自动从磁盘恢复数据，除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小
情况3、消费者弄丢了消息
rabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，rabbitmq认为你都消费了，这数据就丢了。
关闭rabbitmq自动ack机制，可以通过一个api来调用，每次代码里确保处理完的时候，再程序里ack。这样的话，如果还没处理完，就没有ack，那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的
如何预防kafak消息丢失 #   TODO
如何处理消息积压 #  出现场景：消费能力被阻塞（消费者挂掉或者处理速度慢），生产者还不停的往队列里扔消息
解决方法：
 快速恢复consumer服务，慢慢消费，如果积压的数据量太大的话恢复较慢 临时写脚本快速的把这批消息给消费掉，或者增加消费者数量/消费速度，要避免负载把其他服务打挂 扩容：提高相同消息的队列数量，出现问题时写脚本分发到不同队列里，再给每个队列指定消费者，消费结束后再恢复  预防：
 提前准备多个队列在投递时随机投递，存储同类型无顺序要求的消息 使用多个消费者  消息过期或者队列满了怎么办 #  消息队列TTL超时或者队列满了数据会丢失，这个时候可以自己再去找消息，然后临时写个代码，自己再手动的去把这些消息重新推送到队列里去。
另一种解决方案
 可以在 rabbitmq 中声明死信队列，死信队列为处理过期或不能正确路由的消息提供了驻留场所，可以防止消息丢失，便于分析无法消费的原因 写程序处理死信队列里的数据，并接入告警分析  如果投递不成功，需要把数据暂存内存或者暂存redis之类的数据库中，等待恢复时重试"><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/interview/queue/"><meta property="article:section" content="interview"><title>Queue | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.9743218a9b114aeb464b4ee93a2e447b8c9df2a07e1de157caa2f0c8a81fadb7.js integrity="sha256-l0MhipsRSutGS07pOi5Ee4yd8qB+HeFXyqLwyKgfrbc=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/>Linux</a></li><li><a href=/interview/go/><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/>Java</a></li><li><a href=/interview/redis/>Redis</a></li><li><a href=/interview/mysql/>Mysql</a></li><li><a href=/interview/queue/ class=active>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Queue</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#如何保证队列数据一致性防止重复消费幂等性>如何保证队列数据一致性，防止重复消费，幂等性</a></li><li><a href=#如何预防rabbitmq消息的丢失>如何预防rabbitmq消息的丢失</a></li><li><a href=#如何预防kafak消息丢失>如何预防kafak消息丢失</a></li><li><a href=#如何处理消息积压>如何处理消息积压</a></li><li><a href=#消息过期或者队列满了怎么办>消息过期或者队列满了怎么办</a></li><li><a href=#怎么实现一个延时队列>怎么实现一个延时队列？</a></li><li><a href=#什么是优先队列怎么实现>什么是优先队列，怎么实现</a></li><li><a href=#如何保证消息队列的顺序性>如何保证消息队列的顺序性</a></li></ul></nav></aside></header><article class=markdown><h1 id=消息队列>消息队列
<a class=anchor href=#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97>#</a></h1><h2 id=如何保证队列数据一致性防止重复消费幂等性>如何保证队列数据一致性，防止重复消费，幂等性
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e9%98%9f%e5%88%97%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%98%b2%e6%ad%a2%e9%87%8d%e5%a4%8d%e6%b6%88%e8%b4%b9%e5%b9%82%e7%ad%89%e6%80%a7>#</a></h2><p>所有的消息中间件在实际的业务场景中都逃脱不了保证消息的一致性的问题</p><p><code>kafka</code>实际上有个<code>offset</code>的概念，就是每个消息写进去，都有一个<code>offset</code>，可以理解成一个自增持的序号，一个个排下来</p><p>然后消费者<code>consumer</code>，每隔一段时间，就把自己消费过的消息提交一下，如果说出现宕机或者重启，则会继续从上次消费的序号接着往下排，继续消费</p><p>但是有的时候，消费者<code>consumer</code>消费的消息，由于各种原因，比如网络、宕机、停电。。。都没来得及写<code>offset</code>,这个时候少数消息会再次消费一次</p><p>这个时候，我们可以<strong>用一个唯一的id标识来区分</strong>，这不是消息中间件做的事，而是开发者要做的，比如你消费一个就往数据库插入一条记录，然后下次再去消费的时候，你去查一下，看看这个消息是否被消费了，消费了那就不要重复消费了。</p><p>（补充一下：确认一条数据在百万级别海量数据里是否存在？&ndash;可以用<strong>布隆过滤器</strong>）</p><ul><li>根据主键查一下，如果这数据都有了，就别插入了，update一下（虽然重复插入会因为唯一键约束而报错，我觉得我们还是应该避免报错）</li><li>如果是写redis，反正每次都是set，天然幂等性</li><li>如果不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，就别处理了，保证别重复处理相同的消息即可。</li></ul><p>引用:</p><ul><li><a href=https://blog.csdn.net/lanshen110119/article/details/89399084>rabbitMq-kafka消息高可用，一致性</a></li><li><a href=https://www.bilibili.com/read/cv1923046/>如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性</a></li></ul><h2 id=如何预防rabbitmq消息的丢失>如何预防rabbitmq消息的丢失
<a class=anchor href=#%e5%a6%82%e4%bd%95%e9%a2%84%e9%98%b2rabbitmq%e6%b6%88%e6%81%af%e7%9a%84%e4%b8%a2%e5%a4%b1>#</a></h2><p><strong>情况1、生产者自己丢失了消息(网络故障/发送失败)</strong></p><p>解决方案：</p><p>rabbitmq：一般这种都是采用回调接口的方案（confirm模式），就是说你扔一个消息过去了，对方给你一个回调接口，告诉你成功了或者失败了，失败了你可以选择继续扔消息， (重试机制等)，来保证消息一定送达</p><p>开启confirm模式（异步的）之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>引用：
<a href=https://www.bilibili.com/read/cv1923046/>如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性</a></p><p><strong>情况2、消息中间件弄丢了消息</strong></p><p>解决方案：以rabbitmq来说，开启<strong>持久化</strong>就好了，当发生宕机的时候，queue会自动从磁盘恢复数据，除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小</p><p><strong>情况3、消费者弄丢了消息</strong></p><p>rabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，rabbitmq认为你都消费了，这数据就丢了。</p><p>关闭rabbitmq自动ack机制，可以通过一个api来调用，每次代码里确保处理完的时候，再程序里ack。这样的话，如果还没处理完，就没有ack，那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的</p><h2 id=如何预防kafak消息丢失>如何预防kafak消息丢失
<a class=anchor href=#%e5%a6%82%e4%bd%95%e9%a2%84%e9%98%b2kafak%e6%b6%88%e6%81%af%e4%b8%a2%e5%a4%b1>#</a></h2><p><a href=https://github.com/minibear2333/interview-leetcode/issues/35>TODO</a></p><h2 id=如何处理消息积压>如何处理消息积压
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e6%b6%88%e6%81%af%e7%a7%af%e5%8e%8b>#</a></h2><p>出现场景：消费能力被阻塞（消费者挂掉或者处理速度慢），生产者还不停的往队列里扔消息</p><p>解决方法：</p><ul><li>快速恢复<code>consumer</code>服务，慢慢消费，如果积压的数据量太大的话恢复较慢</li><li>临时写脚本快速的把这批消息给消费掉，或者增加消费者数量/消费速度，要避免负载把其他服务打挂</li><li>扩容：提高相同消息的队列数量，出现问题时写脚本分发到不同队列里，再给每个队列指定消费者，消费结束后再恢复</li></ul><p>预防：</p><ul><li>提前准备多个队列在投递时随机投递，存储同类型无顺序要求的消息</li><li>使用多个消费者</li></ul><h2 id=消息过期或者队列满了怎么办>消息过期或者队列满了怎么办
<a class=anchor href=#%e6%b6%88%e6%81%af%e8%bf%87%e6%9c%9f%e6%88%96%e8%80%85%e9%98%9f%e5%88%97%e6%bb%a1%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e>#</a></h2><p>消息队列TTL超时或者队列满了数据会丢失，这个时候可以自己再去找消息，然后临时写个代码，自己再手动的去把这些消息重新推送到队列里去。</p><p>另一种解决方案</p><ul><li>可以在 rabbitmq 中声明死信队列，死信队列为处理过期或不能正确路由的消息提供了驻留场所，可以防止消息丢失，便于分析无法消费的原因</li><li>写程序处理死信队列里的数据，并接入告警分析</li></ul><p>如果投递不成功，需要把数据暂存内存或者暂存redis之类的数据库中，等待恢复时重试</p><h2 id=怎么实现一个延时队列>怎么实现一个延时队列？
<a class=anchor href=#%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97>#</a></h2><p>rabbitmq 可以配置
<a href=https://github.com/rabbitmq/rabbitmq-delayed-message-exchange>延时队列插件</a></p><p>消费者是无感知的，可以正常消费，生产者设置延迟时间，到了时间后队列里才会出现消息</p><p>如果一定要手动实现，可以维护不同的队列指代不同的延迟时间，程序根据相应队列来保证最新消息的时间戳与当前时间延迟转发到实际的消费队列</p><p>引用：
<a href=http://www.gxitsky.com/article/1604455229805099>过期时间，死信队列，延迟队列，优先队列，持久化</a></p><h2 id=什么是优先队列怎么实现>什么是优先队列，怎么实现
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0>#</a></h2><p>优先级高的消息先消费</p><p>在rabbitmq中，手动开启设置队列支持的最大优先级（建议不要设置太大，会消耗资源），在投递消息的时间设置优先级数值，队列会自动排序，但是如果消费速度太快，没有任何数据积压的时候，不存在排序也不存在优先级的问题</p><h2 id=如何保证消息队列的顺序性>如何保证消息队列的顺序性
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%80%a7>#</a></h2><p>同一订单不同消息投递到不同位置，不同消费者消费了同一订单的不同消息，一般出现在</p><ul><li>程序设计问题投递到不同队列</li><li>同一队列多个消费者并发消费，无法保证消费顺序</li></ul><p>解决方法：</p><ul><li>队列都是有顺序性保证的，在投递时，创建多个队列，hash投递，hash相同订单号投递同一个队列</li><li>消费时，保证同一个队列只允许一个消费者消费</li><li>多线程并发处理时，避免多进程，而是增加线程数，维护多个内存队列把消息归类</li></ul><p>引用:
<a href=https://xie.infoq.cn/article/c84491a814f99c7b9965732b1>如何保证消息的顺序性</a></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./interview/queue.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#如何保证队列数据一致性防止重复消费幂等性>如何保证队列数据一致性，防止重复消费，幂等性</a></li><li><a href=#如何预防rabbitmq消息的丢失>如何预防rabbitmq消息的丢失</a></li><li><a href=#如何预防kafak消息丢失>如何预防kafak消息丢失</a></li><li><a href=#如何处理消息积压>如何处理消息积压</a></li><li><a href=#消息过期或者队列满了怎么办>消息过期或者队列满了怎么办</a></li><li><a href=#怎么实现一个延时队列>怎么实现一个延时队列？</a></li><li><a href=#什么是优先队列怎么实现>什么是优先队列，怎么实现</a></li><li><a href=#如何保证消息队列的顺序性>如何保证消息队列的顺序性</a></li></ul></nav></div></aside></main></body></html>