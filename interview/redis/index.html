<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Redis #  数据类型 #   键的类型只能为字符串 值支持五种数据类型：  字符串：  set <key> <value> get <key> del <key>   列表  rpush <key> <item> lrange <key> i j（j可填-1） rindex <key> i lpop <key>   无序集合  sadd <key> <item> smembers <key> sismember <key> <item> srem <key> <item>   散列表  hset <key> <sub_key> <value> hgetall <key>（每条数据sub_key和value各占一行） hdel <key> <sub_key>   有序集合  zadd <key> <score> <item> zrange <key> i j withscores zrangebyscore <key> <score1> <score2> withscores zrem <key> <item>       zset(sort list) 的数据结构是什么？ #  zset 有序且唯一，在跳表以空间换时间 以冗余的链表换取效率"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="Redis #  数据类型 #   键的类型只能为字符串 值支持五种数据类型：  字符串：  set <key> <value> get <key> del <key>   列表  rpush <key> <item> lrange <key> i j（j可填-1） rindex <key> i lpop <key>   无序集合  sadd <key> <item> smembers <key> sismember <key> <item> srem <key> <item>   散列表  hset <key> <sub_key> <value> hgetall <key>（每条数据sub_key和value各占一行） hdel <key> <sub_key>   有序集合  zadd <key> <score> <item> zrange <key> i j withscores zrangebyscore <key> <score1> <score2> withscores zrem <key> <item>       zset(sort list) 的数据结构是什么？ #  zset 有序且唯一，在跳表以空间换时间 以冗余的链表换取效率"><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/interview/redis/"><meta property="article:section" content="interview"><title>Redis | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.9743218a9b114aeb464b4ee93a2e447b8c9df2a07e1de157caa2f0c8a81fadb7.js integrity="sha256-l0MhipsRSutGS07pOi5Ee4yd8qB+HeFXyqLwyKgfrbc=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/>Linux</a></li><li><a href=/interview/go/><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/>Java</a></li><li><a href=/interview/redis/ class=active>Redis</a></li><li><a href=/interview/mysql/>Mysql</a></li><li><a href=/interview/queue/>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Redis</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#数据类型>数据类型</a></li><li><a href=#zsetsort-list-的数据结构是什么>zset(sort list) 的数据结构是什么？</a></li><li><a href=#各数据类型底层数据结构>各数据类型底层数据结构</a></li><li><a href=#为什么要用跳表不用b树的结构呢>为什么要用跳表不用B+树的结构呢？</a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#redis事务>redis事务</a></li><li><a href=#redis-与-memcached-对比>Redis 与 Memcached 对比</a></li><li><a href=#数据淘汰策略>数据淘汰策略</a></li><li><a href=#lru和ttl大量过期时会不会阻塞>lru和ttl，大量过期时会不会阻塞</a></li><li><a href=#key清理不干净会不会遇到什么业务上的问题万一用到了会发生什么通过什么办法解决>key清理不干净会不会遇到什么业务上的问题，万一用到了会发生什么？通过什么办法解决？</a></li><li><a href=#缓存穿透与缓存雪崩>缓存穿透与缓存雪崩</a></li><li><a href=#redis做缓存时如何保证与mysql数据一致性>redis做缓存时，如何保证与mysql数据一致性</a></li><li><a href=#redis主从同步中途重连时如何识别同步点>redis主从同步，中途重连时如何识别同步点</a></li><li><a href=#分布式锁实现>分布式锁实现</a><ul><li><a href=#setnxset-if-not-existsredis单例>SETNX（set if not exists）(redis单例)</a></li><li><a href=#redlock>RedLock</a></li></ul></li><li><a href=#什么时候会fork子进程>什么时候会fork子进程</a></li><li><a href=#bigkey还会出现什么问题>bigkey还会出现什么问题？</a></li><li><a href=#集群模式没有mget命令怎么办>集群模式没有mget命令怎么办？</a></li><li><a href=#redis-是单线程的主要读写-io-操作-寻址等为什么不设计成多线程的>redis 是单线程的（主要读写 io 操作 寻址等），为什么不设计成多线程的？</a></li><li><a href=#单线程虽然有这些好处但一定会浪费一些多核cpu的性能优势如果是你设计会怎么考虑>单线程虽然有这些好处，但一定会浪费一些多核cpu的性能优势，如果是你设计会怎么考虑？</a></li><li><a href=#redis使用架构设计>redis使用架构设计</a><ul><li><a href=#一致性hash算法中怎么解决扩容缩容数据落点变化导致的问题>一致性hash算法中，怎么解决扩容缩容数据落点变化导致的问题？</a></li><li><a href=#那崩溃的节点上的历史数据怎么找回呢>那崩溃的节点上的历史数据怎么找回呢？</a></li><li><a href=#扩容的时候会发生历史key失效吗>扩容的时候，会发生历史key失效吗</a></li><li><a href=#缩容万一还是产生了某个节点压力变大而崩溃怎么设计兜底的方案>缩容万一还是产生了某个节点压力变大而崩溃，怎么设计兜底的方案？</a></li></ul></li><li><a href=#识别热key和解决热key>识别热key和解决热key</a></li><li><a href=#最后>最后</a></li></ul></nav></aside></header><article class=markdown><h1 id=redis>Redis
<a class=anchor href=#redis>#</a></h1><h2 id=数据类型>数据类型
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>#</a></h2><ul><li>键的类型只能为字符串</li><li>值支持五种数据类型：<ul><li>字符串：<ul><li><code>set &lt;key> &lt;value></code></li><li><code>get &lt;key></code></li><li><code>del &lt;key></code></li></ul></li><li>列表<ul><li><code>rpush &lt;key> &lt;item></code></li><li><code>lrange &lt;key> i j</code>（j可填-1）</li><li><code>rindex &lt;key> i</code></li><li><code>lpop &lt;key></code></li></ul></li><li>无序集合<ul><li><code>sadd &lt;key> &lt;item></code></li><li><code>smembers &lt;key></code></li><li><code>sismember &lt;key> &lt;item></code></li><li><code>srem &lt;key> &lt;item></code></li></ul></li><li>散列表<ul><li><code>hset &lt;key> &lt;sub_key> &lt;value></code></li><li><code>hgetall &lt;key></code>（每条数据sub_key和value各占一行）</li><li><code>hdel &lt;key> &lt;sub_key></code></li></ul></li><li>有序集合<ul><li><code>zadd &lt;key> &lt;score> &lt;item></code></li><li><code>zrange &lt;key> i j withscores</code></li><li><code>zrangebyscore &lt;key> &lt;score1> &lt;score2> withscores</code></li><li><code>zrem &lt;key> &lt;item></code></li></ul></li></ul></li></ul><p><img src=.gitbook/assets/2021-03-26-16-39-14.png alt></p><h2 id=zsetsort-list-的数据结构是什么>zset(sort list) 的数据结构是什么？
<a class=anchor href=#zsetsort-list-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%98%af%e4%bb%80%e4%b9%88>#</a></h2><p>zset 有序且唯一，在跳表以空间换时间 以冗余的链表换取效率</p><p><img src=.gitbook/assets/2021-03-17-19-59-16.png alt></p><h2 id=各数据类型底层数据结构>各数据类型底层数据结构
<a class=anchor href=#%e5%90%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p><img src=https://coding3min.oss-accelerate.aliyuncs.com/2021/04/13/cIoLit1640.jpg alt=redis数据类型></p><ul><li>字符串：int raw embstr</li><li>字典：hashtable(拉链法单链表)、ziplist</li><li>列表：ziplist（压缩链表）、linkedlist（双向链表）</li><li>集合：hashtable、inset</li><li>有序集合：ziplist和skiplist（跳表）</li></ul><p>图片引用：
<a href=https://zhuanlan.zhihu.com/p/148755561>Redis基础数据结构详解</a></p><h2 id=为什么要用跳表不用b树的结构呢>为什么要用跳表不用B+树的结构呢？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e8%b7%b3%e8%a1%a8%e4%b8%8d%e7%94%a8b%e6%a0%91%e7%9a%84%e7%bb%93%e6%9e%84%e5%91%a2>#</a></h2><p>答者：Shawn</p><p>B+树的每个节点可以存储多个关键字，而Redis是 内存中读取数据，不涉及IO，因此使用了跳表</p><h2 id=使用场景>使用场景
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af>#</a></h2><ul><li>计数器：对 String 进行自增自减运算，从而实现计数器功能（Redis 这种内存型数据库的读写性能非常高）</li><li>缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率</li><li>查找表：查找表的内容不能失效（DNS）</li><li>消息队列或阻塞队列：List 是一个双向链表</li><li>会话缓存</li><li>分布式锁实现<ul><li>SETNX</li><li>RedLock</li></ul></li><li>其他<ul><li>SET可以实现交集、并集等操作</li><li>ZSet 可以实现有序性操作</li></ul></li></ul><h2 id=redis事务>redis事务
<a class=anchor href=#redis%e4%ba%8b%e5%8a%a1>#</a></h2><p>Redis 事务可以一次执行多个命令，单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><p>引用：
<a href=https://www.runoob.com/redis/redis-transactions.html>Redis事务</a></p><h2 id=redis-与-memcached-对比>Redis 与 Memcached 对比
<a class=anchor href=#redis-%e4%b8%8e-memcached-%e5%af%b9%e6%af%94>#</a></h2><ul><li>两者都是非关系型内存键值数据库</li><li>差异<ul><li>数据类型：<ul><li>Memcached 仅支持字符串类型</li><li>Redis 支持五种不同的数据类型</li></ul></li><li>数据持久化<ul><li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志</li><li>Memcached 不支持持久化</li></ul></li><li>分布式<ul><li>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li><li>Redis Cluster 实现了分布式的支持</li></ul></li><li>内存管理机制<ul><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中</li><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了</li></ul></li></ul></li></ul><h2 id=数据淘汰策略>数据淘汰策略
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5>#</a></h2><p><img src=.gitbook/assets/2021-03-26-16-41-07.png alt></p><h2 id=lru和ttl大量过期时会不会阻塞>lru和ttl，大量过期时会不会阻塞
<a class=anchor href=#lru%e5%92%8cttl%e5%a4%a7%e9%87%8f%e8%bf%87%e6%9c%9f%e6%97%b6%e4%bc%9a%e4%b8%8d%e4%bc%9a%e9%98%bb%e5%a1%9e>#</a></h2><p>不会，因为redis是闲时清理，可以设置最高占用cpu，清理是基于概率的，存在部分key总是无法清理的情况在，另外清理key的过程是不会fork子进程</p><h2 id=key清理不干净会不会遇到什么业务上的问题万一用到了会发生什么通过什么办法解决>key清理不干净会不会遇到什么业务上的问题，万一用到了会发生什么？通过什么办法解决？
<a class=anchor href=#key%e6%b8%85%e7%90%86%e4%b8%8d%e5%b9%b2%e5%87%80%e4%bc%9a%e4%b8%8d%e4%bc%9a%e9%81%87%e5%88%b0%e4%bb%80%e4%b9%88%e4%b8%9a%e5%8a%a1%e4%b8%8a%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%87%e4%b8%80%e7%94%a8%e5%88%b0%e4%ba%86%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%e9%80%9a%e8%bf%87%e4%bb%80%e4%b9%88%e5%8a%9e%e6%b3%95%e8%a7%a3%e5%86%b3>#</a></h2><p>如果是lru的话，假如一个key值在以前都没有被访问到，然而最近一次被访问到了，那么就会认为它是热点数据，会更新ttl，不会被淘汰。</p><p>优化的话就增大maxmemory-sample，增加每次lru数据的个数，淘汰起来更精确</p><p>在redis>4.0版本，有LFU算法，访问不频繁的优先淘汰就好了</p><p>另外redis有三种删除策略</p><p>惰性删除，也就是在置换的时候删除</p><p>定时删除，固定时间段执行删除操作</p><p>定期删除，和定时删除一样，区别会时间期是根据业务来自动取的</p><p>另外rdb和aof的持久化策略中，rdb读取时不会读取过期数据，aof有rewrite功能，执行行也不会存过期的策略</p><p>太频繁的主动删除对cpu不友好，惰性删除对内存不友好，一旦插入大key，会出现cpu使用高峰</p><h2 id=缓存穿透与缓存雪崩>缓存穿透与缓存雪崩
<a class=anchor href=#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e4%b8%8e%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9>#</a></h2><ul><li>缓存穿透：用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询，数据库也没有<ul><li>布隆过滤器：对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询</li><li>缓存空对象：当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源</li></ul></li><li>缓存雪崩：大量key同一时间点失效，同时又有大量请求打进来，导致流量直接打在DB上，造成DB不可用<ul><li>设置key永不失效（热点数据）；</li><li>设置key缓存失效时候尽可能错开；</li><li>使用多级缓存机制，比如同时使用redsi和memcache缓存，请求->redis->memcache->db；</li><li>redis高可用</li></ul></li><li>缓存击穿：某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库<ul><li>可以将热点数据设置为永不过期</li><li>基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</li></ul></li></ul><p>引用：
<a href=https://juejin.cn/post/6844903886113751053>Redis雪崩、穿透和击穿</a></p><h2 id=redis做缓存时如何保证与mysql数据一致性>redis做缓存时，如何保证与mysql数据一致性
<a class=anchor href=#redis%e5%81%9a%e7%bc%93%e5%ad%98%e6%97%b6%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%b8%8emysql%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7>#</a></h2><p>只要涉及到数据更新就会有一致性的问题，无论是先更新哪一端</p><ul><li>采用延时双删策略，先删除缓存再删除数据库再更新缓存，弊端期间短暂不一致</li><li>订阅mysql的binlog，增删改增量更新，参考canal(阿里的一款开源框架)，这种情况增删改都是操作MySQL，redis就变成只读了，需要加一些更细粒度的判断</li><li>对不敏感的数据做定时任务</li></ul><p>引用：
<a href=https://juejin.cn/post/6844903805641818120>Redis和mysql数据怎么保持数据一致的</a></p><h2 id=redis主从同步中途重连时如何识别同步点>redis主从同步，中途重连时如何识别同步点
<a class=anchor href=#redis%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e4%b8%ad%e9%80%94%e9%87%8d%e8%bf%9e%e6%97%b6%e5%a6%82%e4%bd%95%e8%af%86%e5%88%ab%e5%90%8c%e6%ad%a5%e7%82%b9>#</a></h2><p>从 <code>redis 2.8</code> 开始支持断点续传， <code>master</code> 会存储一个 <code>backlog</code> ， <code>master</code> 和 <code>slave</code> 都会保存一个 <code>replica offset</code> 还有一个 <code>master id</code> , <code>offset</code> 就是保存在 <code>backlog</code> 中的, 如果 <code>master</code> 和 <code>slave</code> 网络连接断掉了, <code>slave</code> 会让 <code>master</code> 从上次的 <code>replica offset</code> 开始继续复制但是如果没有找到对应的 <code>offset</code> , 那么就会执行一次 <code>resynchronization</code> (重新同步).</p><p>引用：
<a href=https://segmentfault.com/a/1190000021683032>redis主从复制原理, 断点续传, 无磁盘化复制, 过期key的处理</a></p><h2 id=分布式锁实现>分布式锁实现
<a class=anchor href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%ae%9e%e7%8e%b0>#</a></h2><h3 id=setnxset-if-not-existsredis单例>SETNX（set if not exists）(redis单例)
<a class=anchor href=#setnxset-if-not-existsredis%e5%8d%95%e4%be%8b>#</a></h3><ul><li><code>SETNX lock.foo &lt;current Unix time + lock timeout + 1></code></li><li>如果 SETNX 返回1，说明该进程获得锁，SETNX将键 lock.foo 的值设置为锁的超时时间（当前时间 + 锁的有效时间）</li><li>如果 SETNX 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁</li><li>解决死锁问题<ul><li>SETNX lock.foo 返回0，获取锁失败</li><li>GET lock.foo 来检测锁是否已超时</li><li><code>GETSET lock.foo &lt;current Unix timestamp + lock timeout + 1></code></li><li>设置键的值的同时，还会返回键的旧值</li><li>通过比较键 lock.foo 的旧值是否小于当前时间，可以判断进程是否已获得锁</li></ul></li></ul><h3 id=redlock>RedLock
<a class=anchor href=#redlock>#</a></h3><ul><li>客户端获取当前的时间戳。</li><li>对 N 个 Redis 实例进行获取锁的操作，具体的操作同单机分布式锁。对 Redis 实例的操作时间需要远小于分布式锁的超时时间，这样可以保证在少数 Redis 节点 Down 掉的时候仍可快速对下一个节点进行操作。</li><li>客户端会记录所有实例返回加锁成功的时间，只有从多半的实例（在这里例子中 >= 3）获取到了锁，且操作的时间远小于分布式锁的超时时间，锁才被人为是正确获取。</li><li>如果锁被成功获取了，当前分布式锁的合法时间为初始设定的合法时间减去上锁所花的时间。</li><li>若分布式锁获取失败，会强制对所有实例进行锁释放的操作，即使这个实例上不存在相应的键值</li></ul><h2 id=什么时候会fork子进程>什么时候会fork子进程
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9afork%e5%ad%90%e8%bf%9b%e7%a8%8b>#</a></h2><p>rdb 、aof、主从无盘复制方式传输</p><h2 id=bigkey还会出现什么问题>bigkey还会出现什么问题？
<a class=anchor href=#bigkey%e8%bf%98%e4%bc%9a%e5%87%ba%e7%8e%b0%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98>#</a></h2><p>网络阻塞、redis超时、分片内存不均匀导致某些节点占用内存多</p><p>避免bigkey的方法，主要是对 bigkey 进行拆分，拆成多个 key，然后用MGET取回来，再在业务层做合并。</p><h2 id=集群模式没有mget命令怎么办>集群模式没有mget命令怎么办？
<a class=anchor href=#%e9%9b%86%e7%be%a4%e6%a8%a1%e5%bc%8f%e6%b2%a1%e6%9c%89mget%e5%91%bd%e4%bb%a4%e6%80%8e%e4%b9%88%e5%8a%9e>#</a></h2><p>再加个map存在key列表，然后并行取</p><h2 id=redis-是单线程的主要读写-io-操作-寻址等为什么不设计成多线程的>redis 是单线程的（主要读写 io 操作 寻址等），为什么不设计成多线程的？
<a class=anchor href=#redis-%e6%98%af%e5%8d%95%e7%ba%bf%e7%a8%8b%e7%9a%84%e4%b8%bb%e8%a6%81%e8%af%bb%e5%86%99-io-%e6%93%8d%e4%bd%9c-%e5%af%bb%e5%9d%80%e7%ad%89%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%ae%be%e8%ae%a1%e6%88%90%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84>#</a></h2><p>Redis的核心是快『基于内存』，主要有以下观点：由『避免了上下文切换和cpu的竞争，更加无需考虑各种锁操作，也不会和mysql一样存在死锁导致的问题』。</p><p>因为数据是存储在内存中，内存中的运行非常快，但是如果存在上面的锁，和上下文切换，可能就不会那么快了。</p><p>有利于开发人员规范代码，单线程的代码比多核异步更加清晰明了。</p><h2 id=单线程虽然有这些好处但一定会浪费一些多核cpu的性能优势如果是你设计会怎么考虑>单线程虽然有这些好处，但一定会浪费一些多核cpu的性能优势，如果是你设计会怎么考虑？
<a class=anchor href=#%e5%8d%95%e7%ba%bf%e7%a8%8b%e8%99%bd%e7%84%b6%e6%9c%89%e8%bf%99%e4%ba%9b%e5%a5%bd%e5%a4%84%e4%bd%86%e4%b8%80%e5%ae%9a%e4%bc%9a%e6%b5%aa%e8%b4%b9%e4%b8%80%e4%ba%9b%e5%a4%9a%e6%a0%b8cpu%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8a%bf%e5%a6%82%e6%9e%9c%e6%98%af%e4%bd%a0%e8%ae%be%e8%ae%a1%e4%bc%9a%e6%80%8e%e4%b9%88%e8%80%83%e8%99%91>#</a></h2><p>还得看cpu的频率，如果cpu的频率低，并且访问redis的并发很大，那么单个redis线程分摊到每个cpu上的压力也是非常可观的。（一个线程并不是一直都bind到一个固定的核上面的， 其实这也是常遇到的错误的认知：单个线程就算用多核的机器也是浪费的观念）</p><p>虽然redis是单线程，如果有需要可以使用多实例来模拟出多线程或者多进程</p><h2 id=redis使用架构设计>redis使用架构设计
<a class=anchor href=#redis%e4%bd%bf%e7%94%a8%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1>#</a></h2><h3 id=一致性hash算法中怎么解决扩容缩容数据落点变化导致的问题>一致性hash算法中，怎么解决扩容缩容数据落点变化导致的问题？
<a class=anchor href=#%e4%b8%80%e8%87%b4%e6%80%a7hash%e7%ae%97%e6%b3%95%e4%b8%ad%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3%e6%89%a9%e5%ae%b9%e7%bc%a9%e5%ae%b9%e6%95%b0%e6%8d%ae%e8%90%bd%e7%82%b9%e5%8f%98%e5%8c%96%e5%af%bc%e8%87%b4%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h3><p>虚节点把数据落点更加均衡，减少单台机器下线导致的大量数据移动，导致的数据倾斜，也可以解决数据倾斜导致的新节点崩溃的缓存雪崩问题</p><h3 id=那崩溃的节点上的历史数据怎么找回呢>那崩溃的节点上的历史数据怎么找回呢？
<a class=anchor href=#%e9%82%a3%e5%b4%a9%e6%ba%83%e7%9a%84%e8%8a%82%e7%82%b9%e4%b8%8a%e7%9a%84%e5%8e%86%e5%8f%b2%e6%95%b0%e6%8d%ae%e6%80%8e%e4%b9%88%e6%89%be%e5%9b%9e%e5%91%a2>#</a></h3><p>jing</p><p>历史数据找回的前提应该是本来数据就是副本或者纠删码形式存储</p><p>彬</p><p>历史数据归根有两种，后台的一般会回写数据库，这部分不会丢，用户体验可以做到无感。主要是用户的临时数据，比如登录过的账号，这部分要么使用第三方中间件，比如redis之类的存储，这样每次需要直接找redis查即可，要么直接放客户端，例如放cookie，token这些，这样也不会随着服务端变更影响。如果放的是服务端，那么只能做数据迁移后再扩容</p><h3 id=扩容的时候会发生历史key失效吗>扩容的时候，会发生历史key失效吗
<a class=anchor href=#%e6%89%a9%e5%ae%b9%e7%9a%84%e6%97%b6%e5%80%99%e4%bc%9a%e5%8f%91%e7%94%9f%e5%8e%86%e5%8f%b2key%e5%a4%b1%e6%95%88%e5%90%97>#</a></h3><h3 id=缩容万一还是产生了某个节点压力变大而崩溃怎么设计兜底的方案>缩容万一还是产生了某个节点压力变大而崩溃，怎么设计兜底的方案？
<a class=anchor href=#%e7%bc%a9%e5%ae%b9%e4%b8%87%e4%b8%80%e8%bf%98%e6%98%af%e4%ba%a7%e7%94%9f%e4%ba%86%e6%9f%90%e4%b8%aa%e8%8a%82%e7%82%b9%e5%8e%8b%e5%8a%9b%e5%8f%98%e5%a4%a7%e8%80%8c%e5%b4%a9%e6%ba%83%e6%80%8e%e4%b9%88%e8%ae%be%e8%ae%a1%e5%85%9c%e5%ba%95%e7%9a%84%e6%96%b9%e6%a1%88>#</a></h3><h2 id=识别热key和解决热key>识别热key和解决热key
<a class=anchor href=#%e8%af%86%e5%88%ab%e7%83%adkey%e5%92%8c%e8%a7%a3%e5%86%b3%e7%83%adkey>#</a></h2><p>热key一般在两种情况下出现</p><ul><li>突发热点事件，比如促销、秒杀、社会热点场景</li><li>频繁访问某些数据</li></ul><p>热key危害</p><ul><li>分片集群，热key集中时，一旦超过单点访问极限容易出现问题</li><li>流量集中，超过网卡访问上限，影响其他业务</li><li>缓存雪崩</li></ul><p>原生寻找热key方法：</p><ul><li>Redis 4.0 客户端可以通过 <code>--hotkeys</code> 选项快速找到业务中的热点<code>key</code></li><li><code>OBJECT</code> 命令可以找到某个key的访问频率</li></ul><p>其他方法</p><ul><li>埋点，通过sdk，但多语言维护问题困难</li><li>代理层收集，但存在新组件维护及性能瓶颈</li><li>定时扫描，使用刚刚说到的原生方法，实时性比较差</li><li>监控抓包，有可能会增加网络流量和系统负载情况</li></ul><p>饿了么的方案</p><ul><li>所有的redis经过自己开发的代理组件</li><li>使用LFU算法，
<a href=https://en.wikipedia.org/wiki/Approximate_counting_algorithm>概率计数</a>，在代理层仅统计32个key</li><li>统计值会因时间变化，每分钟衰减一半</li><li>采样率可以根据服务器的配置来配置</li><li>超过阈值的key推送到远程监控端</li></ul><p>引用：
<a href=https://www.infoq.cn/article/3l3zaq4h8xpnom2glsyi>如何快速定位 Redis 热 key</a></p><h2 id=最后>最后
<a class=anchor href=#%e6%9c%80%e5%90%8e>#</a></h2><p>如果文中有误，欢迎提pr或者issue，<strong>一旦合并或采纳作为贡献奖励可以联系我直接无门槛</strong>加入
<a href=https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q>技术交流群</a></p><p>我是小熊，关注我，知道更多不知道的技术</p><p><img src=.gitbook/assets/2021-03-17-19-57-33.png alt></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./interview/redis.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#数据类型>数据类型</a></li><li><a href=#zsetsort-list-的数据结构是什么>zset(sort list) 的数据结构是什么？</a></li><li><a href=#各数据类型底层数据结构>各数据类型底层数据结构</a></li><li><a href=#为什么要用跳表不用b树的结构呢>为什么要用跳表不用B+树的结构呢？</a></li><li><a href=#使用场景>使用场景</a></li><li><a href=#redis事务>redis事务</a></li><li><a href=#redis-与-memcached-对比>Redis 与 Memcached 对比</a></li><li><a href=#数据淘汰策略>数据淘汰策略</a></li><li><a href=#lru和ttl大量过期时会不会阻塞>lru和ttl，大量过期时会不会阻塞</a></li><li><a href=#key清理不干净会不会遇到什么业务上的问题万一用到了会发生什么通过什么办法解决>key清理不干净会不会遇到什么业务上的问题，万一用到了会发生什么？通过什么办法解决？</a></li><li><a href=#缓存穿透与缓存雪崩>缓存穿透与缓存雪崩</a></li><li><a href=#redis做缓存时如何保证与mysql数据一致性>redis做缓存时，如何保证与mysql数据一致性</a></li><li><a href=#redis主从同步中途重连时如何识别同步点>redis主从同步，中途重连时如何识别同步点</a></li><li><a href=#分布式锁实现>分布式锁实现</a><ul><li><a href=#setnxset-if-not-existsredis单例>SETNX（set if not exists）(redis单例)</a></li><li><a href=#redlock>RedLock</a></li></ul></li><li><a href=#什么时候会fork子进程>什么时候会fork子进程</a></li><li><a href=#bigkey还会出现什么问题>bigkey还会出现什么问题？</a></li><li><a href=#集群模式没有mget命令怎么办>集群模式没有mget命令怎么办？</a></li><li><a href=#redis-是单线程的主要读写-io-操作-寻址等为什么不设计成多线程的>redis 是单线程的（主要读写 io 操作 寻址等），为什么不设计成多线程的？</a></li><li><a href=#单线程虽然有这些好处但一定会浪费一些多核cpu的性能优势如果是你设计会怎么考虑>单线程虽然有这些好处，但一定会浪费一些多核cpu的性能优势，如果是你设计会怎么考虑？</a></li><li><a href=#redis使用架构设计>redis使用架构设计</a><ul><li><a href=#一致性hash算法中怎么解决扩容缩容数据落点变化导致的问题>一致性hash算法中，怎么解决扩容缩容数据落点变化导致的问题？</a></li><li><a href=#那崩溃的节点上的历史数据怎么找回呢>那崩溃的节点上的历史数据怎么找回呢？</a></li><li><a href=#扩容的时候会发生历史key失效吗>扩容的时候，会发生历史key失效吗</a></li><li><a href=#缩容万一还是产生了某个节点压力变大而崩溃怎么设计兜底的方案>缩容万一还是产生了某个节点压力变大而崩溃，怎么设计兜底的方案？</a></li></ul></li><li><a href=#识别热key和解决热key>识别热key和解决热key</a></li><li><a href=#最后>最后</a></li></ul></nav></div></aside></main></body></html>