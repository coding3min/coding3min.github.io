<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java #  基本数据类型 #   整型：byte(8)、short(16)、int(32)、long(64) 浮点型：float(32)、double(64) 布尔型：boolean(8) 字符型：char(16) 只能向上转型 += 或者 ++ 运算符会执行隐式类型转换  异常处理 #   三种类型的异常 #   **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。  关键字 #   try/catch：捕获异常，catch可以多重捕获（直到异常被捕获或者通过所有的 catch 块） throws/throw：方法使用 throws 关键字来声明（一个方法没有捕获到一个检查性异常），throw 关键字抛出一个异常 finally：在 try 代码块后面执行的代码块  自定义异常 #   所有异常都必须是 Throwable 的子类。 自定义检查性异常类，需要继承 Exception 类。 自定义运行时异常类，那么需要继承 RuntimeException 类。  hashMap #   底层数据结构，JDK 1.8 是数组 + 链表 + 红黑树，JDK 1."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="Java #  基本数据类型 #   整型：byte(8)、short(16)、int(32)、long(64) 浮点型：float(32)、double(64) 布尔型：boolean(8) 字符型：char(16) 只能向上转型 += 或者 ++ 运算符会执行隐式类型转换  异常处理 #   三种类型的异常 #   **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。  关键字 #   try/catch：捕获异常，catch可以多重捕获（直到异常被捕获或者通过所有的 catch 块） throws/throw：方法使用 throws 关键字来声明（一个方法没有捕获到一个检查性异常），throw 关键字抛出一个异常 finally：在 try 代码块后面执行的代码块  自定义异常 #   所有异常都必须是 Throwable 的子类。 自定义检查性异常类，需要继承 Exception 类。 自定义运行时异常类，那么需要继承 RuntimeException 类。  hashMap #   底层数据结构，JDK 1.8 是数组 + 链表 + 红黑树，JDK 1."><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/interview/java/"><meta property="article:section" content="interview"><title>Java | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fa55d4ab6347cff8bc3ae9cefd152a646ed2f9d06f23a24af15f5f4aeb5f3414.js integrity="sha256-+lXUq2NHz/i8OunO/RUqZG7S+dBvI6JK8V9fSutfNBQ=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/>Linux</a></li><li><a href=/interview/go/><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/ class=active>Java</a></li><li><a href=/interview/redis/>Redis</a></li><li><a href=/interview/mysql/>Mysql</a></li><li><a href=/interview/queue/>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Java</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#基本数据类型>基本数据类型</a></li><li><a href=#异常处理>异常处理</a><ul><li><a href=#三种类型的异常>三种类型的异常</a></li><li><a href=#关键字>关键字</a></li><li><a href=#自定义异常>自定义异常</a></li></ul></li><li><a href=#hashmap>hashMap</a></li><li><a href=#concurrenthashmap的实现原理>ConcurrentHashMap的实现原理</a></li><li><a href=#final关键字>final关键字</a></li><li><a href=#string实现>String实现</a></li><li><a href=#clone>clone</a></li><li><a href=#volatile>volatile</a></li><li><a href=#synchronized>synchronized</a></li><li><a href=#偏向锁自旋锁轻量级锁乐观锁重量级锁悲观锁>偏向锁，自旋锁，轻量级锁（乐观锁）重量级锁（悲观锁）</a></li><li><a href=#aqs一个用来构建锁和同步器的框架>AQS（一个用来构建锁和同步器的框架）</a></li><li><a href=#reentrantlock>ReentrantLock</a></li><li><a href=#线程池>线程池</a></li><li><a href=#反射>反射</a><ul><li><a href=#常用方法>常用方法</a></li></ul></li><li><a href=#注解>注解</a><ul><li><a href=#注解的作用>注解的作用</a></li><li><a href=#配置参数>配置参数</a></li><li><a href=#定义方式>定义方式</a></li><li><a href=#元注解>元注解</a></li><li><a href=#使用方式>使用方式</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=java>Java
<a class=anchor href=#java>#</a></h1><h2 id=基本数据类型>基本数据类型
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>#</a></h2><ul><li>整型：byte(8)、short(16)、int(32)、long(64)</li><li>浮点型：float(32)、double(64)</li><li>布尔型：boolean(8)</li><li>字符型：char(16)</li><li>只能向上转型</li><li>+= 或者 ++ 运算符会执行隐式类型转换</li></ul><h2 id=异常处理>异常处理
<a class=anchor href=#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86>#</a></h2><p><img src=.gitbook/assets/2021-03-26-16-30-18.png alt></p><h3 id=三种类型的异常>三种类型的异常
<a class=anchor href=#%e4%b8%89%e7%a7%8d%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%bc%82%e5%b8%b8>#</a></h3><ul><li>**检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><h3 id=关键字>关键字
<a class=anchor href=#%e5%85%b3%e9%94%ae%e5%ad%97>#</a></h3><ul><li>try/catch：捕获异常，catch可以多重捕获（直到异常被捕获或者通过所有的 catch 块）</li><li>throws/throw：方法使用 throws 关键字来声明（一个方法没有捕获到一个检查性异常），throw 关键字抛出一个异常</li><li>finally：在 try 代码块后面执行的代码块</li></ul><h3 id=自定义异常>自定义异常
<a class=anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%bc%82%e5%b8%b8>#</a></h3><ul><li>所有异常都必须是 Throwable 的子类。</li><li>自定义检查性异常类，需要继承 Exception 类。</li><li>自定义运行时异常类，那么需要继承 RuntimeException 类。</li></ul><h2 id=hashmap>hashMap
<a class=anchor href=#hashmap>#</a></h2><ul><li>底层数据结构，JDK 1.8 是<strong>数组 + 链表 + 红黑树</strong>，JDK 1.7 无红黑树。</li><li>初始容量为 <strong>16</strong>，通过 tableSizeFor 保证容量为 2 的幂次方。寻址方式，高位异或，<strong>(n-1)&h</strong> 取模，优化速度。</li><li>扩容机制，当元素数量大于容量 x 负载因子 0.75 时，容量扩大为原来的 2 倍，新建一个数组，然后转移到新数组。</li><li>基于 Map 实现。</li><li>线程不安全。</li><li>key的hashCode()做hash，然后再计算index(高位运算和取模运算)</li><li>指针数组，value为链表，长度大于 8 时，转化为红黑树（1.8），优化查询效率。<ul><li>当 HashMap 中有大量的元素都存放到同一个桶中时，这个时候 HashMap 就相当于一个单链表，遍历时间复杂度就是 O(n)</li><li>转换为红黑树：时间复杂度为 O(logn)</li></ul></li><li>当限制n为2的幂次方时，<strong>(n-1)&h</strong>和h%n结果一致，但效率高了很多倍</li></ul><p><img src=.gitbook/assets/2021-03-26-16-30-40.png alt></p><p><img src=.gitbook/assets/2021-03-26-16-30-59.png alt></p><h2 id=concurrenthashmap的实现原理>ConcurrentHashMap的实现原理
<a class=anchor href=#concurrenthashmap%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86>#</a></h2><ul><li>采用了数组+链表+红黑树的实现方式来设计</li><li>ConcurrentHashMap的主干是个Segment数组<ul><li>Segment继承了ReentrantLock，重入锁</li><li>Segment类似于HashMap，一个Segment维护着一个HashEntry数组</li></ul></li><li>分段锁</li><li>内部大量采用CAS操作<ul><li>比较交换</li><li>乐观锁</li><li>包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)</li></ul></li><li>链表：保存key，value及key的hash值的数据结构，value和next都用volatile修饰</li></ul><h2 id=final关键字>final关键字
<a class=anchor href=#final%e5%85%b3%e9%94%ae%e5%ad%97>#</a></h2><ul><li>修饰类不能被继承</li><li>修饰方法：不能被重写</li><li>修饰变量：基本数据类型不能被修改；引用类型初始化后不能指向另一个对象</li></ul><h2 id=string实现>String实现
<a class=anchor href=#string%e5%ae%9e%e7%8e%b0>#</a></h2><ul><li>属性value：char[]</li><li>String不可变：<ul><li>实现字符串池（String pool）</li><li>多线程安全</li><li>避免安全问题</li><li>加快字符串处理速度（hashMap的key方便计算hashcode）</li></ul></li><li>Equals:<ul><li>this == anObject</li><li>anObject instanceof String</li><li>比较value属性</li><li>重写hashCode方法</li></ul></li></ul><h2 id=clone>clone
<a class=anchor href=#clone>#</a></h2><ul><li>clone() 是 Object 的 protected 方法，不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</li><li>Cloneable 接口规定：一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException</li><li>浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象</li><li>深拷贝：拷贝对象和原始对象的引用类型引用不同对象</li><li>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象</li></ul><h2 id=volatile>volatile
<a class=anchor href=#volatile>#</a></h2><ul><li>在多线程环境下，保证变量的可见性。使用了 volatile 修饰变量后，<strong>在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。</strong></li><li>禁止 JVM 指令重排序。</li></ul><p><img src=.gitbook/assets/2021-03-26-16-31-24.png alt></p><h2 id=synchronized>synchronized
<a class=anchor href=#synchronized>#</a></h2><ul><li>三种应用方式：<ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul></li></ul><h2 id=偏向锁自旋锁轻量级锁乐观锁重量级锁悲观锁>偏向锁，自旋锁，轻量级锁（乐观锁）重量级锁（悲观锁）
<a class=anchor href=#%e5%81%8f%e5%90%91%e9%94%81%e8%87%aa%e6%97%8b%e9%94%81%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81%e4%b9%90%e8%a7%82%e9%94%81%e9%87%8d%e9%87%8f%e7%ba%a7%e9%94%81%e6%82%b2%e8%a7%82%e9%94%81>#</a></h2><ul><li>通过 synchronized 加锁，第一个线程获取的锁为偏向锁，这时有其他线程参与锁竞争，升级为轻量级锁，其他线程通过循环的方式尝试获得锁，称自旋锁。若果自旋的次数达到一定的阈值，则升级为重量级锁。</li><li>需要注意的是，在第二个线程获取锁时，会先判断第一个线程是否仍然存活，如果不存活，不会升级为轻量级锁。</li></ul><p><img src=.gitbook/assets/2021-03-26-16-31-49.png alt></p><h2 id=aqs一个用来构建锁和同步器的框架>AQS（一个用来构建锁和同步器的框架）
<a class=anchor href=#aqs%e4%b8%80%e4%b8%aa%e7%94%a8%e6%9d%a5%e6%9e%84%e5%bb%ba%e9%94%81%e5%92%8c%e5%90%8c%e6%ad%a5%e5%99%a8%e7%9a%84%e6%a1%86%e6%9e%b6>#</a></h2><ul><li>结构<ul><li>用 volatile 修饰的整数类型的 state 状态（持有锁的次数），用于表示同步状态，提供 getState 和 setState 来操作同步状态；</li><li>提供了一个 FIFO 等待队列，实现线程间的竞争和等待，这是 AQS 的核心；</li><li>AQS 内部提供了各种基于 CAS 原子操作方法，如 compareAndSetState 方法，并且提供了锁操作的acquire和release方法。</li></ul></li><li>独占锁模式<ul><li>用 state 值表示锁并且 0 表示无锁状态，0 -> 1 表示从无锁到有锁，</li><li>仅允许一条线程持有锁，其余的线程会被包装成一个 Node 节点放到队列中进行挂起</li><li>队列中的头节点表示当前正在执行的线程，当头节点释放后会唤醒后继节点</li></ul></li><li>共享锁模式<ul><li>当有一个线程获取到锁之后，那么它就会依次唤醒等待队列中可以跟它共享的节点</li></ul></li></ul><h2 id=reentrantlock>ReentrantLock
<a class=anchor href=#reentrantlock>#</a></h2><ul><li><p>基于 AQS （AbstractQueuedSynchronizer）实现，主要有 state (资源) + FIFO (线程等待队列) 组成。</p></li><li><p>公平锁与非公平锁：区别在于在获取锁时，公平锁会判断当前队列是否有正在等待的线程，如果有则进行排队。</p></li><li><p>使用 lock() 和 unLock() 方法来加锁解锁。</p></li><li><p>非公平锁吞吐量高</p><p>在获取锁的阶段来分析，当某一线程要获取锁时，非公平锁可以直接尝试获取锁，而不是判断当前队列中是否有线程在等待。一定情况下可以避免线程频繁的上下文切换，这样，活跃的线程有可能获得锁，而在队列中的锁还要进行唤醒才能继续尝试获取锁，而且线程的执行顺序一般来说不影响程序的运行。</p></li></ul><h2 id=线程池>线程池
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0>#</a></h2><ul><li><p>分类</p><ul><li>FixThreadPool 固定数量的线程池，适用于对线程管理，高负载的系统</li><li>SingleThreadPool 只有一个线程的线程池，适用于保证任务顺序执行</li><li>CacheThreadPool 创建一个不限制线程数量的线程池，适用于执行短期异步任务的小程序，低负载系统</li><li>ScheduledThreadPool 定时任务使用的线程池，适用于定时任务</li></ul></li><li><p>重要参数</p><ul><li>int corePoolSize, 核心线程数</li><li>int maximumPoolSize, 最大线程数</li><li>long keepAliveTime, TimeUnit unit, 超过 corePoolSize 的线程的存活时长，超过这个时间，多余的线程会被回收。</li><li><code>BlockingQueue&lt;Runnable> workQueue</code>, 任务的排队队列</li><li>ThreadFactory threadFactory, 新线程的产生方式</li><li>RejectedExecutionHandler handler) 拒绝策略</li></ul></li><li><p>线程池线程工作过程</p><p>corePoolSize -> 任务队列 -> maximumPoolSize -> 拒绝策略</p></li></ul><blockquote><p>核心线程在线程池中一直存活，当有任务需要执行时，直接使用核心线程执行任务。当任务数量大于核心线程数时，加入等待队列。当任务队列数量达到队列最大长度时，继续创建线程，最多达到最大线程数。当设置回收时间时，核心线程以外的空闲线程会被回收。如果达到了最大线程数还不能够满足任务执行需求，则根据拒绝策略做拒绝处理。</p></blockquote><h2 id=反射>反射
<a class=anchor href=#%e5%8f%8d%e5%b0%84>#</a></h2><p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法</strong></p><h3 id=常用方法>常用方法
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95>#</a></h3><ul><li>获取反射中的Class对象<code>Class clz</code><ul><li>使用 Class.forName 静态方法<code>Class.forName("java.lang.String")</code></li><li>使用 .class 方法<code>String.class</code></li><li>使用类对象的 getClass() 方法<code>new String("Hello").getClass()</code></li></ul></li><li>通过反射创建类对象(通过 Constructor 对象创建类对象可以选择特定构造方法，通过 Class 对象则只能使用默认的无参数构造方法)<ul><li>通过 Class 对象的 newInstance() 方法<code>(Apple)clz.newInstance()</code></li><li>通过 Constructor 对象的 newInstance() 方法<code>Constructor constructor = clz.getConstructor(); Apple apple = (Apple)constructor.newInstance();</code></li></ul></li><li>通过反射获取类属性、方法、构造器<ul><li>Class 对象的 getFields() 方法可以获取 Class 类的属性（无法获取私有属性）</li><li>Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性</li></ul></li></ul><h2 id=注解>注解
<a class=anchor href=#%e6%b3%a8%e8%a7%a3>#</a></h2><h3 id=注解的作用>注解的作用
<a class=anchor href=#%e6%b3%a8%e8%a7%a3%e7%9a%84%e4%bd%9c%e7%94%a8>#</a></h3><ul><li>由编译器使用的注解：不会被编译进入<code>.class</code>文件，在编译后就被编译器扔掉（@Override、@SuppressWarnings）</li><li>由工具处理.class文件使用的注解：会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中</li><li>在程序运行期能够读取的注解：在加载后一直存在于JVM中</li></ul><h3 id=配置参数>配置参数
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0>#</a></h3><p>可以有默认值；大部分注解会有一个名为 <code>value</code> 的配置参数，可以省略value参数</p><ul><li>所有基本类型；</li><li>String；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组</li></ul><h3 id=定义方式>定义方式
<a class=anchor href=#%e5%ae%9a%e4%b9%89%e6%96%b9%e5%bc%8f>#</a></h3><ul><li>使用<code>@interface</code>语法来定义注解</li><li>用<code>default</code>设定一个默认值（强烈推荐）</li></ul><h3 id=元注解>元注解
<a class=anchor href=#%e5%85%83%e6%b3%a8%e8%a7%a3>#</a></h3><ul><li>修饰其他注解的注解</li><li>Java标准库定义</li><li>常用<ul><li>@Target：定义<code>Annotation</code>能够被应用于源码的哪些位置（数组）<ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code></li></ul></li><li>@Retention：定义<code>Annotation</code>的生命周期（默认值CLASS）<ul><li><code>RetentionPolicy.SOURCE</code>：在编译期就被丢掉（由编译器使用）</li><li><code>RetentionPolicy.CLASS</code>：仅保存在class文件中，它们不会被加载进JVM（主要由底层工具库使用）</li><li>RetentionPolicy.RUNTIME`：会被加载进JVM，并且在运行期可以被程序读取</li></ul></li><li>@Repeatabl：定义<code>Annotation</code>是否可重复</li><li>@Inherited：定义子类是否可继承父类定义的<code>Annotation</code></li></ul></li></ul><h3 id=使用方式>使用方式
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f>#</a></h3><p>注解定义后也是一种 <code>class</code> ，所有的注解都继承自 <code>java.lang.annotation.Annotation</code> 。读取注解，需要使用反射API</p><ul><li><code>Class.isAnnotationPresent(Class)</code></li><li><code>Field.isAnnotationPresent(Class)</code></li><li><code>Method.isAnnotationPresent(Class)</code></li><li><code>Constructor.isAnnotationPresent(Class)</code></li></ul></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./interview/java.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#基本数据类型>基本数据类型</a></li><li><a href=#异常处理>异常处理</a><ul><li><a href=#三种类型的异常>三种类型的异常</a></li><li><a href=#关键字>关键字</a></li><li><a href=#自定义异常>自定义异常</a></li></ul></li><li><a href=#hashmap>hashMap</a></li><li><a href=#concurrenthashmap的实现原理>ConcurrentHashMap的实现原理</a></li><li><a href=#final关键字>final关键字</a></li><li><a href=#string实现>String实现</a></li><li><a href=#clone>clone</a></li><li><a href=#volatile>volatile</a></li><li><a href=#synchronized>synchronized</a></li><li><a href=#偏向锁自旋锁轻量级锁乐观锁重量级锁悲观锁>偏向锁，自旋锁，轻量级锁（乐观锁）重量级锁（悲观锁）</a></li><li><a href=#aqs一个用来构建锁和同步器的框架>AQS（一个用来构建锁和同步器的框架）</a></li><li><a href=#reentrantlock>ReentrantLock</a></li><li><a href=#线程池>线程池</a></li><li><a href=#反射>反射</a><ul><li><a href=#常用方法>常用方法</a></li></ul></li><li><a href=#注解>注解</a><ul><li><a href=#注解的作用>注解的作用</a></li><li><a href=#配置参数>配置参数</a></li><li><a href=#定义方式>定义方式</a></li><li><a href=#元注解>元注解</a></li><li><a href=#使用方式>使用方式</a></li></ul></li></ul></nav></div></aside></main></body></html>