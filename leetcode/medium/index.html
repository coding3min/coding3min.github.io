<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LeetCode-hot100-medium #  介绍 #  一句话总结算法思路，LeetCode hot100 medium
按频率排序，排序依据参考 字节跳动后端高频面试题目。
全部源码可见我的GitHub interview-leetcode
注：
有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。
3.无重复字符的最长子串 #  题目： 在字符串中找一个子串，要求连续无重复字符且最长，只需要返回最大长度
题解：
 字符串长度为0直接返回 记录最大子串的长度，用来和新子串长度比较，维护子串的状态还需要记录当前子串的起始位置的下标 使用map来储存字符对应的下标， 只要当前字符出现在map里，同时map里的字符就是子串里的字符时（存储的字符下标大于等于起始位置下标）说明重复，更新子串起始位置为map中记录的重复点+1 else (没有出现在子串里)，子串长度++，判断更新最大长度(注意更新时+1)  代码： golang
215.数组中的第k个最大元素 #  题目： 数组中的第k个最大元素，比如第二大，就是找次大。
题解： 方法1，堆排序（不推荐）
 求第K大的数，实际上就是取小根堆的根节点 小根堆的性质，根节点比所有叶子节点更小   注意：这里为什么用堆，是因为堆是一个完全二叉树，而二叉搜索树不自平衡，而且堆的话小根堆保证堆个数为k，直接取根节点就是结果了
堆排序的好处是，假设k比较小，而数组比较大，不需要加载全部内容到内存里
方法2 快速排序变形（快速选择算法）
 其实就是快排的思路，只是做了下剪枝 只要保证len-k这个位置右侧全部比k大，左侧全部小于等于k，那么len-k位置的数就是第k大    因为我们不知道是哪个数，所以随便取一个数x，最终达到左侧全部<=x，右侧全部>x的效果，核心代码如下  // 快排剪枝 func quickSelect(a []int, l, r, index int) int { // 查找中枢  q := randomPartition(a, l, r) if q == index { return a[q] } else if q < index { return quickSelect(a, q + 1, r, index) } return quickSelect(a, l, q - 1, index) }  把x的下标index和len-k比较，如果小，说明第k大数一定在[index+1,r]；如果大说明第k大数一定在[l,index-1]中 缩小区间，继续随便取一个数，直到正好x的下标就是len-k为止  查找中枢的办法借助快排的思路"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="LeetCode-hot100-medium #  介绍 #  一句话总结算法思路，LeetCode hot100 medium
按频率排序，排序依据参考 字节跳动后端高频面试题目。
全部源码可见我的GitHub interview-leetcode
注：
有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。
3.无重复字符的最长子串 #  题目： 在字符串中找一个子串，要求连续无重复字符且最长，只需要返回最大长度
题解：
 字符串长度为0直接返回 记录最大子串的长度，用来和新子串长度比较，维护子串的状态还需要记录当前子串的起始位置的下标 使用map来储存字符对应的下标， 只要当前字符出现在map里，同时map里的字符就是子串里的字符时（存储的字符下标大于等于起始位置下标）说明重复，更新子串起始位置为map中记录的重复点+1 else (没有出现在子串里)，子串长度++，判断更新最大长度(注意更新时+1)  代码： golang
215.数组中的第k个最大元素 #  题目： 数组中的第k个最大元素，比如第二大，就是找次大。
题解： 方法1，堆排序（不推荐）
 求第K大的数，实际上就是取小根堆的根节点 小根堆的性质，根节点比所有叶子节点更小   注意：这里为什么用堆，是因为堆是一个完全二叉树，而二叉搜索树不自平衡，而且堆的话小根堆保证堆个数为k，直接取根节点就是结果了
堆排序的好处是，假设k比较小，而数组比较大，不需要加载全部内容到内存里
方法2 快速排序变形（快速选择算法）
 其实就是快排的思路，只是做了下剪枝 只要保证len-k这个位置右侧全部比k大，左侧全部小于等于k，那么len-k位置的数就是第k大    因为我们不知道是哪个数，所以随便取一个数x，最终达到左侧全部<=x，右侧全部>x的效果，核心代码如下  // 快排剪枝 func quickSelect(a []int, l, r, index int) int { // 查找中枢  q := randomPartition(a, l, r) if q == index { return a[q] } else if q < index { return quickSelect(a, q + 1, r, index) } return quickSelect(a, l, q - 1, index) }  把x的下标index和len-k比较，如果小，说明第k大数一定在[index+1,r]；如果大说明第k大数一定在[l,index-1]中 缩小区间，继续随便取一个数，直到正好x的下标就是len-k为止  查找中枢的办法借助快排的思路"><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/leetcode/medium/"><meta property="article:section" content="LeetCode"><title>Medium | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fa55d4ab6347cff8bc3ae9cefd152a646ed2f9d06f23a24af15f5f4aeb5f3414.js integrity="sha256-+lXUq2NHz/i8OunO/RUqZG7S+dBvI6JK8V9fSutfNBQ=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/contribute/>如何贡献</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=/interview/xiang-mu-wen-shi-mo/>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/ class=active>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=/interview/cao-zuo-xi-tong/>操作系统</a></li><li><a href=/interview/qian-duan/>前端</a></li><li><a href=/interview/linux/>Linux</a></li><li><a href=/interview/go/><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=/interview/java/>Java</a></li><li><a href=/interview/redis/>Redis</a></li><li><a href=/interview/mysql/>Mysql</a></li><li><a href=/interview/queue/>消息队列</a></li><li><a href=/interview/network/>网络</a></li><li><a href=/interview/mongodb/>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=/interview/mysql/><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Medium</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#3无重复字符的最长子串>3.无重复字符的最长子串</a></li><li><a href=#215数组中的第k个最大元素>215.数组中的第k个最大元素</a></li><li><a href=#15三数之和>15.三数之和</a></li><li><a href=#22括号生成>22.括号生成</a></li><li><a href=#103二叉树的锯齿形层序遍历>103.二叉树的锯齿形层序遍历</a></li><li><a href=#39组合总合>39.组合总合</a></li><li><a href=#142-环形链表-ii>142. 环形链表 II</a></li><li><a href=#300最长递增子序列>300.最长递增子序列</a></li><li><a href=#1143最长公共子序列>1143.最长公共子序列</a></li><li><a href=#59螺旋矩阵-ii>59.螺旋矩阵-ii</a></li><li><a href=#搜索二维矩阵>搜索二维矩阵</a></li><li><a href=#最后>最后</a></li></ul></nav></aside></header><article class=markdown><h1 id=leetcode-hot100-medium>LeetCode-hot100-medium
<a class=anchor href=#leetcode-hot100-medium>#</a></h1><h2 id=介绍>介绍
<a class=anchor href=#%e4%bb%8b%e7%bb%8d>#</a></h2><p>一句话总结算法思路，LeetCode hot100 medium</p><p>按频率排序，排序依据参考
<a href=https://github.com/afatcoder/LeetcodeTop/blob/master/bytedance/backend>字节跳动后端高频面试题目</a>。</p><p>全部源码可见我的GitHub
<a href=https://github.com/coding3min/interview-leetcode/tree/master/LeetCode/all>interview-leetcode</a></p><p>注：</p><p>有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。</p><h2 id=3无重复字符的最长子串>3.无重复字符的最长子串
<a class=anchor href=#3%e6%97%a0%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e6%9c%80%e9%95%bf%e5%ad%90%e4%b8%b2>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/>在字符串中找一个子串，要求连续无重复字符且最长，只需要返回最大长度</a></p><p>题解：</p><ul><li>字符串长度为0直接返回</li><li>记录最大子串的长度，用来和新子串长度比较，维护子串的状态还需要记录当前子串的起始位置的下标</li><li>使用map来储存字符对应的下标，</li><li>只要当前字符出现在map里，同时map里的字符就是子串里的字符时（存储的字符下标大于等于起始位置下标）说明重复，更新子串起始位置为map中记录的重复点+1</li><li>else (没有出现在子串里)，子串长度++，判断更新最大长度(注意更新时+1)</li></ul><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/3.%e6%97%a0%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e6%9c%80%e9%95%bf%e5%ad%90%e4%b8%b2.go>golang</a></p><h2 id=215数组中的第k个最大元素>215.数组中的第k个最大元素
<a class=anchor href=#215%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e7%ac%ack%e4%b8%aa%e6%9c%80%e5%a4%a7%e5%85%83%e7%b4%a0>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/>数组中的第k个最大元素，比如第二大，就是找次大。</a></p><p>题解： 方法1，堆排序（不推荐）</p><ul><li>求第K大的数，实际上就是取小根堆的根节点</li><li>小根堆的性质，根节点比所有叶子节点更小</li></ul><p><img src=https://coding3min.oss-accelerate.aliyuncs.com/2021/07/27/ffd837f564946747ff6fca9df7568fa894494f2e46fe0fe2d6590123432f0a57.gif alt></p><p>注意：这里为什么用堆，是因为堆是一个完全二叉树，而二叉搜索树不自平衡，而且堆的话小根堆保证堆个数为k，直接取根节点就是结果了</p><p>堆排序的好处是，假设k比较小，而数组比较大，不需要加载全部内容到内存里</p><p>方法2 快速排序变形（快速选择算法）</p><ul><li>其实就是快排的思路，只是做了下剪枝</li><li>只要保证len-k这个位置右侧全部比k大，左侧全部小于等于k，那么len-k位置的数就是第k大</li></ul><p><img src=https://coding3min.oss-accelerate.aliyuncs.com/2021/07/27/nwa3pv.jpg alt></p><ul><li>因为我们不知道是哪个数，所以随便取一个数x，最终达到左侧全部<code>&lt;=x</code>，右侧全部<code>>x</code>的效果，核心代码如下</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 快排剪枝
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>quickSelect</span>(<span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
    <span style=color:#75715e>// 查找中枢
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>q</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>randomPartition</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>index</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>q</span>]
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>q</span> &lt; <span style=color:#a6e22e>index</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>quickSelect</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>index</span>)
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>quickSelect</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>index</span>)
}
</code></pre></div><ul><li>把x的下标index和len-k比较，如果小，说明第k大数一定在<code>[index+1,r]</code>；如果大说明第k大数一定在<code>[l,index-1]</code>中</li><li>缩小区间，继续随便取一个数，直到正好x的下标就是len-k为止</li></ul><p>查找中枢的办法借助快排的思路</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>//随机中枢
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>randomPartition</span>(<span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
    <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Int</span>() <span style=color:#f92672>%</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>l</span>
	<span style=color:#75715e>// 因为把r的位置作为中枢，所以要交换
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>] = <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>]
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>partition</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span>)
}
</code></pre></div><ul><li>随机取一个数x，把他和r位置的数对调</li><li>找到中枢的正确位置，保证左侧都比它小，右侧都比他大</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>//快排核心代码
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>partition</span>(<span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>l</span>, <span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
	<span style=color:#75715e>// 因为传入的中枢是r位置
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>]
	<span style=color:#75715e>// 先把i设置为l-1区间之外，保证每次更新先++再更新
</span><span style=color:#75715e></span>	<span style=color:#75715e>// i 的作用是记录小于中枢的区间
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
	<span style=color:#75715e>// j不能遍历到r位置，因为r是中枢本身，查找完之后再做交换
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#a6e22e>r</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
		<span style=color:#75715e>// 遍历l到r，保证i左侧包括i位置记录的都小于等于x,右侧全部大于x
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>x</span> {
            <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
            <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>]
        }
    }
	<span style=color:#75715e>// 最后遍历完交换r和i+1位置，把中枢放到正确的地方
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>] = <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>r</span>], <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
}
</code></pre></div><ul><li>维护左侧区间都比x小，所以初始化i为l-1</li><li>变量j遍历<code>[l,r)</code> 左闭右开区间，大于x无操作</li><li>小于x时候,<code>i++</code>，然后对调i和j位置的数字，这样又可以保证i左侧包括i位置的数都小于x</li><li>遍历结束以后i+1位置的数正好是最后一个比i大的数，把他和r对调</li><li>返回i+1，也就是中枢位置的下标</li></ul><p><strong>时间复杂度</strong>：运气好就是一次就找到了<code>On</code>运气不好每个数都找了一次<code>ON^2</code>，算法导论中把每次查找都使用一个随机数，可以显著提高效率，趋近于On，具体为什么可以自己去看</p><p>为什么推荐用快选，因为空间O1，时间<code>On~On^2</code>比堆的时间<code>Onlogn</code>和<code>Ologk</code>更快，但是快排也有局限性</p><ul><li>快选需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</li><li>堆只需要保存 k 个元素的小根堆。快速排序变形的方法如果不允许修改原数组那就要保存下来所有的数据，所以数据量大时用堆更好</li></ul><p>引用：
<a href=https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/>优劣比较</a></p><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/215.%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e7%ac%ack%e4%b8%aa%e6%9c%80%e5%a4%a7%e5%85%83%e7%b4%a0.go>golang</a></p><h2 id=15三数之和>15.三数之和
<a class=anchor href=#15%e4%b8%89%e6%95%b0%e4%b9%8b%e5%92%8c>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/>数组里有没有三个数加起来为0，找出所有可能的情况</a></p><p>题解：</p><ul><li>先把数组排序</li><li>从小到大遍历这个数组，每次取一个元素，将这个元素的相反数设为<code>target</code></li><li>在每次遍历中，使用双指针对当前元素的后面的所有元素进行处理，找到所有两个元素的和为<code>target</code>，这样，三个元素的和就是 0</li><li>双指针的具体处理方式为：头尾各一个指针，每次判断两个指针所指的元素的和与target的大小，如果和小了，左指针右移；如果和大了，右指针左移，直到两个指针相遇</li></ul><p>注意：</p><ul><li>因为不能有重复的结果，所以前后两次遍历取的元素如果相等，要采取跳过的操作</li><li>在第三步中，对当前元素的后面的所有元素进行处理的原因是，前面的元素已经找到了所有符合条件的可能，不需要再找</li></ul><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/15.%e4%b8%89%e6%95%b0%e4%b9%8b%e5%92%8c.go>golang</a> 引用：
<a href=https://zhuanlan.zhihu.com/p/53519899>【LeetCode】15#三数之和</a></p><h2 id=22括号生成>22.括号生成
<a class=anchor href=#22%e6%8b%ac%e5%8f%b7%e7%94%9f%e6%88%90>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/generate-parentheses/description/>数字n代表生成括号的对数,请生成所有可能的并且有效的 括号组合</a>3</p><p>比如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>输入：n = 3
输出：[&#34;((()))&#34;,&#34;(()())&#34;,&#34;(())()&#34;,&#34;()(())&#34;,&#34;()()()&#34;]
</code></pre></div><p>题解：</p><ul><li>找不同可能性的题目，解题思路优先考虑深度优先dfs</li><li>既然是有效的括号组合而且只有小括号，那么只需要维护n个左括号，n个右括号的组合</li><li>深度优先，就是类似二叉树的遍历，使用模板</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>根</span>){
    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>左子</span>)
    <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>右子</span>)
}
</code></pre></div><ul><li>要维护左右括号的个数</li><li>因为是有效的括号，要先拼左括号再拼右括号，需要左右括号相等，所以</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>左括号个数</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>右括号个数</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>当前字符串</span>){
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>左</span>&gt;<span style=color:#a6e22e>右</span>{
        <span style=color:#66d9ef>return</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>左</span><span style=color:#f92672>==</span><span style=color:#a6e22e>右</span>{
        append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>当前字符串</span>)
        <span style=color:#66d9ef>return</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>左</span>&gt;<span style=color:#ae81ff>0</span>{
        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>左</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>右</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>当前</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;(&#34;</span>)
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>右</span>&gt;<span style=color:#ae81ff>0</span>{
        <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>左</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>右</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>当前</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;)&#34;</span>)
    }
}
</code></pre></div><p>注意：边界n==0不需要查找</p><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/22.%e6%8b%ac%e5%8f%b7%e7%94%9f%e6%88%90.go>golang</a></p><h2 id=103二叉树的锯齿形层序遍历>103.二叉树的锯齿形层序遍历
<a class=anchor href=#103%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%94%af%e9%bd%bf%e5%bd%a2%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/description/>先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进</a></p><p>题解：不改变原树结构，层遍历，维护正反bool条件，头插尾插，最终返回二维数组</p><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/103.%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%94%af%e9%bd%bf%e5%bd%a2%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86.go>golang</a></p><h2 id=39组合总合>39.组合总合
<a class=anchor href=#39%e7%bb%84%e5%90%88%e6%80%bb%e5%90%88>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/combination-sum/description/>找出数组里所有和等于target的总合</a></p><p>题解：回溯，边界是sum大于target剪枝，等于就拿到一个结果</p><p>注意：append一维数组的时候要拷贝下</p><p>拷贝函数参考</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tmp</span> []<span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>tmp</span> = append(<span style=color:#a6e22e>tmp</span>,<span style=color:#a6e22e>curr</span><span style=color:#f92672>...</span>)
<span style=color:#a6e22e>res</span> = append(<span style=color:#a6e22e>res</span>,<span style=color:#a6e22e>tmp</span>)
</code></pre></div><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/39.%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8c.go>golang</a></p><h2 id=142-环形链表-ii>142. 环形链表 II
<a class=anchor href=#142-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8-ii>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/linked-list-cycle-ii/>找到交点坐标的下标，无环时返回null</a></p><p>题解：</p><ul><li>这不仅仅是返回是否相交，还要找到交点的下标；我们知道可以用双指针相遇时说明相交</li><li>找到交点时，快指针正好比慢指针多一圈</li></ul><p><img src=../assets/2021-04-14-17-29-43.png alt></p><p>设链表共有 a+b+c 个节点，链表头部到链表入口有 a 个节点（不计链表入口节点），相遇时快指针走了a+b+c+b次，慢指针走了a+b次，发件人指针是慢指针的两倍速度,可得</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>a+b+c+b = 2(a+b)
c=a
</code></pre></div><p>所以相遇时再加一个头指针一起跑，慢指针继续跑相遇点就是环的起始位置</p><p>代码不写了，比较简单</p><h2 id=300最长递增子序列>300.最长递增子序列
<a class=anchor href=#300%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/longest-increasing-subsequence/description/>求最长递增子序列的长度，子序列是不连续的</a></p><p>题解：求最值，不用保存子序列，我们记录数组里每个数作为终点的序列最长长度就好了</p><ul><li>对每个数都遍历之前的数，只要比当前数小，说明他可以作为终点</li><li>因为已经记录了之前数作为终点的序列长度，让序列长度+1就可以</li><li>再做下对比，公式如下</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>dp</span>[<span style=color:#a6e22e>i</span>],<span style=color:#a6e22e>dp</span>[<span style=color:#a6e22e>j</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</code></pre></div><p>得到所有序列作为终点的最长子序列长度数组以后，遍历下取最值就好了</p><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/300.%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97.go>golang</a></p><h2 id=1143最长公共子序列>1143.最长公共子序列
<a class=anchor href=#1143%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/longest-common-subsequence/description/>求两个数组的最长公共子序列长度</a></p><p>题解：</p><ul><li><p>用二维数组dp记录最长公共子序列长度，<code>dp[i][j]</code> 为当前位置最长公共子序列长度，状态转移方程</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 其中因为当前字符相等，所以长度各减1的dp[i-1][j-1]表示没有当前字符时字符串的最长公共子序列长度
</span><span style=color:#75715e>// 也就是加入text1长度为i，text2长度为j，i j 就是当前长度的最长公共子序列,i-1 j 代表长度为i-1的字符串与j的字符串公共子序列长度
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>text1</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>text2</span>[<span style=color:#a6e22e>j</span>] <span style=color:#a6e22e>then</span> <span style=color:#a6e22e>dp</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>dp</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#a6e22e>j</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> 
<span style=color:#75715e>// 长度不一样时对比各自长度-1，作为当前长度最长公共子序列
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>text1</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>text2</span>[<span style=color:#a6e22e>j</span>] <span style=color:#a6e22e>then</span> <span style=color:#a6e22e>dp</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>dp</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#a6e22e>j</span>],<span style=color:#a6e22e>dp</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>j</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</code></pre></div></li></ul><p>注意：i-1 和 j-1 会越界，申明时让dp行列<code>len+1</code></p><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/1143.%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97.go>golang</a></p><h2 id=59螺旋矩阵-ii>59.螺旋矩阵-ii
<a class=anchor href=#59%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5-ii>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/spiral-matrix-ii/description/>给一个数字n，输出n*n的正方形螺旋矩阵</a></p><p>题解：生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：</p><ul><li>定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n；</li><li>当 num &lt;= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：<ul><li>执行 num += 1：得到下一个需要填入的数字；</li><li>更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。</li></ul></li><li>使用num &lt;= tar而不是l &lt; r || t &lt; b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</li></ul><p>最终返回 mat 即可。</p><p><a href=https://leetcode-cn.com/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/>题解来源</a></p><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/59.%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5-ii.go>golang</a></p><h2 id=搜索二维矩阵>搜索二维矩阵
<a class=anchor href=#%e6%90%9c%e7%b4%a2%e4%ba%8c%e7%bb%b4%e7%9f%a9%e9%98%b5>#</a></h2><p>题目：
<a href=https://leetcode-cn.com/problems/search-a-2d-matrix/description/>递增的二维矩阵，搜索值是否在内部</a></p><p>题解：方法1，简单搜索</p><ul><li>以二维数组左下角为原点，建立直角坐标轴。</li><li>若当前数字大于了查找数，查找往上移一位。</li><li>若当前数字小于了查找数，查找往右移一位。</li></ul><p><a href=https://leetcode-cn.com/problems/search-a-2d-matrix/solution/zuo-biao-zhou-fa-er-wei-shu-zu-zhong-de-nxfc8/>题解来源</a></p><p>方法2，二分搜索（独创）</p><p>既然列递增，且行递增，下一行所有数字都比上一行大，可以把二维数组拼接起来，视为递增的一纬度数组来处理</p><ul><li>取行列长度n1 n2，得到全局数字个数n1*n2</li><li>使用二分法，取数字时，mid/n2为行，mid%n2为列即可</li></ul><p><a href=https://leetcode-cn.com/problems/search-a-2d-matrix/solution/tui-hua-fa-yi-ci-er-fen-zhao-dao-shu-zi-k36is/>我的题解</a></p><p>代码：
<a href=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/all/74.%e6%90%9c%e7%b4%a2%e4%ba%8c%e7%bb%b4%e7%9f%a9%e9%98%b5.go>golang</a></p><h2 id=最后>最后
<a class=anchor href=#%e6%9c%80%e5%90%8e>#</a></h2><p>如果文中有误，欢迎提pr或者issue，<strong>一旦合并或采纳作为贡献奖励可以联系我直接无门槛</strong>加入
<a href=https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q>技术交流群</a></p><p>我是小熊，关注我，知道更多不知道的技术</p><p><img src=https://github.com/coding3min/interview-leetcode/tree/a5bdcb9c83a659846f49bc48e9345212b7f95784/LeetCode/hot100/res/2021-03-17-19-57-33.png alt></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=coding3min/comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/./LeetCode/medium.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#3无重复字符的最长子串>3.无重复字符的最长子串</a></li><li><a href=#215数组中的第k个最大元素>215.数组中的第k个最大元素</a></li><li><a href=#15三数之和>15.三数之和</a></li><li><a href=#22括号生成>22.括号生成</a></li><li><a href=#103二叉树的锯齿形层序遍历>103.二叉树的锯齿形层序遍历</a></li><li><a href=#39组合总合>39.组合总合</a></li><li><a href=#142-环形链表-ii>142. 环形链表 II</a></li><li><a href=#300最长递增子序列>300.最长递增子序列</a></li><li><a href=#1143最长公共子序列>1143.最长公共子序列</a></li><li><a href=#59螺旋矩阵-ii>59.螺旋矩阵-ii</a></li><li><a href=#搜索二维矩阵>搜索二维矩阵</a></li><li><a href=#最后>最后</a></li></ul></nav></div></aside></main></body></html>