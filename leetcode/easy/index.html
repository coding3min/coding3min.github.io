<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="LeetCode-hot100-easy #  介绍 #  一句话总结算法思路，LeetCode hot100 easy
总计21题，题目列表请戳 LeetCode Hot100 easy 列表。
全部源码可见我的GitHub interview-leetcode
注：
有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。
题解 #  1.两数之和(高频) #  题目： 数据中是否有两个数之和为目标值
题解：遍历数组，用目标值减去当前值，判断HashMap是否有值存在，如果有则创建新数组返回两者，如果没有循环遍历完返回空数组
时间复杂度：O(1) 代码： golang
20.有效的括号(高频) #  题目： 存在[]{})(的字符串，判断是否合法
题解： 存储左括号和右括号的映射，用栈统计左括号，出现左括号就入栈，出现右括号就和栈顶在map中映射的右括号比较，如果匹配就出栈，不匹配返回false，最后遍历完栈空为false
注意：go语言可以用byte代表单个字符
代码： golang
21.合并两个有序链表(高频) #  题目： 两个升序链表，合并成一个
题解：
 需要一个空的头节点做辅助，head.Next就是结果 每次遍历始终维护上一个节点prev，初始值prev=head 循环遍历两个链表，循环条件都不为空，每次把当前节点更小的取出来即可  prev.Next = l1 prev = l1 l1 = l1.Next  最后加入有不为空的节点，则直接赋值  if l1!=nil{ prev.Next = l1 }else{ prev."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="LeetCode-hot100-easy #  介绍 #  一句话总结算法思路，LeetCode hot100 easy
总计21题，题目列表请戳 LeetCode Hot100 easy 列表。
全部源码可见我的GitHub interview-leetcode
注：
有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。
题解 #  1.两数之和(高频) #  题目： 数据中是否有两个数之和为目标值
题解：遍历数组，用目标值减去当前值，判断HashMap是否有值存在，如果有则创建新数组返回两者，如果没有循环遍历完返回空数组
时间复杂度：O(1) 代码： golang
20.有效的括号(高频) #  题目： 存在[]{})(的字符串，判断是否合法
题解： 存储左括号和右括号的映射，用栈统计左括号，出现左括号就入栈，出现右括号就和栈顶在map中映射的右括号比较，如果匹配就出栈，不匹配返回false，最后遍历完栈空为false
注意：go语言可以用byte代表单个字符
代码： golang
21.合并两个有序链表(高频) #  题目： 两个升序链表，合并成一个
题解：
 需要一个空的头节点做辅助，head.Next就是结果 每次遍历始终维护上一个节点prev，初始值prev=head 循环遍历两个链表，循环条件都不为空，每次把当前节点更小的取出来即可  prev.Next = l1 prev = l1 l1 = l1.Next  最后加入有不为空的节点，则直接赋值  if l1!=nil{ prev.Next = l1 }else{ prev."><meta property="og:type" content="article"><meta property="og:url" content="https://leetcode.coding3min.com/leetcode/easy/"><meta property="article:section" content="LeetCode"><title>Easy | 程序员的魔法书</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.958cea7827621d6fbcb3acf091344c3e44e3d2a9428f9c3c38bb9eb37bf8c45d.css integrity="sha256-lYzqeCdiHW+8s6zwkTRMPkTj0qlCj5w8OLues3v4xF0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.cb87d6945700e4d526d4bd625513edb4dbb96da0bc0dfbe025929056bf765946.js integrity="sha256-y4fWlFcA5NUm1L1iVRPttNu5baC8DfvgJZKQVr92WUY=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><img src=/logo.png alt=Logo><span>程序员的魔法书</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/readme/>知识库介绍</a></li><li><a href=/todo/>待解答问题列表</a></li><li><a href=%e8%b5%84%e6%ba%90%e5%ba%93/README>资源库</a></li><li><a href=/blog/>大佬Blog</a></li><li><a href=interview/xiang-mu-wen-shi-mo>项目一般问什么</a></li><li><a href=/leetcode/suan-fa-mian-shi-zhu-yi/>算法面试注意</a></li><li><a href=/leetcode/shu-ju-jie-gou/>数据结构</a></li><li><a href=/leetcode/easy/ class=active>LeetCode-hot100-easy</a></li><li><a href=/leetcode/medium/>LeetCode-hot100-medium</a></li><li><a href=/leetcode/difficult/>LeetCode-hot100-difficult</a></li><li><a href=/leetcode/other/>其他高频算法</a></li><li><a href=/leetcode/hua-wei-ji-shi/>华为机试</a></li><li><a href=interview/cao-zuo-xi-tong>操作系统</a></li><li><a href=interview/qian-duan>前端</a></li><li><a href=interview/linux>Linux</a></li><li><a href=interview/go><strong>Go</strong></a><ul><li><a href=https://golang.coding3min.com>Go语言精进之路</a></li></ul></li><li><a href=interview/java>Java</a></li><li><a href=interview/redis>Redis</a></li><li><a href=interview/mysql>Mysql</a></li><li><a href=interview/queue>消息队列</a></li><li><a href=interview/network>网络</a></li><li><a href=interview/mongodb>mongoDB</a></li><li><a href=/leetcode-vscode/>协作办法</a></li><li><a href=interview/devops><strong>devops</strong></a><ul><li><a href=jenkins/jenkins%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8>jenkins 快速入门</a></li></ul></li><li><a href=interview/mysql><strong>Mysql</strong></a><ul><li><a href=mysql/%e9%9b%86%e7%be%a4>集群</a><ul><li><a href=/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/>快速拉起</a></li></ul></li><li><a href=mysql/%e4%b8%bb%e4%bb%8e>主从</a><ul><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/>建立主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/relaylog/>relaylog 详解</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/>主从切换</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/>集群方案切换为互为主从</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/>常见故障</a></li><li><a href=/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/>mysql 的 expire_logs_days 参数引发的主从状态丢失问题</a></li></ul></li><li><a href=mysql/%e8%bf%90%e7%bb%b4>运维</a><ul><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/>备份数据库</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/>重建 mysql 数据库的方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/>mysql 正确清理 binlog 日志的两种方法</a></li><li><a href=/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/>注意事项</a></li></ul></li></ul></li><li><a href=/tools/readme/>实用工具</a></li><li><a href=docker><strong>Docker</strong></a><ul><li><strong>Docker 入门</strong><ul><li><a href=Docker>容器&Docker 入门</a></li><li><a href=Docker/chapter.1/docker-story>容器故事</a></li><li><a href=Docker/chapter.1/deal-what>能解决什么问题</a></li><li><a href=Docker/chapter.1/docker-superiority>优势</a></li><li><a href=Docker/chapter.1/what-is-image>镜像概念</a></li><li><a href=Docker/chapter.1/what-is-docker>容器概念</a></li><li><a href=Docker/chapter.1/what-is-repository>仓库概念</a></li></ul></li><li><a href=Docker><strong>Docker 安装</strong></a><ul><li><a href=Docker/chapter.1/%e5%ae%89%e8%a3%85Docker>安装说明</a></li><li><a href=Docker/chapter.1/Centos%e5%ae%89%e8%a3%85>CentOS 安装</a></li><li><a href=Docker/chapter.1/Windows%e5%ae%89%e8%a3%85>Windows 安装</a></li><li><a href=Docker/chapter.1/Macbook%e5%ae%89%e8%a3%85>Macbook 安装</a></li><li><a href=Docker/chapter.1/README>容器&docker 入门实验</a></li></ul></li><li><a href=Docker/chapter.2/README><strong>Docker 命令</strong></a><ul><li><a href=Docker/chapter.2/base-command>基础命令</a></li><li><a href=Docker/chapter.2/image-command>镜像命令</a></li><li><a href=Docker/chapter.2/container-command>容器操作命令</a></li><li><a href=Docker/chapter.2/container-command2>容器管理命令</a></li><li><a href=Docker/chapter.2/resources-command>资源命令</a></li><li><a href=Docker/chapter.2/lab-wordpress>wordpress 博客系统</a></li><li><a href=Docker/chapter.2/lab-python>python 文件下载系统</a></li></ul></li><li><strong>Docker 镜像</strong><ul><li><a href=Docker/chapter.3/c-dockerfile>Dockerfile</a></li><li><a href=Docker/chapter.3/repositories>个人仓库</a></li><li><a href=Docker/chapter.4/best-dockerfile>Dockerfile 最佳实践</a></li><li><a href=Docker/chapter.4/best-dockerfile-other>Dockerfile 其他建议</a></li></ul></li><li><strong>Docker 网络-todo</strong></li><li><strong>Docker 存储-todo</strong><ul><li>数据卷-todo</li><li>挂载卷-todo</li></ul></li><li><strong>Docker Compose-todo</strong></li><li><strong>Docker Swarm-todo</strong></li></ul></li><li><a href=k8s>k8s</a><ul><li>Kubernetes 入门-todo</li><li><a href=Kubernetes/chapter.1/install-k8s>Kubernetes 安装-todo</a></li><li><a href=Kubernetes/skill/k8s%e6%8a%80%e5%b7%a7%e5%ae%8c%e5%85%a8%e7%89%88>k8s 技巧大全</a></li><li><a href=Kubernetes/CKA-1/Intorduction>CKA 刷题之路</a><ul><li><a href=Kubernetes/CKA-1/cka-list>2019 年考试题目</a></li></ul></li></ul></li></ul></nav><script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Easy</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#题解>题解</a><ul><li><a href=#1两数之和高频>1.两数之和(高频)</a></li><li><a href=#20有效的括号高频>20.有效的括号(高频)</a></li><li><a href=#21合并两个有序链表高频>21.合并两个有序链表(高频)</a></li><li><a href=#53最大子序和高频>53.最大子序和(高频)</a></li><li><a href=#70爬楼梯>70.爬楼梯</a></li><li><a href=#101对称二叉树>101.对称二叉树</a></li><li><a href=#104二叉树的最大深度>104.二叉树的最大深度</a></li><li><a href=#121买卖股票的最佳时机高频>121.买卖股票的最佳时机(高频)</a></li><li><a href=#136只出现一次的数字>136.只出现一次的数字</a></li><li><a href=#141环形链表高频>141.环形链表(高频)</a></li><li><a href=#155最小栈中频>155.最小栈(中频)</a></li><li><a href=#160相交链表高频>160.相交链表(高频)</a></li><li><a href=#169多数元素>169.多数元素</a></li><li><a href=#206反转链表高频>206.反转链表(高频)</a></li><li><a href=#226翻转二叉树>226.翻转二叉树</a></li><li><a href=#234回文链表>234.回文链表</a></li><li><a href=#283移动零>283.移动零</a></li><li><a href=#448找到所有数组中消失的数字>448.找到所有数组中消失的数字</a></li><li><a href=#461汉明距离>461.汉明距离</a></li><li><a href=#543二叉树的直径>543.二叉树的直径</a></li><li><a href=#617合并二叉树>617.合并二叉树</a></li></ul></li><li><a href=#最后>最后</a></li></ul></nav></aside></header><article class=markdown><h1 id=leetcode-hot100-easy>LeetCode-hot100-easy
<a class=anchor href=#leetcode-hot100-easy>#</a></h1><h2 id=介绍>介绍
<a class=anchor href=#%e4%bb%8b%e7%bb%8d>#</a></h2><p>一句话总结算法思路，LeetCode hot100 easy</p><p>总计21题，题目列表请戳
<a href="https://leetcode-cn.com/problemset/leetcode-hot-100/?difficulty=%E7%AE%80%E5%8D%95">LeetCode Hot100 easy 列表</a>。</p><p>全部源码可见我的GitHub
<a href=https://github.com/minibear2333/interview-leetcode/tree/master/LeetCode/all>interview-leetcode</a></p><p>注：</p><p>有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。</p><h2 id=题解>题解
<a class=anchor href=#%e9%a2%98%e8%a7%a3>#</a></h2><h3 id=1两数之和高频>1.两数之和(高频)
<a class=anchor href=#1%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c%e9%ab%98%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/two-sum>数据中是否有两个数之和为目标值</a></p><p>题解：遍历数组，用目标值减去当前值，判断HashMap是否有值存在，如果有则创建新数组返回两者，如果没有循环遍历完返回空数组</p><p>时间复杂度：O(1) 代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/1.%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c.go>golang</a></p><h3 id=20有效的括号高频>20.有效的括号(高频)
<a class=anchor href=#20%e6%9c%89%e6%95%88%e7%9a%84%e6%8b%ac%e5%8f%b7%e9%ab%98%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/valid-parentheses>存在<code>[]{})(</code>的字符串，判断是否合法</a></p><p>题解： 存储左括号和右括号的映射，用栈统计左括号，出现左括号就入栈，出现右括号就和栈顶在map中映射的右括号比较，如果匹配就出栈，不匹配返回false，最后遍历完栈空为false</p><p>注意：go语言可以用byte代表单个字符</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/20.%e6%9c%89%e6%95%88%e7%9a%84%e6%8b%ac%e5%8f%b7.go>golang</a></p><h3 id=21合并两个有序链表高频>21.合并两个有序链表(高频)
<a class=anchor href=#21%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8%e9%ab%98%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/merge-two-sorted-lists>两个升序链表，合并成一个</a></p><p>题解：</p><ul><li>需要一个空的头节点做辅助，<code>head.Next</code>就是结果</li><li>每次遍历始终维护上一个节点<code>prev</code>，初始值<code>prev=head</code></li><li>循环遍历两个链表，循环条件都不为空，每次把当前节点更小的取出来即可</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>l1</span>
<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>l1</span>
<span style=color:#a6e22e>l1</span> = <span style=color:#a6e22e>l1</span>.<span style=color:#a6e22e>Next</span>
</code></pre></div><ul><li>最后加入有不为空的节点，则直接赋值</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>l1</span><span style=color:#f92672>!=</span><span style=color:#66d9ef>nil</span>{
    <span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>l1</span>
}<span style=color:#66d9ef>else</span>{
    <span style=color:#a6e22e>prev</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>l2</span>
}
</code></pre></div><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/21.%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8.go>golang</a></p><h3 id=53最大子序和高频>53.最大子序和(高频)
<a class=anchor href=#53%e6%9c%80%e5%a4%a7%e5%ad%90%e5%ba%8f%e5%92%8c%e9%ab%98%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/maximum-subarray>求和加起来最大的连续子数组</a></p><p>题解：</p><ul><li>一次循环，数组里有可能出现负数，且只需要统计和即可</li><li>需要两个计数器，一个存储全局最大的子序列和，只要出现更大的就更新</li><li>另一个存储当前最大的子序和，判断当前最大子序和的方法是比较子序和与当前值哪个大</li><li>有可能当前值比子序列和大，就更新子序 <code>max(nums[i],nums[i]+last)</code></li></ul><p>核心代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>last</span> = <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>],<span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>]<span style=color:#f92672>+</span><span style=color:#a6e22e>last</span>)
<span style=color:#a6e22e>resMax</span> = <span style=color:#a6e22e>max</span>(<span style=color:#a6e22e>resMax</span>,<span style=color:#a6e22e>last</span>)
</code></pre></div><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/53.%e6%9c%80%e5%a4%a7%e5%ad%90%e5%ba%8f%e5%92%8c.go>golang</a></p><h3 id=70爬楼梯>70.爬楼梯
<a class=anchor href=#70%e7%88%ac%e6%a5%bc%e6%a2%af>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/climbing-stairs/>一次可以上一阶或者二阶，如果是n阶有多少种爬法</a></p><p>题解：斐波那契数列，返回结果是前两个值的和，只需要保存前两个值和当前结果，递推赋值即可</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/70.%e7%88%ac%e6%a5%bc%e6%a2%af.go>golang</a></p><h3 id=101对称二叉树>101.对称二叉树
<a class=anchor href=#101%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/symmetric-tree/description/>二叉树是不是镜像的</a></p><p>题解：</p><ul><li>递归，相当于使用了前序遍历和后续遍历相等的性质</li><li>函数签名<code>isMirror(root,root)</code>，判断前序和后续相等</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Val</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>isMirror</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Left</span>,<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Right</span>) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>isMirror</span>(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Right</span>,<span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Left</span>)
</code></pre></div><ul><li>注意都为空时<code>true</code>，其中一个为空时<code>false</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>q</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>q</span><span style=color:#f92672>==</span><span style=color:#66d9ef>nil</span>{
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
}
</code></pre></div><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/101.%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91.go>golang</a></p><h3 id=104二叉树的最大深度>104.二叉树的最大深度
<a class=anchor href=#104%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/>根节点到最远叶子节点的最长路径上的节点数</a></p><p>题解：递归，前序遍历，返回值为左右节点最大深度+1，退出条件为null节点返回0，左右子树都为空返回1</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/104.%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6.go>golang</a></p><h3 id=121买卖股票的最佳时机高频>121.买卖股票的最佳时机(高频)
<a class=anchor href=#121%e4%b9%b0%e5%8d%96%e8%82%a1%e7%a5%a8%e7%9a%84%e6%9c%80%e4%bd%b3%e6%97%b6%e6%9c%ba%e9%ab%98%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/>给定整数数组表示每天股票价格，买一次卖一次求最大收益</a>，要求必须先买再卖</p><p>题解：与目前最小值做差，得到当前最大值，更新最大值，一次循环。核心代码如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span>&lt;<span style=color:#a6e22e>minNum</span>{
    <span style=color:#a6e22e>minNum</span> = <span style=color:#a6e22e>v</span>
}<span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>minNum</span> &gt; <span style=color:#a6e22e>maxNum</span>{
    <span style=color:#a6e22e>maxNum</span> = <span style=color:#a6e22e>v</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>minNum</span>
}
</code></pre></div><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/121.%e4%b9%b0%e5%8d%96%e8%82%a1%e7%a5%a8%e7%9a%84%e6%9c%80%e4%bd%b3%e6%97%b6%e6%9c%ba.go>golang</a></p><h3 id=136只出现一次的数字>136.只出现一次的数字
<a class=anchor href=#136%e5%8f%aa%e5%87%ba%e7%8e%b0%e4%b8%80%e6%ac%a1%e7%9a%84%e6%95%b0%e5%ad%97>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/single-number/description/>数组中某元素只出现一次，其余两次。找那个元素</a></p><p>题解：</p><ul><li>方法一、直接用map统计，超过一次就删掉</li><li>方法二、每个值都异或，最终得到的就是答案</li><li>异或的性质：<code>a^a=0, a^0=a</code></li></ul><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/136.%e5%8f%aa%e5%87%ba%e7%8e%b0%e4%b8%80%e6%ac%a1%e7%9a%84%e6%95%b0%e5%ad%97.go>golang</a></p><h3 id=141环形链表高频>141.环形链表(高频)
<a class=anchor href=#141%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8%e9%ab%98%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/linked-list-cycle/description/>判断链表中是否有环</a></p><p>题解：快慢指针，相等时退出，注意循环条件</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Next</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Next</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>q</span>.<span style=color:#a6e22e>Next</span>.<span style=color:#a6e22e>Next</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>
</code></pre></div><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/141.%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8.go>golang</a></p><h3 id=155最小栈中频>155.最小栈(中频)
<a class=anchor href=#155%e6%9c%80%e5%b0%8f%e6%a0%88%e4%b8%ad%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/min-stack/description/>设计一个栈，支持push、pop、top、getMin获取栈内最小值操作</a></p><p>题解：要自定义结构体，结构体内两个栈，一个存储push的元素的栈1，另一个存储最小值栈2，栈2有一个性质，每个栈2内元素位置为栈顶时，始终表示当前栈1最小的元素，比如</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>栈1 [1 2 3 4 0]
栈2 [1 1 1 1 0]
</code></pre></div><p>这样出栈同同步出栈，始终最小值就是栈2的栈顶，使用了一个当前最优解的思路</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/155.%e6%9c%80%e5%b0%8f%e6%a0%88.go>golang</a></p><h3 id=160相交链表高频>160.相交链表(高频)
<a class=anchor href=#160%e7%9b%b8%e4%ba%a4%e9%93%be%e8%a1%a8%e9%ab%98%e9%a2%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/>假定链表中没有循环，判断两个链表是否相交</a></p><p>题解：</p><p>法1（笨办法）</p><ul><li>双指针同步走，肯定有一个先结束，假如另一个指针所指到结束位置的距离就是长链表比短链表多出来的部分</li><li>长链表跑到和短链表等长，然后同步走，找出相等节点（地址相同非值相同）</li></ul><p>法2（最优）</p><ul><li>pA走过的路径为A链+B链, pB走过的路径为B链+A链</li><li>分别将另一个链表拼到尾部，相当于两个链表等长</li><li>pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>pA:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null-&gt;9-&gt;5-&gt;6-&gt;null
pB:9-&gt;5-&gt;6-&gt;null-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null
</code></pre></div><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/160.%e7%9b%b8%e4%ba%a4%e9%93%be%e8%a1%a8.go>golang</a></p><h3 id=169多数元素>169.多数元素
<a class=anchor href=#169%e5%a4%9a%e6%95%b0%e5%85%83%e7%b4%a0>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/majority-element/description/>数组中有一个数超过元素的一半，找出那个数</a></p><p>题解：</p><ul><li>最先想到的是hash表，更好的办法是投票</li><li>随便选个人当选，和它不同就反对，票数&ndash;</li><li>和他相同就赞成，票数++</li><li>票数为0则换届，最终票数肯定是正的，当选的肯定是众数，代码较短我直接贴上来了</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>majorityElement</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>count</span>,<span style=color:#a6e22e>num</span> <span style=color:#66d9ef>int</span>
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>,<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span>{
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>num</span>{
            <span style=color:#a6e22e>num</span> = <span style=color:#a6e22e>v</span>
            <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
        }<span style=color:#66d9ef>else</span>{
            <span style=color:#a6e22e>count</span><span style=color:#f92672>--</span>
        }
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>num</span>
}
</code></pre></div><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/169.%e5%a4%9a%e6%95%b0%e5%85%83%e7%b4%a0.go>golang</a></p><h3 id=206反转链表高频>206.反转链表(高频)
<a class=anchor href=#206%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8%e9%ab%98%e9%a2%91>#</a></h3><p>题目：</p><p>题解：</p><ul><li>其实是234. 回文链表 的一部分,就是在考基本功</li></ul><p>方法1、递归</p><ul><li>首先要确认递归返回链表头，所以退出条件：head为空直接退出，递归内部head.Next为空返回头节点</li><li>递归传入<code>head.Next</code>返回已经反转好的链表头</li><li>递归后动作，需要让最后的头节点指空，也就是<code>head.Next = nil</code>在指空前，需要让<code>head.Next.Next=head</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>1-&gt;2-&gt;null
1&lt;-2
nil&lt;-1&lt;-2
</code></pre></div><p>关键代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>newHead</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reverseList</span>(<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Next</span>)
<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Next</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>head</span>
<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#66d9ef>nil</span>
<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newHead</span>
</code></pre></div><p>方法2、非递归（最快，省空间）</p><ul><li>非递归两件套，<code>prev,curr = nil,head</code></li><li>每次保存下一个节点，让当前节点指向上一个节点</li><li>然后向下走一位,<code>prev=curr; curr=next</code>,<code>curr</code>为空时停止，<code>prev</code>就是新的头节点</li></ul><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/206.%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8.go>golang</a></p><h3 id=226翻转二叉树>226.翻转二叉树
<a class=anchor href=#226%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/invert-binary-tree/description/>翻转二叉树，每一层都要完全翻转</a></p><p>题解：</p><p>方法1 非递归 不推荐 较为麻烦，容易漏掉</p><ul><li>层遍历保存每层的状态，反着读出来每层就是翻转结果</li><li>但不能改变层遍历的过程，所以要两个栈，栈1保存层遍历，栈2保存该层的反向结果作为下次的<code>before</code>层</li><li>遍历栈2，左右节点指向倒着遍历栈1</li><li>要注意有可能出现部分空节点的情况，栈1，空位要留出来，所以要用nil来占位</li></ul><p>方法2 递归:其实子节点还是属于父节点，只要翻转左右节点位置就行了</p><p>自身递归，“交换”左右子树时记得备份。 代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/226.%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91.go>golang</a></p><h3 id=234回文链表>234.回文链表
<a class=anchor href=#234%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/palindrome-linked-list/description/>判断一个链表是否为回文链表</a></p><p>题解： 法1、最简单，直接遍历一次转换成数组，判断数组是否回文即可 法2、快慢指针（整除器）</p><ul><li><p>把剩下的一半变成逆序，再进行比较。注意奇偶情况讨论。递归非递归都行，想起来哪个用哪个，判断完后恢复链表</p></li><li><p>如果要快就边跑边让慢指针翻转链表，结束后也不用恢复</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/234.%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8.go>golang</a></p></li></ul><h3 id=283移动零>283.移动零
<a class=anchor href=#283%e7%a7%bb%e5%8a%a8%e9%9b%b6>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/move-zeroes/description/>把数组里的零全部移动到结尾</a></p><p>题解：两个下标，使用类似于选择插入排序的方法，不断扩充非零列，剩余的元素用0填充</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/283.%e7%a7%bb%e5%8a%a8%e9%9b%b6.go>golang</a></p><h3 id=448找到所有数组中消失的数字>448.找到所有数组中消失的数字
<a class=anchor href=#448%e6%89%be%e5%88%b0%e6%89%80%e6%9c%89%e6%95%b0%e7%bb%84%e4%b8%ad%e6%b6%88%e5%a4%b1%e7%9a%84%e6%95%b0%e5%ad%97>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/description/>1-n的数字存储在长度为n的数组里，有的数字重复出现了，所以有的数字没有出现，找出没有出现的数字</a></p><p>题解： 法1、直接用hash表，比较简单，不过建议还是用法2可以体现水平 法2、用占位方法，遍历，出现的abs(数字)-1作为下标的数字改为负，如果已经是负的就不用改了，最后再遍历一次数组把存储数字为正位置的(下标+1)存储到结果集里</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/448.%e6%89%be%e5%88%b0%e6%89%80%e6%9c%89%e6%95%b0%e7%bb%84%e4%b8%ad%e6%b6%88%e5%a4%b1%e7%9a%84%e6%95%b0%e5%ad%97.go>golang</a></p><h3 id=461汉明距离>461.汉明距离
<a class=anchor href=#461%e6%b1%89%e6%98%8e%e8%b7%9d%e7%a6%bb>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/hamming-distance/description/>求两个数字二进制位不同的有多少个</a></p><p>题解：先亦或，然后<code>%2=1</code>时统计，<code>>>1</code>代表<code>/2</code>去掉一位</p><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/461.%e6%b1%89%e6%98%8e%e8%b7%9d%e7%a6%bb.go>golang</a></p><h3 id=543二叉树的直径>543.二叉树的直径
<a class=anchor href=#543%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/diameter-of-binary-tree/description/>求两个叶子之间最大距离</a></p><p>题解：</p><ul><li>深度优先dps，必须用递归，递归返回的是左右子树最深深度</li><li>维护一个最大值，递归返回后判断左右子树贡献的深度和，与最大值哪个大，更新最大值，这样可以保证直径是当前最大 <code>max(x+y,maxRes)</code></li><li>返回当前子树最大深度<code>return max(x,y)+1</code></li></ul><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/543.%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84.go>golang</a></p><h3 id=617合并二叉树>617.合并二叉树
<a class=anchor href=#617%e5%90%88%e5%b9%b6%e4%ba%8c%e5%8f%89%e6%a0%91>#</a></h3><p>题目：
<a href=https://leetcode-cn.com/problems/merge-two-binary-trees/description/>合并二叉树，同位置都有值就加起来，有一个为空就只合并</a></p><p>题解：</p><ul><li>递归，返回条件：其中一个为空返回另一个节点</li><li>如果两个都不为空，加起来</li><li>处理递归函数，分别传入两棵树的左子树或右子树，赋值给当前节点左右子树</li><li>跟437 路径总和III的思想是一样的。</li></ul><p>代码：
<a href=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/all/617.%e5%90%88%e5%b9%b6%e4%ba%8c%e5%8f%89%e6%a0%91.go>golang</a></p><h2 id=最后>最后
<a class=anchor href=#%e6%9c%80%e5%90%8e>#</a></h2><p>如果文中有误，欢迎提pr或者issue，<strong>一旦合并或采纳作为贡献奖励可以联系我直接无门槛</strong>加入
<a href=https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q>技术交流群</a></p><p>我是小熊，关注我，知道更多不知道的技术</p><p><img src=https://github.com/minibear2333/interview-leetcode/tree/f218b102b41d5ce6b95e9b305fdc326205b4e2f9/LeetCode/hot100/res/2021-03-17-19-57-33.png alt></p></article><div class="book-footer justify-between"></div><hr style=height:1px;background:var(--gray-200)><br><p>本图书由<a href=https://github.com/minibear2333>小熊</a>©2021 版权所有，<a href=https://golang.coding3min.com/>所有文章</a>采用<a href=https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh>知识署名-非商业性使用-禁止演绎 4.0 国际</a>进行许可。</p><div style=text-align:center><p><img width=70% style=width:70%;height:70%;!important src=https://coding3min.oss-accelerate.aliyuncs.com/2021/06/24/qrcode.png></p></div><script src=https://utteranc.es/client.js repo=minibear2333/blog-comment issue-term=title theme=github-light crossorigin=anonymous async></script><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/coding3min/interview-leetcode/edit/master/content/LeetCode/easy.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#题解>题解</a><ul><li><a href=#1两数之和高频>1.两数之和(高频)</a></li><li><a href=#20有效的括号高频>20.有效的括号(高频)</a></li><li><a href=#21合并两个有序链表高频>21.合并两个有序链表(高频)</a></li><li><a href=#53最大子序和高频>53.最大子序和(高频)</a></li><li><a href=#70爬楼梯>70.爬楼梯</a></li><li><a href=#101对称二叉树>101.对称二叉树</a></li><li><a href=#104二叉树的最大深度>104.二叉树的最大深度</a></li><li><a href=#121买卖股票的最佳时机高频>121.买卖股票的最佳时机(高频)</a></li><li><a href=#136只出现一次的数字>136.只出现一次的数字</a></li><li><a href=#141环形链表高频>141.环形链表(高频)</a></li><li><a href=#155最小栈中频>155.最小栈(中频)</a></li><li><a href=#160相交链表高频>160.相交链表(高频)</a></li><li><a href=#169多数元素>169.多数元素</a></li><li><a href=#206反转链表高频>206.反转链表(高频)</a></li><li><a href=#226翻转二叉树>226.翻转二叉树</a></li><li><a href=#234回文链表>234.回文链表</a></li><li><a href=#283移动零>283.移动零</a></li><li><a href=#448找到所有数组中消失的数字>448.找到所有数组中消失的数字</a></li><li><a href=#461汉明距离>461.汉明距离</a></li><li><a href=#543二叉树的直径>543.二叉树的直径</a></li><li><a href=#617合并二叉树>617.合并二叉树</a></li></ul></li><li><a href=#最后>最后</a></li></ul></nav></div></aside></main></body></html>