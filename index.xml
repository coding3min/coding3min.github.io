<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>程序员的魔法书</title><link>https://leetcode.coding3min.com/</link><description>Recent content on 程序员的魔法书</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://leetcode.coding3min.com/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://leetcode.coding3min.com/blog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/blog/</guid><description>编程伐木累成员博客 # 网站 GitHub 优秀开源项目 微信公众号 说明 机智的程序员小熊 minibear2333 go语言精进之路 机智的程序员小熊 涉及各种后端语言、OpenStack、DevOps、容器等，还有一些思考 老衲的博客 yann的小站 运维、go语言 好博客推荐 # 网站 说明 酷壳 左耳朵耗子的博客，无所谓技术，里面一些思考见解也是值得一看的，我没事就会看看 Jack Cui 剑指Offer全集题解，机器学习领域，建站文章写的比较全 wego 一个线上go语言组织内容很丰富 星光博客 wordpress建站比较6、其他文章没什么意思</description></item><item><title/><link>https://leetcode.coding3min.com/contribute/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/contribute/</guid><description>如何贡献 #</description></item><item><title/><link>https://leetcode.coding3min.com/interview/cao-zuo-xi-tong/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/cao-zuo-xi-tong/</guid><description>操作系统 # 并发和并行的理解？ # 并发：在一个时间段中多个程序都启动运行在同一个处理机中，比如线程 并行：假设目前A，B两个进程，两个进程分别由不同的 CPU 管理执行，两个进程不抢占 CPU 资源且可以同时运行，这叫做并行。单核CPU是伪并行 线程与进程的优缺点 # 多线程的优点：
更加高效的内存共享。多进程下内存共享不便； 较轻的上下文切换。因为不用切换地址空间，CR3寄存器和清空TLB。 多进程的优点：
各个进程有自己内存空间，所以具有更强的容错性，不至于一个集成crash导致系统崩溃 具有更好的伸缩性，因为进程将地址空间，页表等进行了隔离，可以在不同的服务器上进行水平伸缩 如何提升多线程的效率？ # 答者：彬
使用线程池，减少线程的创建销毁带来的开销 根据不同的线程类型确定线程数量，例如cpu繁琐的，核线比1:2，I/O繁琐的1:1 压测，看具体项目能吃多少线程 在线程数无法减少的情况下，根据物理内存调整jvm堆大小，为线程提供足够内存空间 升级物理机的cpu和内存 单台机极限的情况下，使用集群 最基本的，优化代码，减低复杂度 小熊补充
尽量使用线程池，从而不用频繁的创建，销毁线程； 减少线程之间的同步和通信； 通过Huge Page的方式避免产生大量的缺页异常； 避免需要频繁共享写的数据。 进程的三个状态 # 就绪 —&amp;gt; 执行：准备就绪，调度器满足了的需求 执行 —&amp;gt; 阻塞：正在执行的进程由于发生某事件（例如请求I/O而等待I/O完成等）而暂时无法继续执行时，便放弃处理机而处于暂停状态，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 阻塞 —&amp;gt; 就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态； 执行 —&amp;gt; 就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中, 当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。 进程与线程有什么区别？ # 进程是资源分配的最小单位，线程是进程的一个实体，也是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，有时又被称为轻量级进程。 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销； 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的； 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉； 所以</description></item><item><title/><link>https://leetcode.coding3min.com/interview/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/docker/</guid><description>Docker # 介绍docker # docker是go开发的，基于Apache2.0协议开源，可以把应用和他的依赖打包到一个轻量级、方便移植的系统中，主要解决的问题是快速发布、自动化构建、统一测试成功的环境和线上环境
docker分为镜像、容器、仓库，打包好的叫镜像，存储镜像的地方叫仓库，镜像运行起来叫容器
容器也可以理解成进程，只不过做了隔离和资源限制，方便管理，对于容器内部的进程来说就好像是一个独立的操作系统
因为镜像小，方便创建和效果所以伸缩、管理、部署起来更为容易
隔离是怎么做的? # 用namespace做的
资源限制是怎么做的？ # 用cgroup做的，对cpu和内存做了限制
听过镜像分层吗？ # 按层构建，基于一个基础层添加新层，前一层是后一层的基础，构建完就变成只读的了，每一层都意味着不同的操作指令，比如初始化环境、程序入口等
docker网络模式 # Docker使用Linux的Namespaces技术来进行资源隔离
container模式：和一个已经存在的容器共享Network namespace，不创建自己的网卡，也不配置自己的ip，共享同一个ip和共享的端口范围，但文件系统和进程列表还是隔离的，同样是用到veth设置拉到docker0上，docker0是默认网关，转发到宿主机上 host模式：和主机共享网络，但文件系统和进程列表还是隔离的，容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口 none模式：Docker容器拥有自己的Network Namespace，但不为Docker容器进行任何网络配置，没有网卡、IP、路由等信息 bridge模式：默认模式，在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。 从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。在主机上创建一对虚拟网卡 veth pair 设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0 （容器的网卡），另一端放在主机中，以 vethxxx 这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。可以通过 brctl show 命令查看。 选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用</description></item><item><title/><link>https://leetcode.coding3min.com/interview/go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/go/</guid><description>Go # 基本数据类型 # goroutine # 框架 # gin # 线程和协程，有什么区别，为什么协程可以创建很多 # 答者：记事本
线程由系统调度，协程由运行时调度
而为什么协程可以做到同时创建上万个，是因为go的协程初始化资源是4KB空间，比线程轻量级
网上：
区别在于
一个线程可以多个协程，一个进程也可以单独拥有多个协程。 线程进程都是同步机制，而协程则是异步。 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：
协程的好处：
无需线程上下文切换的开销 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型 缺点：
无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序 最佳实践
线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 go协程的GMP理论 # 首先协程和线程是多对多的关系，一般是多对一，只要不涉及多线程就不涉及抢占和线程上下文切换
G指goroutine M thread(machine)、P(Processor处理器)
在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。 全局队列（Global Queue）：存放等待运行的 G。 P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。 P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。 M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。 一句话：协程创建先放入P的队列，放满了把一半放G的全局队列，M顺序取P来运行，如果M没有取到（P为空）移动全局队列到P中，或者去其他P上取，所以M有调度的作用</description></item><item><title/><link>https://leetcode.coding3min.com/interview/java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/java/</guid><description>Java # 基本数据类型 # 整型：byte(8)、short(16)、int(32)、long(64) 浮点型：float(32)、double(64) 布尔型：boolean(8) 字符型：char(16) 只能向上转型 += 或者 ++ 运算符会执行隐式类型转换 异常处理 # 三种类型的异常 # **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 关键字 # try/catch：捕获异常，catch可以多重捕获（直到异常被捕获或者通过所有的 catch 块） throws/throw：方法使用 throws 关键字来声明（一个方法没有捕获到一个检查性异常），throw 关键字抛出一个异常 finally：在 try 代码块后面执行的代码块 自定义异常 # 所有异常都必须是 Throwable 的子类。 自定义检查性异常类，需要继承 Exception 类。 自定义运行时异常类，那么需要继承 RuntimeException 类。 hashMap # 底层数据结构，JDK 1.8 是数组 + 链表 + 红黑树，JDK 1.</description></item><item><title/><link>https://leetcode.coding3min.com/interview/k8s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/k8s/</guid><description>k8s # 核心组件 # 主节点（Master）：kube-controller-manager，kube-apiserver，kube-scheduler 工作节点（Node）：kubelet和kube-proxy 只有apiserver使用etcd k8s的架构和组件是哪些，有哪些资源(api)类型？ # Kubernetes主要由以下几个核心组件组成：
etcd保存了整个集群的状态； apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制； controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等； scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上； kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理； Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）； kube-proxy负责为Service提供cluster内部的服务发现和负载均衡； 除了核心组件，还有一些推荐的Add-ons：
kube-dns负责为整个集群提供DNS服务 Ingress Controller为服务提供外网入口 Heapster提供资源监控 Dashboard提供GUI Federation提供跨可用区的集群 Fluentd-elasticsearch提供集群日志采集、存储与查询 资源类型:
类别 名称 资源对象 Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition 存储对象 Volume、PersistentVolume、Secret、ConfigMap 策略对象 SecurityContext、ResourceQuota、LimitRange 身份对象 ServiceAccount、Role、ClusterRole 哪些组件和etcd打交道？ # etcd 保存了整个集群的状态，所以和操作资源相关的都要读写 etcd
注意：只有apiserver使用etcd，其他组件都是通过apiserver和etcd打交道</description></item><item><title/><link>https://leetcode.coding3min.com/interview/linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/linux/</guid><description>Linux # VIM 三个模式 # 一般指令模式（默认模式） 编辑模式 指令列模式 文件属性 # 用户分为三种 文件拥有者 群组 其它人 文件类型 d：目录 -：文件 l：链接文件 文件权限： 三位一组 对文件拥有者、所属群组以及其它人的文件权限 3 位分别为 r、w、x 权限，表示可读、可写、可执行 文件时间 modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 修改权限 chmod 左到右每个位的权值为 4、2、1 默认权限 文件默认权限666 目录默认权限777 链接 # 实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 符号链接：文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式 ln创建链接：默认是实体链接，加 -s 为符号链接 获取文件内容 # cat、tac(从最后一行打印) more（一页一页打印）、less（增加向前翻页） head（前n行）、tail（后几行） 数据流重定向 # 一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向 输出重定向到 /dev/null（扔进垃圾箱） 排序指令（sort） # $ sort [-fbMnrtuk] [file or stdin] -f ：忽略大小写 -b ：忽略最前面的空格 -M ：以月份的名字来排序，例如 JAN，DEC -n ：使用数字 -r ：反向排序 -u ：相当于 unique，重复的内容只出现一次 -t ：分隔符，默认为 tab -k ：指定排序的区间 $ uniq [-ic](可以将重复的数据只取一个) -i ：忽略大小写 -c ：进行计数 正则表达式(grep) # $ grep [-acinv] [--color=auto] 搜寻字符串 filename -c ： 统计匹配到行的个数 -i ： 忽略大小写 -n ： 输出行号 -v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto ：找到的关键字加颜色显示 查看进程 # ps -l 查看自己的进程 ps aux 查看系统所有进程 pstree 查看进程数 查看子进程的命令 # 这里的 722 是指进程 pid</description></item><item><title/><link>https://leetcode.coding3min.com/interview/mongodb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/mongodb/</guid><description>TODO-mongoDB # 请移步 面试高频问题-待解答</description></item><item><title/><link>https://leetcode.coding3min.com/interview/mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/mysql/</guid><description>Mysql # 数据类型 # 整型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间 浮点数：FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型 字符串： CHAR（定长） 和 VARCHAR（变长的） 时间日期：date、datetime、timestamp（比DATETIME 空间效率更高） 存储引擎：myisam和innodb的区别是什么 # 答者：狸追
innodb 支持事务和外键，最小锁粒度是行级锁，myisam 不支持事务和外键，最小锁粒度是表级锁，间歇锁 innodb 的索引如果是聚簇索引，叶子节点上保存的是数据和索引，非聚簇索引，节点上保存的是id，而myisam保存的是数据的地址（相当于一个指针） myisam 的表可以没有索引，innodb一定要有索引 myisam 会保存总行数，innodb是全表扫描 总结：对于大量更新、插入、删除，innodb性能上更好，因为他具备的事务、行级锁、B+树等特点，更安全，因为回滚和崩溃恢复更适合大型应用 经过测试在单进程读的情况下myisam执行速度比innodb更快，但是多进程读的时候就失去优势了 mysql5.5版本之后默认innodb 展开说
MyISAM： 拥有较高的插入，查询速度 不支持事务 支持表级锁 不支持MVCC 不支持外键 支持全文索引 内部维护了一个计数器，selectcount更快 InnoDB ：插入缓冲（insert buffer)、二次写(double write)、自适应哈希索引(ahi)、预读(read ahead) 5.5版本后Mysql的默认数据库 支持ACID事务 支持行级锁定 支持MVCC 支持外键 不支持全文索引 不建议使用过长的字段作为主键：因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。 不建议用非单调的字段作为主键：因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 特殊的功能“自适应哈希索引”：当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引（B+Tree 索引具有哈希索引的一些优点） 主从复制 # 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中 从：sql执行线程——执行relay log中的语句 索引类型 # 普通索引 唯一索引：索引列的值必须唯一，但允许有空值 主键索引：特殊的唯一索引，一个表只能有一个主键，不允许有空值 组合索引：在查询条件中使用了创建索引时的第一个字段，索引才会被使用。遵循最左前缀集合 全文索引：主要用来查找文本中的关键字（MATCH AGAINST） Mysql8新特性降序索引 聚集索引（主键索引）和非聚集索引 # 索引按照数据结构来说主要包含B+树和Hash索引。</description></item><item><title/><link>https://leetcode.coding3min.com/interview/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/network/</guid><description>网络 # 计算机网络网络 # IP协议：一种分组交换传输协议； TCP协议：一种面向连接，可靠传输的协议； UDP协议：一种无连接，不可靠传输的协议。 操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序 一个Socket由IP地址和端口号 小于1024的端口属于_特权端口_，需要管理员权限 使用Socket进行网络编程时，本质上就是两个进程之间的网络通信 服务器端的Socket是指定的IP地址和指定的端口号；客户端的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号 三次握手 TCP客户端最后还要发送一次确认的原因：主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误 四次挥手 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 underlay就是底层承载网，overlay就是基于底层网络互联互通的基础加上隧道技术去构建一个虚拟的网络。overlay的核心其实就是打隧道（tunnel） http 中的 4层与7层分别代表什么，中间那三层是为了满足什么样的需求呢？ # 提问：小雨
答者：海翔
一个ISO7层模型，一个是web四层模型，不是一个东西 7层模型分物理层，数据链路层，网络层，传输层，会话层，表示层，应用层 4层模型是TCP/IP协议的定义，数据链路层对应7层模型的物理层+数据链路层，网络层对应7层模型的网络层，传输层对应7层模型的传输层，应用层对应7层模型的会话层+表示层+应用层 TCP # TCP 三次握手、四次挥手（重点） # 三次握手：1.</description></item><item><title/><link>https://leetcode.coding3min.com/interview/qian-duan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/qian-duan/</guid><description>TODO-前端 # 请移步 面试高频问题-待解答</description></item><item><title/><link>https://leetcode.coding3min.com/interview/queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/queue/</guid><description>消息队列 # 如何保证队列数据一致性，防止重复消费，幂等性 # 所有的消息中间件在实际的业务场景中都逃脱不了保证消息的一致性的问题
kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，可以理解成一个自增持的序号，一个个排下来
然后消费者consumer，每隔一段时间，就把自己消费过的消息提交一下，如果说出现宕机或者重启，则会继续从上次消费的序号接着往下排，继续消费
但是有的时候，消费者consumer消费的消息，由于各种原因，比如网络、宕机、停电。。。都没来得及写offset,这个时候少数消息会再次消费一次
这个时候，我们可以用一个唯一的id标识来区分，这不是消息中间件做的事，而是开发者要做的，比如你消费一个就往数据库插入一条记录，然后下次再去消费的时候，你去查一下，看看这个消息是否被消费了，消费了那就不要重复消费了。
（补充一下：确认一条数据在百万级别海量数据里是否存在？&amp;ndash;可以用布隆过滤器）
根据主键查一下，如果这数据都有了，就别插入了，update一下（虽然重复插入会因为唯一键约束而报错，我觉得我们还是应该避免报错） 如果是写redis，反正每次都是set，天然幂等性 如果不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，就别处理了，保证别重复处理相同的消息即可。 引用:
rabbitMq-kafka消息高可用，一致性 如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性 如何预防rabbitmq消息的丢失 # 情况1、生产者自己丢失了消息(网络故障/发送失败)
解决方案：
rabbitmq：一般这种都是采用回调接口的方案（confirm模式），就是说你扔一个消息过去了，对方给你一个回调接口，告诉你成功了或者失败了，失败了你可以选择继续扔消息， (重试机制等)，来保证消息一定送达
开启confirm模式（异步的）之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
引用： 如何保证消息队列的高可用和幂等性以及数据丢失，顺序一致性
情况2、消息中间件弄丢了消息
解决方案：以rabbitmq来说，开启持久化就好了，当发生宕机的时候，queue会自动从磁盘恢复数据，除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小
情况3、消费者弄丢了消息
rabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，rabbitmq认为你都消费了，这数据就丢了。
关闭rabbitmq自动ack机制，可以通过一个api来调用，每次代码里确保处理完的时候，再程序里ack。这样的话，如果还没处理完，就没有ack，那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的
如何预防kafak消息丢失 # TODO
如何处理消息积压 # 出现场景：消费能力被阻塞（消费者挂掉或者处理速度慢），生产者还不停的往队列里扔消息
解决方法：
快速恢复consumer服务，慢慢消费，如果积压的数据量太大的话恢复较慢 临时写脚本快速的把这批消息给消费掉，或者增加消费者数量/消费速度，要避免负载把其他服务打挂 扩容：提高相同消息的队列数量，出现问题时写脚本分发到不同队列里，再给每个队列指定消费者，消费结束后再恢复 预防：
提前准备多个队列在投递时随机投递，存储同类型无顺序要求的消息 使用多个消费者 消息过期或者队列满了怎么办 # 消息队列TTL超时或者队列满了数据会丢失，这个时候可以自己再去找消息，然后临时写个代码，自己再手动的去把这些消息重新推送到队列里去。
另一种解决方案
可以在 rabbitmq 中声明死信队列，死信队列为处理过期或不能正确路由的消息提供了驻留场所，可以防止消息丢失，便于分析无法消费的原因 写程序处理死信队列里的数据，并接入告警分析 如果投递不成功，需要把数据暂存内存或者暂存redis之类的数据库中，等待恢复时重试</description></item><item><title/><link>https://leetcode.coding3min.com/interview/redis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/redis/</guid><description>Redis # 数据类型 # 键的类型只能为字符串 值支持五种数据类型： 字符串： set &amp;lt;key&amp;gt; &amp;lt;value&amp;gt; get &amp;lt;key&amp;gt; del &amp;lt;key&amp;gt; 列表 rpush &amp;lt;key&amp;gt; &amp;lt;item&amp;gt; lrange &amp;lt;key&amp;gt; i j（j可填-1） rindex &amp;lt;key&amp;gt; i lpop &amp;lt;key&amp;gt; 无序集合 sadd &amp;lt;key&amp;gt; &amp;lt;item&amp;gt; smembers &amp;lt;key&amp;gt; sismember &amp;lt;key&amp;gt; &amp;lt;item&amp;gt; srem &amp;lt;key&amp;gt; &amp;lt;item&amp;gt; 散列表 hset &amp;lt;key&amp;gt; &amp;lt;sub_key&amp;gt; &amp;lt;value&amp;gt; hgetall &amp;lt;key&amp;gt;（每条数据sub_key和value各占一行） hdel &amp;lt;key&amp;gt; &amp;lt;sub_key&amp;gt; 有序集合 zadd &amp;lt;key&amp;gt; &amp;lt;score&amp;gt; &amp;lt;item&amp;gt; zrange &amp;lt;key&amp;gt; i j withscores zrangebyscore &amp;lt;key&amp;gt; &amp;lt;score1&amp;gt; &amp;lt;score2&amp;gt; withscores zrem &amp;lt;key&amp;gt; &amp;lt;item&amp;gt; zset(sort list) 的数据结构是什么？ # zset 有序且唯一，在跳表以空间换时间 以冗余的链表换取效率</description></item><item><title/><link>https://leetcode.coding3min.com/interview/xiang-mu-wen-shi-mo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/interview/xiang-mu-wen-shi-mo/</guid><description>项目一般问什么 # 项目问题因人而异，但是这些问题是共性的，可以思考一下 # 你最有成就感，或者最有挑战的项目经过，解决什么样的问题 数据量很大还是并发量很高，并发量体现在哪里？QPS是多少？ 怎么提高可用性的？ 技术难点体现在哪里？ 你的项目有没有出现什么重大事故/故障，是怎么解决的，具体是什么原因 有没有什么印象深刻的Bug 分布式锁如何实现 # 分布式锁，一般为了达到分布式加锁需要通过投票的机制，依次向所有节点申请加锁，半数以上节点投票通过完成加锁，可以避免单点故障（Redis称为Redlock算法）
加锁的动作需要保证原子性，Redis通过Lua脚本来保证 谁加的锁谁来释放锁，所以需要标记锁来源 预防加锁程序挂掉导致的锁不释放，所以需要设置过期时间 加锁成功需要判断获取锁总耗时没有超过锁有效时间，这才判定为加锁成功 注意：假如程序处理速度比锁过期时间要长，是不合理的设计，超时时间的设置就很精细，一般都是远大于处理的时间，如果真的处理时间太长应该判定失败并告警
见 redis
如何实现一个分布式id生成器 # 首先要知道自增主键出现的问题
在高并发的情况下加入事务执行失败回滚，会跳过当前插入ID，使ID不连续 所有数据库中的自增字段或者自增序列都要记录日志，会产生磁盘IO，会成为性能瓶颈 假如数据库使用的是Range分片，自增ID可能会集中写入集群中的一个节点，出现数据访问热地世，性能退化成单机写入 解决方案
随机主键UUID方案（32 个的 16 进制数字，16^32 = 2^128 就是128位），虽然可以保证每次随机都不一样，但缺点是键值长度过长，存储和计算的代价增加，uuid只能保证不重复，但数据页可能会分裂，影响查询性能 号段模式，每个业务批量获取数据库中的号段，比如一次获取1000个，然后内存生成1000个自增ID，使用完再获取1000个；只需要插入一条记录，步长设置为1000，注意使用乐观锁（维护版本号），记录字段有业务类型、当前最大可用id、号段步长，version号；缺点服务重启时重新申请号段，不够随机有被猜到的风险 在TiDB 里提供了一种AutoRandom的算法，生成64位整型随机ID，1bit符号位、5bit事务开始时间，58bit自增序列号，还是有可能出现尾部热点 雪花算法Snowflake，时间戳精确到毫秒，10位长度机器码最大规模1024个节点(2^10), 12位序列代表1毫秒能产生的id数量最多4096个。所以 TPS 可以达到 419 万左右（2^22*1000）, 每秒那么多大多系统都够了 注意雪花算法，对时间的要求比较高，如果时间不同步，时钟回拨时 ID 有可能出现重复
引用： 分布式数据库30讲
如何优化雪花算法的问题 # 雪花算法的问题主要在于时间回拨出现id重复、机器id有上限
时钟回拨就是本机时间略快，完成时间服务器的校准（NTP或者闰秒回拨）以后，会出现时间倒退，导致生成ID重复
时钟回拨解决办法：
继续在当前ID序列号最大基础上增加，方案来自 snowflake算法的时钟回拨问题如何解决 如果时间偏差比较小，&amp;lt;=5ms 可以等待2倍时间，牺牲很短时间的可用性，方案来自 SnowFlakeID原理和改进优化 时间回拨跨度太大时告警，并摘除本身节点，只会影响一个节点 也可以考虑直接关闭时间同步 机器id有上限的解决办法（雪花算法优化）</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode-vscode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode-vscode/</guid><description>协作办法 # 下载插件 # 直接在vscode中搜索 LeetCode 插件完成下载，并登陆账号，修改配置如下
找到修改配置位置 # 改为中国区 # 修改默认语言 # 修改文件夹目录 # 修改插件配置，设置文件夹目录为 LeetCode/all ，这样才会自动创建go文件在此
&amp;#34;leetcode.filePath&amp;#34;: { &amp;#34;default&amp;#34;: { &amp;#34;folder&amp;#34;: &amp;#34;LeetCode/all&amp;#34;, &amp;#34;filename&amp;#34;: &amp;#34;${id}.${kebab-case-name}.${ext}&amp;#34; } } 修改工作目录 # 如果不是直接打开的需要修改工作目录
最后 # 如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/all/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/all/readme/</guid><description>请使用 vscode 中的 LeetCode 插件，自动创建文件、手动提交测试</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/difficult/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/difficult/</guid><description>LeetCode-hot100-difficult # 介绍 # 一句话总结算法思路，LeetCode hot100 difficult
按频率排序，排序依据参考 字节跳动后端高频面试题目。
全部源码可见我的GitHub interview-leetcode
注：
有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。
题解 # 42.接雨水 # 题目： 接雨水，给定整数数组，把他想象成柱状图，凹槽部分接雨水总合
题解：用栈的思路比较难理解，我写在代码里了，有兴趣可以自己看看，这里推荐双指针的思路
双指针下标l和r指向0和len-1，记录左侧最大值height[0]和右侧最大值height[len-1] 判断左侧和右侧最大值哪个更小，更小侧向内测移动，比如 if lMax&amp;lt;rMax then l++ 如果当前指针位置比lMax要小，又因为此时rMax&amp;gt;lMax说明此处一定会出现低洼，它被两侧包住了，一定不会渗水；水的高度是由更小的最大值决定，现在是lMax 统计水量res += lMax - height[l]，如果当前指针比lMax大，说明左侧包不住，更新左侧最大值 上面1、2、3步骤的动作else 反过来，r--; if height[r]&amp;lt;rMax then res+= rMax-height[r] else rMax = height[r] 循环条件l&amp;lt;r,函数至少要3个值才有可能形成低洼，所以边界是len&amp;lt;3 return 0 代码： golang
题目：
题解：</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/easy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/easy/</guid><description>LeetCode-hot100-easy # 介绍 # 一句话总结算法思路，LeetCode hot100 easy
总计21题，题目列表请戳 LeetCode Hot100 easy 列表。
全部源码可见我的GitHub interview-leetcode
注：
有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。
题解 # 1.两数之和(高频) # 题目： 数据中是否有两个数之和为目标值
题解：遍历数组，用目标值减去当前值，判断HashMap是否有值存在，如果有则创建新数组返回两者，如果没有循环遍历完返回空数组
时间复杂度：O(1) 代码： golang
20.有效的括号(高频) # 题目： 存在[]{})(的字符串，判断是否合法
题解： 存储左括号和右括号的映射，用栈统计左括号，出现左括号就入栈，出现右括号就和栈顶在map中映射的右括号比较，如果匹配就出栈，不匹配返回false，最后遍历完栈空为false
注意：go语言可以用byte代表单个字符
代码： golang
21.合并两个有序链表(高频) # 题目： 两个升序链表，合并成一个
题解：
需要一个空的头节点做辅助，head.Next就是结果 每次遍历始终维护上一个节点prev，初始值prev=head 循环遍历两个链表，循环条件都不为空，每次把当前节点更小的取出来即可 prev.Next = l1 prev = l1 l1 = l1.Next 最后加入有不为空的节点，则直接赋值 if l1!=nil{ prev.Next = l1 }else{ prev.</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/hot100/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/hot100/readme/</guid><description>介绍 # 题目列表请戳 LeetCode-Hot100列表
算法 LeetCode Hot 100 思路与代码，请点击相应目录查看
最后 # 如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/hua-wei-ji-shi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/hua-wei-ji-shi/</guid><description>华为机试 # 字符串余 # 输入若干字符串和一个数字n，按8切分字符串，长度不足补0
示例：
输入：asdf 123456789 输出：asdf0000 12345678 90000000 func splitStr(str string,n int){ zeroStr := &amp;#34;00000000&amp;#34; for len(str)&amp;gt;8{ fmt.Println(str[:8]) str = str[8:] } fmt.Println(str+zeroStr[:8-len(str)]) } 货币汇率兑换算法 # 知道各货币兑换另一种货币的汇率，要求求最大兑换和最小可兑换货币
USD - RMB 1:6 RMB - HKD 1:2 HKD - JAN 1:20
示例：
输入HKD = 65 最大可兑换 USD=10,RMB=5 最小可兑换 JAN=2600 函数
// 顺序输入UDB RMB HKD 汇率，比如上面的例子，输入[6 2 20] // moneyType = 0 1 2 3 对应 USD RMB HKD JAN，money对应货币数量 // isMax = true 时求最大可兑换 false 时求最小可兑换 // 返回兑换情况，最大[5,2,1,0]，最小[0,0,0,1300] func xxx(rate []int,moneyType int,money int,isMax bool) []int{ } 解法,代码见 货币汇率兑换算法.</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/medium/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/medium/</guid><description>LeetCode-hot100-medium # 介绍 # 一句话总结算法思路，LeetCode hot100 medium
按频率排序，排序依据参考 字节跳动后端高频面试题目。
全部源码可见我的GitHub interview-leetcode
注：
有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。
3.无重复字符的最长子串 # 题目： 在字符串中找一个子串，要求连续无重复字符且最长，只需要返回最大长度
题解：
字符串长度为0直接返回 记录最大子串的长度，用来和新子串长度比较，维护子串的状态还需要记录当前子串的起始位置的下标 使用map来储存字符对应的下标， 只要当前字符出现在map里，同时map里的字符就是子串里的字符时（存储的字符下标大于等于起始位置下标）说明重复，更新子串起始位置为map中记录的重复点+1 else (没有出现在子串里)，子串长度++，判断更新最大长度(注意更新时+1) 代码： golang
215.数组中的第k个最大元素 # 题目： 数组中的第k个最大元素
题解： 方法1，堆排序（不推荐）
求第K大的数，实际上就是取小根堆的根节点 小根堆的性质，根节点比所有叶子节点更小 注意：这里为什么用堆，是因为堆是一个完全二叉树，而二叉搜索树不自平衡，而且堆的话小根堆直接取根节点就是结果了
方法2 快速排序变形（快速选择算法）
其实就是快排的思路，只是做了下剪枝 只要保证len-k这个位置右侧全部比k大，左侧全部小于等于k，那么len-k位置的数就是第k大 因为我们不知道是哪个数，所以随便取一个数x，最终达到左侧全部&amp;lt;=x，右侧全部&amp;gt;x的效果 把x的下标index和len-k比较，如果小，说明第k大数一定在[index+1,r]；如果大说明第k大数一定在[l,index-1]中 缩小区间，继续随便取一个数，直到正好x的下标就是len-k为止 查找中枢的办法借助快排的思路
随机取一个数x，把他和r位置的数对调 维护左侧区间都比x小，所以初始化i为l-1 变量j遍历[l,r) 左闭右开区间，大于x无操作 小于x时候,i++，然后对调i和j位置的数字，这样又可以保证i左侧包括i位置的数都小于x 遍历结束以后i+1位置的数正好是最后一个比i大的数，把他和r对调 返回i+1，也就是中枢位置的下标 时间复杂度：运气好就是一次就找到了On运气不好每个数都找了一次ON^2，算法导论中把每次查找都使用一个随机数，可以显著提高效率，趋近于On，具体为什么可以自己去看
为什么推荐用快选，因为空间O1，时间On~On^2比堆的时间Onlogn和Ologk更快，但是快排也有局限性
快选需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。 堆只需要保存 k 个元素的小根堆。快速排序变形的方法如果不允许修改原数组那就要保存下来所有的数据，所以数据量大时用堆更好 引用： 优劣比较</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/other/</guid><description>其他高频算法 # 其他高频 # medium # 120.三角形最小路径和 # 题目： 求三角形的最小路径和
要求是每一步只能找下一行的相邻节点，也就是当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 题解：从三角形底部向上遍历
[ [2], [3,4], [6,5,7], [4,1,8,3] ] 相邻结点：与(i, j) 点相邻的结点为 (i + 1, j) 和 (i + 1, j + 1)。 用一个一维度数组dp [n+1]int来存储最终结果，保证每个值都是最优解 方程 min(dp[j],dp[j+1]) + triangle[i][j] 注意：</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/readme/</guid><description>面试算法 # 介绍 # 这里是所有的算法题目，建议先刷hot100再刷剑指Offer
请直接点击相应目录查看
最后 # 如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/shu-ju-jie-gou/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/shu-ju-jie-gou/</guid><description>数据结构 # 树 # 基本概念 # 树有多个节点(node)，用以储存元素 节点之间的连线称为边(edge) 边的上端节点称为父节点 下端称为子节点 树的深度(depth)是从根节点开始（其深度为1）自顶向下逐层累加的 高度的定义为：从结点x向下到某个叶结点最长简单路径中边的条数 深度是从根节点往下 二叉树 # 常见的二叉树：完全二叉树，满二叉树，二叉搜索树，二叉堆，AVL 树，红黑树，哈夫曼树
完全二叉树：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边（效率高） 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树 二叉搜索树（二叉排序树，二叉查找树） 树中每个节点最多有两个子树，通常称为左子树和右子树 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 它的左右子树仍然是一棵二叉搜索树 (recursive) 平衡树(B树) 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则； 子节点数：1&amp;lt;非叶节点的子节点数&amp;lt;=M ，且M&amp;gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路, 当M=2则是2叉树, M=3则是3叉） 关键字数：ceil(m/2)-1&amp;lt;=枝节点的关键字数量&amp;lt;=M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2); 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子 B+树 特点 B+树的非叶子节点不保存关键字记录的指针，只进行数据索引（非叶子节点所能保存的关键字大大增加） B+树叶子节点保存父节点的所有关键字记录的指针，数据地址必须要到叶子节点才能获取到（每次数据查询的次数都一样） B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针 非叶子节点的子节点数=关键字数（两种实现，或：非叶节点的关键字数=子节点数-1。Mysql 的B+树是第一种） 与红黑树的比较（访问磁盘数据有更高的性能） B+ 树有更低的树高</description></item><item><title/><link>https://leetcode.coding3min.com/leetcode/suan-fa-mian-shi-zhu-yi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/leetcode/suan-fa-mian-shi-zhu-yi/</guid><description>算法面试注意 # 算法思维 # 进入函数优先考虑边界 如果出现循环，进入循环时考虑break条件和continue条件 使用下标计算长度时，优先考虑区间的开闭 我们应该在做算法的过程总不断的思考和总结共性 面试注意 # 一定要记得常用的函数，现场是没有办法可以查的
字符串去左右空格 字符串切割 随机数种子，随机数生成 内置排序函数 int最小值最大值怎么取 以go为例
s = strings.TrimSpace(s) arr := strings.Split(s,&amp;#34;&amp;#34;) rand.Seed(time.Now().UnixNano()) rand.Int() sort.Int() sort.Slice(x,func(i,j int)bool{ // 降序 return x[i]&amp;gt;x[j] }) math.MaxInt32 math.MinInt32 牛客网面试注意 # 牛客网比较坑，一切输入输出都要自己实现
还要劳记链表创建代码， 完整代码
package main import( &amp;#34;fmt&amp;#34; ) type LinkNode struct{ Val int Next *LinkNode } func createNode(a []int) *LinkNode{ head :=&amp;amp;LinkNode{ 0, nil, } prev := head for i:=0;i&amp;lt;len(a);i++{ node := &amp;amp;LinkNode{ a[i], nil, } prev.</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</guid><description>我在测试主从方案的时候发现状态丢失了，同步用的binlog也不见了(binlog doesn&amp;rsquo;t exist)，非常奇怪，回顾解决以后写在这里供大家参考。
报错与原因 # 发现错误信息类似于
Slave: Table 'XXX' doesn't exist Error running query, ......，We stopped at log 'mysql-bin.000036' position 154. 赶快去找，本想看看主数据的这个文件的position 154是什么语句，使用语句
show binlog events in &amp;#39;mysql-bin.000036&amp;#39; 居然返回了502。
又到主库的服务器查看了下binlog的存储情况，发现binlog的编号是从36开始的，前面的不见了！难道设置了参数定期删除binlog？
于是又来到了my.cnf文件，查看文件之后找到了一个expire_logs_days。经搜索，确定了这个参数就是删除以前binlog文件的“罪魁祸首”。
到这来，大概明白了为啥主从同步没有成功，因为这是基于binlog的（逐行扫描sql语句进行同步写入），如果binlog文件不全，就无法正确的进行主从同步。
解决办法 # 这种情况从删除那一天起，至今所有的同步语句全部都丢失了，所以除非可以精确的知道执行了哪些语句，或者那些语句都不重要可以忽略，不然都必须要清理数据库，备份主库，重新手动更新从库来解决。可以参考我的 备份数据库这篇文章的。
如果你精确的知识执行了哪些语句，需要先停止从库，执行丢失的语句，再进行从库同步设置。
mysql&amp;gt; stop slave; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&amp;gt; reset slave; Query OK, 0 rows affected (0.00 sec) .....执行你的语句 mysql&amp;gt; change master to master_host=&amp;#39;192.168.1.51&amp;#39;, master_user=&amp;#39;replslave&amp;#39;, master_password=&amp;#39;replslave&amp;#39;, master_log_file=&amp;#39;mysql-bin-000002&amp;#39;,master_log_pos=168; Query OK, 0 rows affected (0.</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/relaylog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/relaylog/</guid><description>前言：MySQL进行主主复制或主从复制的时候会在home目录下面产生相应的relay log，本文档总结这些相关参数的定义及解释.
1、什么是relay log # The relay log, like the binary log, consists of a set of numbered files containing events that describe database changes, and an index file that contains the names of all used relay log files. The term &amp;ldquo;relay log file&amp;rdquo; generally denotes an individual numbered file containing database events. The term&amp;quot;relay log&amp;quot; collectively denotes the set of numbered relay log files plus the index file</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/</guid><description>[TOC]
1、主库停止应用，确认主库不再有数据生成 # 将主库改为 read_only 模式
mysql&amp;gt; set global super_read_only=on; Query OK, 0 rows affected (0.00 sec) mysql&amp;gt; set global read_only=on; Query OK, 0 rows affected (0.00 sec) 2、查看主备库数据是否一致 # 主库：
mysql&amp;gt; show master status; +------------------+----------+--------------+------------------+-----------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-----------------------------------------------+ | mysql-bin.000012 | 195 | | | 8876d804-9218-11e8-8eaf-0242ac110002:1-224227 | +------------------+----------+--------------+------------------+-----------------------------------------------+ 1 row in set (0.00 sec) mysql&amp;gt; select @@server_uuid; +--------------------------------------+ | @@server_uuid | +--------------------------------------+ | 8876d804-9218-11e8-8eaf-0242ac110002 | +--------------------------------------+ 1 row in set (0.</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/</guid><description>【ERROR】1452:无法在外键的表插入或更新参考主键没有的数据。 # 主键在从库不存在时会发生这样的问题，报1452错误。此时可以检查参考的表的主键是否有主库对应的数据，如果有，则插入参考的表相应的数据，再开启复制恢复SQL线程。
【ERROR】1032:删除或更新从库的数据，从库找不到记录。 # 此时，主库的数据是比从库新的，可以采取从库添加相同的数据再开启复制恢复SQL线程。
【ERROR】1062:从库插入数据，发生唯一性冲突。 # 此时从库已经有相同主键的数据，如果再插入相同主键值的数据则会报错。可以查看主库的改行数据与从库的要插入数据是否一致，如一致则跳过错误，恢复SQL线程，如不一致，则以主库为准，将从库的该行记录删除，再开启复制。
【ERROR】1201: Could not initialize master info structure. # 出现这个错误的原因是因为从库之前已经做过主从复制,所以需要先停止从库，再进行从库同步设置。
具体的解决方法如下：
mysql&amp;gt; change master to master_host=&amp;#39;192.168.1.51&amp;#39;, master_user=&amp;#39;replslave&amp;#39;, master_password=&amp;#39;replslave&amp;#39;, master_log_file=&amp;#39;mysql-bin-000002&amp;#39;,master_log_pos=168; ERROR 1201 (HY000): Could not initialize master info structure; more error messa ges can be found in the MySQL error log mysql&amp;gt; stop slave; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&amp;gt; reset slave; Query OK, 0 rows affected (0.</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/</guid><description>前提 # 本方案是两节点主从方案，只要建立好主从，及时数据库挂掉又拉起主从模式不会失效。
保证时间同步 保证都安装了mysql/mariadb 建立主从的过程 # 这里介绍的是两节点主从，如果是集群模式，至少需要三个节点，因为偶数个节点是导致脑裂高发的原因（无法确定该同步谁的）。
主从服务器节点设置不同的server-id 启用二进制日志和relaylog 主节点创建一个拥有复制权限的用户账号 查询主节点binlog信息 设置从节点同步主节点 停止所有写入 # 在所有服务器上执行此步
在所有服务器上执行此步
在所有服务器上执行此步
停止所有写入是为了防止数据设置同步的过程中数据不一致。
如果 mariadb 是通过 hosts 文件中的域名进行访问的，那么只需要编辑 /etc/hosts , 把mysql的域名解析删掉就可以停止所有读写，执行以下命令。
关掉所有读写mysql的服务，你也可以直接用iptables来禁用端口通信（如果应用有自动重连机制的话，否则只能重启应用了）
等待 1 分钟，依次进入集群中所有的 mariadb ，查看进程状态，确保没有额外的读写操作( command 列除了 show processlist 外没有多余的 sleep 和 query )。
MariaDB [(none)]&amp;gt; show processlist; 备份与导入 # 首先，你需要保证所有的节点数据一致，在升级过程中万一升级失败能及时的恢复数据。
请参考本小册 备份数据库
添加一个专门用来同步的用户 # 在从节点中的 mariadb 执行以下命令，如果全部输出 ok，则继续。
/usr/local/mariadb/bin/mysql -A -e &amp;#34;GRANT replication slave ON *.</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/</guid><description>文档目标 # 由于集群模式容易出现脑裂，恢复起来速度慢，难度大，不稳定，所以采用主从模式托管，容易恢复，更加稳定，同时建立成功主从模式以后，及时关机再重启也不会丢失主从状态。
通过本文档可以把mariadb或mysql从三节点集群模式切换为互为主从（成环）
相对于集群的好处就是不会发生脑裂，故障恢复相对比较容易 坏处是如果挂掉一个节点时，剩下的两个节点就会变成主从模式，如果应用读写到从节点，那么数据就不同步了，需要等待恢复以后才能自动同步（所以我们要控制，挂掉一个节点后，让读写正确的切换到主节点上，可能要keepalived、haproxy的配合） [TOC]
0、检查是否是集群状态 # ps: 监测当前是否是集群模式, 而且整个集群的所有服务器正常，如果不是 ON ，则停止操作，并联系管理员。
在集群中所有服务器上执行
MariaDB [(none)]&amp;gt; show global variables like &amp;#39;%wsrep_on%&amp;#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wsrep_on | ON | +---------------+-------+ 1 row in set (0.00 sec) 1、停止所有写入 # 在集群所有服务器上执行此步
在集群所有服务器上执行此步
在集群所有服务器上执行此步
如果 mariadb 是通过 hosts 文件中的域名进行访问的，那么只需要编辑 /etc/hosts , 把 mysql.cloud.local 的域名解析删掉就可以停止所有读写，执行以下命令。
cp /etc/hosts /etc/hosts.bak sed -i &amp;#34;/mysql.cloud.local/d&amp;#34; /etc/hosts 等待1分钟，依次进入集群中所有的 mariadb ，查看进程状态，确保没有额外的读写操作( command 列除了 show processlist 外没有多余的 sleep 和 query )。</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</guid><description>前言 # MySQL 中的 binlog 日志记录了数据库中数据的变动，便于对数据的基于时间点和基于位置的恢复，但是 binlog 也会日渐增大，占用很大的磁盘空间，因此，要对 binlog 使用正确安全的方法清理掉一部分没用的日志
方法一、手动清理 binlog # 清理前的准备：
查看主库和从库正在使用的 binlog 是哪个文件
show master status \G show slave status \G 在删除 binlog 日志之前，首先对 binlog 日志备份，以防万一
开始动手删除 binlog： 删除指定日期以前的日志索引中 binlog 日志文件
purge master logs before&amp;#39;2016-09-01 17:20:00&amp;#39;; 或 删除指定日志文件的日志索引中 binlog 日志文件
purge master logs to&amp;#39;mysql-bin.000022&amp;#39;; 注意：时间和文件名一定不可以写错，尤其是时间中的年和文件名中的序号，以防不小心将正在使用的 binlog 删除！！！&amp;gt; 切勿删除正在使用的 binlog！！！ 使用该语法，会将对应的文件和 mysql-bin.index 中的对应路径删除。
方法二、通过设置 binlog 过期的时间，使系统自动删除 binlog 文件 # 临时生效
mysql&amp;gt; show variables like &amp;#39;expire_logs_days&amp;#39;; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | expire_logs_days | 0 | +------------------+-------+ mysql&amp;gt; set global expire_logs_days = 30; #设置binlog多少天过期 长期生效需要修改配置文件</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>备份数据库 # 主库锁表
flush table with read lock; 备份数据库（会有压缩，测试数据 11G，得到备份文件 227M）
其中 max_allowed_packet 和 net_buffer_length 两个参数是用来加速的，可以查看从库数据 如果 root 有密码请加上参数例如 -uroot -proot /usr/local/mariadb/bin/mysqldump --max_allowed_packet=33554432 --net_buffer_length=8192 --events -A -B |gzip &amp;gt;/server/backup/mysql_bak.$(date +%F).sql.gz PS: 如果上面的命令报错如下
Couldn&amp;#39;t execute &amp;#39;show events&amp;#39;: Cannot proceed because system tables used by Event Scheduler were found damaged at server start (1577) 请执行命令(如果 root 有密码请加上参数例如 -uroot -proot )
/usr/local/mariadb/bin/mysql_upgrade 备份结束后，解锁主库，恢复读写
unlock tables; 拷贝到从库中
注意日期一定有所不同，如果端口不是默认的请叫参数 -P 端口号 注意确保 /root 目录有足够的空间，如果空间不够请切换目录 scp /server/backup/mysql_bak.</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/</guid><description>root 用户无法免密登陆，同时又忘记了密码?
/usr/local/mariadb/bin/mysqladmin -u有权限的用户名 -p密码 shutdown /usr/local/mariadb/bin/mysqld_safe --skip-grant-tables &amp;amp; mysql -A -e &amp;#34;update mysql.user set password=password(&amp;#39;root&amp;#39;) where user=&amp;#39;root&amp;#39;&amp;#34;; mysql -A -e &amp;#34;flush privileges;&amp;#34; /usr/local/mariadb/bin/mysqladmin shutdown mkdir -p /var/run/mariadb; chown -R mysql:mysql /var/run/mariadb; /usr/local/mariadb/bin/mysqld_safe --datadir=/data/mariadb/data --pid-file=/var/run/mariadb/mariadb.pid &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid><description>注意事项 # mysql.sock不要放在tmp目录下面 # 执行命令，更改mariadb.sock文件位置，防止/tmp目录下文件被删除导致挂掉
sed -i &amp;#34;s/\/tmp\/mariadb.sock/\/data\/mariadb\/mariadb.sock/g&amp;#34; /etc/my.cnf.d/client.cnf sed -i &amp;#34;s/\/tmp\/mariadb.sock/\/data\/mariadb\/mariadb.sock/g&amp;#34; /etc/my.cnf 修改完确认上面命令中的两个文件是不是都成功修改了mariadb.sock的目录，为/data/mariadb/mariadb.sock，如果没有手动修改。</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>本操作是高危操作，会导致所有数据丢掉，用来恢复无法恢复的mysql，重建以后再导入备份好的数据。
1、停止MySql数据库的运行 2、删除mysql/var里面的所有数据库，这里是数据目录，具体请查看/etc/my.cnf的配置 3、进入mysql/bin目录下，执行./mysql_install_db命令 此时会在mysql/var目录下创建两个目录文件mysql、test 4、修改mysql、test两个目录及目录下所有文件的权限：
chown mysql:mysql -R mysql test 注意这里一定要加上-R参数，否则启动会报错 5、启动数据库
./mysqld_safe --user=mysql &amp;amp; 6、修改root密码
mysql/bin/mysqladmin -u root password &amp;#34;yourpasswd&amp;#34; 这样，就完成了MySql数据库的重建了。关于停止MySql的运行，直接用启动MYSQL服务命令也行，也可以用停止进程的方法。启动数据库也可以直接用启动MYSQL服务的命令来启动。</description></item><item><title/><link>https://leetcode.coding3min.com/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/</guid><description>当Mariadb集群因故障重启时，有时会遇到Mariadb Galera Cluster集群无法正常启动的情况。有很多方式能将数据库拉起，但是如何做到快速启动，又不丢失数据呢？
找到数据最新的节点 # 对比三个节点日志中的New cluster view: global state状态，可知道那个节点中的数据是最新的。
[mysql@test45 logs]$ grep &amp;#34;New cluster view&amp;#34; mariadb.log |awk -F: &amp;#39;END { print $1&amp;#34;:&amp;#34;$2&amp;#34;:&amp;#34;$3 $6&amp;#34;:&amp;#34;$7}&amp;#39; 180518 14:59:00 [Note] WSREP 874d8e7e-5980-11e8-8c23-83493ba049c2:&amp;lt;span style=&amp;#34;color:#ff0000;&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;2840&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;, view# 3 [mysql@test44 logs]$ grep &amp;#34;New cluster view&amp;#34; mariadb.log |awk -F: &amp;#39;END { print $1&amp;#34;:&amp;#34;$2&amp;#34;:&amp;#34;$3 $6&amp;#34;:&amp;#34;$7}&amp;#39; 180518 15:55:03 [Note] WSREP 874d8e7e-5980-11e8-8c23-83493ba049c2:&amp;lt;strong&amp;gt;&amp;lt;span style=&amp;#34;color:#ff0000;&amp;#34;&amp;gt;3068&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt;, view# 4 [mysql@test43 logs]$ grep &amp;#34;New cluster view&amp;#34; mariadb.log |awk -F: &amp;#39;END { print $1&amp;#34;:&amp;#34;$2&amp;#34;:&amp;#34;$3 $6&amp;#34;:&amp;#34;$7}&amp;#39; 180518 15:55:41 [Note] WSREP 874d8e7e-5980-11e8-8c23-83493ba049c2:&amp;lt;strong&amp;gt;&amp;lt;span style=&amp;#34;color:#ff0000;&amp;#34;&amp;gt;3111&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt;, view# -1 得知三个节点数据的状态 ：3111&amp;gt;3068&amp;gt;2840</description></item><item><title/><link>https://leetcode.coding3min.com/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/readme/</guid><description>interview-leetcode🔥 # interview-leetcode 项目旨在快速复习找到工作，包括高频算法和真实面试问题问答，当然这些基本知识，也是工程师的学习素养，全部掌握对于工作来说也会有极大的帮助。
如果这个项目能为您带来帮助，我将感到非常荣幸！😁 如果您也对这个项目感兴趣，请 点此跳转项目🌟Star 以示鼓励， 项目会 持续更新，谢谢你的支持。 成员结构 # 这是一群爱学习的互联网人，联合起来完成了这个知识库的维护
编程伐木累线上组织的成员来源于各个公司和各大高校，在群里我们可以一起:
认识各大公司一线开发者，和他们进行交流分享 获得内推机会，我们的成员来自国内众多一线互联网公司、还有专业的人力资源在线答疑 讨论最新互联网前沿知识和目前的趋势 反馈本书遇到的问题，共同改善内容质量 成为本书的编辑者，为手册贡献更多优质的内容 日常分享算法、Go等语言、工程、架构、运维等技术内容 群内分享工作经验、职场感悟、学习方法、商业、投资、协作、管理等方面的想法 成为组织的一员，可在群内在线答疑交流、以及反馈知识库中的问题。
算法 # 刷题平台： LeetCode中国
算法面试注意 数据结构 LeetCode-hot100-easy LeetCode-hot100-medium LeetCode-hot100-difficult 其他高频算法 华为机试 面试高频问题大全 # 面试高频问题，是技术交流群每日一问讨论并总结得出，复习的时候注意反思节奏，用过没，是什么，哪个更好，为什么可以这样，是怎么实现的
面试高频问题-操作系统 面试高频问题-linux 面试高频问题-go 面试高频问题-redis 面试高频问题-mysql 面试高频问题-网络 面试高频问题-docker 面试高频问题-k8s TODO面试高频问题-前端 TODO面试高频问题-mongoDB 项目一般问什么 面试高频问题-待解答 更多内容见电子书 leetcode.</description></item><item><title/><link>https://leetcode.coding3min.com/todo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/todo/</guid><description>待解答 # 介绍 # 此处是未解答的问题列表，欢迎挑战，可以提 issue 和 pr , 解答时提issue直接粘贴题目发起起问题即可
前端 # react中的diff算法是什么，为什么要做diff算法，key有什么用 # 提问：小雨
回答-橙子： 如果有问题请更正我，谢谢！ key 这个答案很简单就两个作用1. 为了高效，， key 相当于一个标记， 快速的能够比较出现在节点和之前节点的区别，比如你一个数组， 你有下标就能更快的找到，diff算法里面就提到了先比较key， 如果没有key ， 那undefiend == undefined ,这样就会产生第二个问题， 容易就地复用所以key的第二个作用就是为了避免就地复用， 举个简单例子， 你写一个循环， 循环里面有每一个元素都有一个checkbox， 有一个他对应的文案， 这时候你进行一个排序， 没有key 你会发现内容排序变了，但是选中的checkbox 并没有跟着内容一起动
diff 算法我不会react 所以不能确定是否和vue 一样， 如果有需要vue的diff 算法解释请联系我
闭包与Hooks设计有什么联系？ # 提问：小雨
java # hashmap和treemap的区别 # go # hashmap是怎么实现O1算法的时间复杂度的 # 为什么数组删除和插入是O（n） # redis # Redis 原理与调优经验 # 有用过哪些数据结构 # zset 是怎么使用的 # 介绍一下持久化aof rdb # 分片是如何存储 # mysql # mysql的事物隔离级别有哪些 默认的事物隔离级别是什么？ # mysql 数据库 undolog和binlog的区别是什么？ # mysql 回表和覆盖索引是什么？ # 回表就是普通索引，定位id，再通过聚簇索引定位到数据，覆盖索引就是把单索引升级成联合索引，将多个列一起做索引，能防止回表</description></item><item><title/><link>https://leetcode.coding3min.com/tools/components/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/tools/components/readme/</guid><description>这里存放了前端的各种组件
canvas # 20行代码实现代码雨效果 code-rain</description></item><item><title/><link>https://leetcode.coding3min.com/tools/mac/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/tools/mac/readme/</guid><description>程序员的mac一些小技巧
小问题 # brew install卡 暂时禁止自动更新，关闭窗口后失效
export HOMEBREW_NO_AUTO_UPDATE=true 命令替代 # tree命令
alias tree=&amp;#34;find . -print | sed -e &amp;#39;s;[^/]*/;|____;g;s;____|; |;g&amp;#39;&amp;#34;</description></item><item><title/><link>https://leetcode.coding3min.com/tools/mark-markdown-ppt/example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/tools/mark-markdown-ppt/example/</guid><description> Marp for VS Code方法 # 一种用markdown写ppt的vscode插件marp # 这款ppt就是我用“写”出来的，用来展示效果。
幻灯片1
asdf asdf 幻灯片2
asdf asdf 左中右组合方式 # 在其中一张图片后加入属性 vertical 将使图片纵向组合。 # 设置左图右文 # 文字 文字 命令 单独看图片 # 可以看到图片已经放到右边了，非常舒服
prometheus # 此处的图片加了阴影drop-shadow
引用 # 技术分享之工具推荐-jeremyxu marp官方文档 Marp：用 Markdown「写」PPT 的新选择 官方github 谢谢 #</description></item><item><title/><link>https://leetcode.coding3min.com/tools/mark-markdown-ppt/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/tools/mark-markdown-ppt/readme/</guid><description>一种用markdown写PPT的方法，再也不用费劲排版了 # 本文原创首发于 一种用markdown写PPT的方法，再也不用费劲排版了
示例:
源文件 example 生成ppt example.pptx 前言 # 今天看 jeremyxu 的技术点滴，发现分享了一个 markdown 写 PPT 的插件，惊为天人，先来看看官方效果图。
再看看 jeremyxu 写的效果，我学完了都没学会是怎么写的，直到看了他 项目样例我才算是真的学会了。
参考 marp 官方文档可以很快学会用法，但是用的时候去翻比较麻烦，我提炼了常用的语法，最后做了一个 PPT 练手，才算是学会了，现在分享出来以便以后翻阅。
marp 是个什么？ # 日常工作生活中常常会用到 ppt, 但是 ppt 有时候做起来非常浪费时间，如果不用关心排版，可以专注内容自动排版岂不妙哉？
正好 markdown 就是解决排版的一种语言，有好心人自发开发了一个做 ppt 的利器，只用关注内容，简单分隔一下，稍微改一下样式就可以用了。
安装和上手 # 下载个 VSCode, 天然支持 markdown ，然后在左侧的插件栏中搜索并安装 Marp for VS Code 就可以开始了。为了获得更好的 Markdown 编辑体验，大家不妨再安装一个叫做 Markdown All in One 的插件。
使用 Markdown 输出一份最简单的幻灯片，只需要让编辑器知道两点即可：它是幻灯片（不是文档）以及它该在哪里分页，通过如下代码做到：</description></item><item><title/><link>https://leetcode.coding3min.com/tools/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/tools/readme/</guid><description>实用工具 # 工具名称 技术栈关键字 备注 markdown写PPT工具 vscode、markdown、ppt vscode的插件，从此不用再关心ppt排版 命令行自动演示工具 linux、demo 讲课、分享的时候假装在现场输入命令的作弊工具 运维工具 # 工具名称 技术栈关键字 备注 消耗CPU资源的脚本 shell、cpu 可设置占用多少cpu 前端组件库 # 分类 组件与效果 技术栈关键字 备注 背景 20行代码实现代码雨效果 canvas</description></item><item><title/><link>https://leetcode.coding3min.com/tools/scripts/devops/killcpu/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/tools/scripts/devops/killcpu/readme/</guid><description>使用方法很简单，参数3表示消耗3颗CPU的资源，运行后，会有一堆 kill 命令，方便 kill 进程：
[root@test02 ~]# ./killcpu.sh 3 kill 30104 ; kill 30106 ; kill 30108 ; [root@test02 ~]# top top - 15:27:31 up 264 days, 23:39, 4 users, load average: 0.86, 0.25, 0.19 Tasks: 185 total, 5 running, 180 sleeping, 0 stopped, 0 zombie Cpu0 : 100.0% us, 0.0% sy, 0.0% ni, 0.0% id, 0.0% wa, 0.0% hi, 0.0% si Cpu1 : 0.0% us, 0.0% sy, 0.0% ni, 100.</description></item><item><title/><link>https://leetcode.coding3min.com/tools/scripts/show-demo-magic/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/tools/scripts/show-demo-magic/readme/</guid><description>报错？网卡？演示的时候别再尴尬，试试 demo-magic 假输入命令工具
本文原创首发于 报错？网卡？演示的时候别再尴尬，试试 demo-magic 假输入命令工具
简介 # 演示的时候要准确的输入很多命令，有时候会遭遇网比较卡，半天没反应，或者命令报错的尴尬，特别在大分享，众多人等待的情况下，只能面对面，干瞪眼。
所以 demo-magic 就是解决这个问题的，他可以模拟你的输入输出，看起来就像现场打字一样，你还可以调整打字速度，可以随时暂定继续，满足演示的需要。
如下图，就是全自动的，我特意让他在下载东西的时候停顿了1秒，在登陆的时候特意等待我按回车。
用法 # 先到 github上把demo-magic.sh下载下来，放到任意目录里。
我的目录结构
. |____tools | |____demo-magic.sh |____cache | |____ls-al-cache.txt | |____install-pv-cache.txt |____run.sh demo-magic.sh 就是下载好的脚本 cache 用来保存准备好的输出 run.sh 测试脚本（假演示脚本） 这个工具 用法非常非常简单，简单到一看就会的程度。
#/bin/bash # include demo-magic . ./tools/demo-magic.sh -n # Will wait max 1 seconds until user presses PROMPT_TIMEOUT=1 TYPE_SPEED=10 # hide the evidence clear p &amp;#34;ls -al&amp;#34; cat cache/ls-al-cache.txt p &amp;#34;brew install pv&amp;#34; wait cat cache/install-pv-cache.</description></item><item><title/><link>https://leetcode.coding3min.com/%E5%85%A5%E8%81%8C%E5%90%8E/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leetcode.coding3min.com/%E5%85%A5%E8%81%8C%E5%90%8E/</guid><description>快速熟悉一个项目的方法 # 不知道你有没有经历过一个五年或者更长工作年限的开发人员半路加入团队的情况，可能第一两个星期他会问一些业务或者技术问题，不过一两个月他就可能在指导那些初级开发人员了。
什么原因呢？因为他已经从过往经验里面总结出来一些套路了。
项目的共性 # 绝大部分业务系统，核心功能都是由增删改查组成，然后通过通信、运算和人机交互串起来的，系统的复杂度主要体现在系统规模、性能、稳定性、业务流程、通信等方面。（部分工具类、基础架构类系统可能不一样） 绝大部份系统，都是遵循某种或几种设计模式分层进行开发的，最最常见的也就是MVC了。其他请参考一下设计模式教程。 快速熟悉新的项目的套路。 # 先搞清楚新的系统是搞什么的，就问简单几个问题，谁在用这个系统？用这个系统做什么？然后自己根据这些问题去文档找答案。 弄清楚系统是怎么分层、分模块的，每层、每个模块都用到了什么技术和框架，之间是怎么通信的。有架构设计文档的话学习一下最好，没用过的技术先查查资料知道个大概。 把开发环境搭起来，通过几个典型的功能弄清楚系统里面增删改查、通信、用户交互是怎么实现的。最简单的方法是根据系统的分层，先从前端到数据库把代码疏通一下，搞不清楚的话打开debug模式一步一步走一下。 经过上面三个步骤基本上就可以改几个bug和照葫芦画瓢做个功能了。后面重点关注那些没用过的技术和组件：先搞清它的目的、背景、实现原理和功能列表，再照着文档做几个demo，平常工作时把它的文档建个快捷方式，随手查询学习一下。 平常开发过程中如果遇到问题首先要相信： 1）绝大部分自己遇到的问题很多人已经遇到过并且解决了 。 2）绝大部分自己遇到的问题在当前系统里面已经有了答案。 3）绝大部分自己遇到的问题在你用的框架和组件里面都有现成的解决方案。
对于规模比较大的系统或者系统集合，其实你平时工作接触到的也就是其中的一个系统或者模块，先把自己接触的部分搞定就行了。 对于老系统要注意 # 对于老系统，首先建议看一下 在感觉项目代码的构架不行的时候, 你们会怎么办?
老系统其实满是宝藏，里面有很多你可以借鉴和学习的东西。 老系统也满是坑，一个看起来毫不悬念的代码改了以后可能会引发地震。 很多你看着不爽的代码其实都是有道理的。 不要在老系统里面继续挖坑。 看不懂的代码不要动。 在你力所能及的范围内让老系统变的更美好。 上面这个套路应该符合百分之七八十的项目，可以试试看。
引用： 程序员如何快速上手一个自己不太熟悉的新项目？有什么技巧？</description></item></channel></rss>