[{"id":0,"href":"/blog/","title":"Blog","section":"","content":"编程伐木累成员博客 #     网站 GitHub 优秀开源项目 微信公众号 说明     机智的程序员小熊 minibear2333 go语言精进之路 机智的程序员小熊 涉及各种后端语言、OpenStack、DevOps、容器等，还有一些思考   老衲的博客       yann的小站 运维、go语言       好博客推荐 #     网站 说明     酷壳 左耳朵耗子的博客，无所谓技术，里面一些思考见解也是值得一看的，我没事就会看看   Jack Cui 剑指Offer全集题解，机器学习领域，建站文章写的比较全   wego 一个线上go语言组织内容很丰富   星光博客 wordpress建站比较6、其他文章没什么意思    "},{"id":1,"href":"/leetcode-vscode/","title":"Leetcode Vscode","section":"","content":"协作办法 #  下载插件 #  直接在vscode中搜索 LeetCode 插件完成下载，并登陆账号，修改配置如下\n找到修改配置位置 #   改为中国区 #   修改默认语言 #   修改文件夹目录 #  修改插件配置，设置文件夹目录为 LeetCode/all ，这样才会自动创建go文件在此\n\u0026#34;leetcode.filePath\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;folder\u0026#34;: \u0026#34;LeetCode/all\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;${id}.${kebab-case-name}.${ext}\u0026#34; } } 修改工作目录 #  如果不是直接打开的需要修改工作目录\n 最后 #  如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群\n"},{"id":2,"href":"/leetcode/all/readme/","title":"Readme","section":"LeetCodes","content":"请使用 vscode 中的 LeetCode 插件，自动创建文件、手动提交测试\n"},{"id":3,"href":"/leetcode/difficult/","title":"Difficult","section":"LeetCodes","content":"LeetCode-hot100-difficult #  介绍 #  一句话总结算法思路，LeetCode hot100 difficult\n按频率排序，排序依据参考 字节跳动后端高频面试题目。\n全部源码可见我的GitHub interview-leetcode\n注：\n有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。\n题解 #  42.接雨水 #  题目： 接雨水，给定整数数组，把他想象成柱状图，凹槽部分接雨水总合\n题解：用栈的思路比较难理解，我写在代码里了，有兴趣可以自己看看，这里推荐双指针的思路\n 双指针下标l和r指向0和len-1，记录左侧最大值height[0]和右侧最大值height[len-1]   判断左侧和右侧最大值哪个更小，更小侧向内测移动，比如 if lMax\u0026lt;rMax then l++     如果当前指针位置比lMax要小，又因为此时rMax\u0026gt;lMax说明此处一定会出现低洼，它被两侧包住了，一定不会渗水；水的高度是由更小的最大值决定，现在是lMax     统计水量res += lMax - height[l]，如果当前指针比lMax大，说明左侧包不住，更新左侧最大值   上面1、2、3步骤的动作else 反过来，r--; if height[r]\u0026lt;rMax then res+= rMax-height[r] else rMax = height[r] 循环条件l\u0026lt;r,函数至少要3个值才有可能形成低洼，所以边界是len\u0026lt;3 return 0  代码： golang\n题目：\n题解：\n注意：\n代码： golang\n最后 #  如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群\n我是小熊，关注我，知道更多不知道的技术\n "},{"id":4,"href":"/leetcode/easy/","title":"Easy","section":"LeetCodes","content":"LeetCode-hot100-easy #  介绍 #  一句话总结算法思路，LeetCode hot100 easy\n总计21题，题目列表请戳 LeetCode Hot100 easy 列表。\n全部源码可见我的GitHub interview-leetcode\n注：\n有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。\n题解 #  1.两数之和(高频) #  题目： 数据中是否有两个数之和为目标值\n题解：遍历数组，用目标值减去当前值，判断HashMap是否有值存在，如果有则创建新数组返回两者，如果没有循环遍历完返回空数组\n时间复杂度：O(1) 代码： golang\n20.有效的括号(高频) #  题目： 存在[]{})(的字符串，判断是否合法\n题解： 存储左括号和右括号的映射，用栈统计左括号，出现左括号就入栈，出现右括号就和栈顶在map中映射的右括号比较，如果匹配就出栈，不匹配返回false，最后遍历完栈空为false\n注意：go语言可以用byte代表单个字符\n代码： golang\n21.合并两个有序链表(高频) #  题目： 两个升序链表，合并成一个\n题解：\n 需要一个空的头节点做辅助，head.Next就是结果 每次遍历始终维护上一个节点prev，初始值prev=head 循环遍历两个链表，循环条件都不为空，每次把当前节点更小的取出来即可  prev.Next = l1 prev = l1 l1 = l1.Next  最后加入有不为空的节点，则直接赋值  if l1!=nil{ prev.Next = l1 }else{ prev.Next = l2 } 代码： golang\n53.最大子序和(高频) #  题目： 求和加起来最大的连续子数组\n题解：\n 一次循环，数组里有可能出现负数，且只需要统计和即可 需要两个计数器，一个存储全局最大的子序列和，只要出现更大的就更新 另一个存储当前最大的子序和，判断当前最大子序和的方法是比较子序和与当前值哪个大 有可能当前值比子序列和大，就更新子序 max(nums[i],nums[i]+last)  核心代码\nlast = max(nums[i],nums[i]+last) resMax = max(resMax,last) 代码： golang\n70.爬楼梯 #  题目： 一次可以上一阶或者二阶，如果是n阶有多少种爬法\n题解：斐波那契数列，返回结果是前两个值的和，只需要保存前两个值和当前结果，递推赋值即可\n代码： golang\n101.对称二叉树 #  题目： 二叉树是不是镜像的\n题解：\n 递归，相当于使用了前序遍历和后续遍历相等的性质 函数签名isMirror(root,root)，判断前序和后续相等  q.Val == p.Val \u0026amp;\u0026amp; isMirror(p.Left,q.Right) \u0026amp;\u0026amp; isMirror(p.Right,q.Left)  注意都为空时true，其中一个为空时false  if p == nil \u0026amp;\u0026amp; q == nil { return true } if p==nil || q==nil{ return false } 代码： golang\n104.二叉树的最大深度 #  题目： 根节点到最远叶子节点的最长路径上的节点数\n题解：递归，前序遍历，返回值为左右节点最大深度+1，退出条件为null节点返回0，左右子树都为空返回1\n代码： golang\n121.买卖股票的最佳时机(高频) #  题目： 给定整数数组表示每天股票价格，买一次卖一次求最大收益，要求必须先买再卖\n题解：与目前最小值做差，得到当前最大值，更新最大值，一次循环。核心代码如下\nif v\u0026lt;minNum{ minNum = v }else if v - minNum \u0026gt; maxNum{ maxNum = v - minNum } 代码： golang\n136.只出现一次的数字 #  题目： 数组中某元素只出现一次，其余两次。找那个元素\n题解：\n 方法一、直接用map统计，超过一次就删掉 方法二、每个值都异或，最终得到的就是答案 异或的性质：a^a=0, a^0=a  代码： golang\n141.环形链表(高频) #  题目： 判断链表中是否有环\n题解：快慢指针，相等时退出，注意循环条件\np.Next != nil \u0026amp;\u0026amp; q.Next != nil \u0026amp;\u0026amp; q.Next.Next != nil 代码： golang\n155.最小栈(中频) #  题目： 设计一个栈，支持push、pop、top、getMin获取栈内最小值操作\n题解：要自定义结构体，结构体内两个栈，一个存储push的元素的栈1，另一个存储最小值栈2，栈2有一个性质，每个栈2内元素位置为栈顶时，始终表示当前栈1最小的元素，比如\n栈1 [1 2 3 4 0] 栈2 [1 1 1 1 0] 这样出栈同同步出栈，始终最小值就是栈2的栈顶，使用了一个当前最优解的思路\n代码： golang\n160.相交链表(高频) #  题目： 假定链表中没有循环，判断两个链表是否相交\n题解：\n法1（笨办法）\n 双指针同步走，肯定有一个先结束，假如另一个指针所指到结束位置的距离就是长链表比短链表多出来的部分 长链表跑到和短链表等长，然后同步走，找出相等节点（地址相同非值相同）  法2（最优）\n pA走过的路径为A链+B链, pB走过的路径为B链+A链 分别将另一个链表拼到尾部，相当于两个链表等长 pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。  pA:1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;null-\u0026gt;9-\u0026gt;5-\u0026gt;6-\u0026gt;null pB:9-\u0026gt;5-\u0026gt;6-\u0026gt;null-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;null 代码： golang\n169.多数元素 #  题目： 数组中有一个数超过元素的一半，找出那个数\n题解：\n 最先想到的是hash表，更好的办法是投票 随便选个人当选，和它不同就反对，票数\u0026ndash; 和他相同就赞成，票数++ 票数为0则换届，最终票数肯定是正的，当选的肯定是众数，代码较短我直接贴上来了  func majorityElement(nums []int) int { var count,num int for _,v := range nums{ if count == 0 || v == num{ num = v count++ }else{ count-- } } return num } 代码： golang\n206.反转链表(高频) #  题目：\n题解：\n 其实是234. 回文链表 的一部分,就是在考基本功  方法1、递归\n 首先要确认递归返回链表头，所以退出条件：head为空直接退出，递归内部head.Next为空返回头节点 递归传入head.Next返回已经反转好的链表头 递归后动作，需要让最后的头节点指空，也就是head.Next = nil在指空前，需要让head.Next.Next=head  1-\u0026gt;2-\u0026gt;null 1\u0026lt;-2 nil\u0026lt;-1\u0026lt;-2 关键代码\nnewHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead 方法2、非递归（最快，省空间）\n 非递归两件套，prev,curr = nil,head 每次保存下一个节点，让当前节点指向上一个节点 然后向下走一位,prev=curr; curr=next,curr为空时停止，prev就是新的头节点  代码： golang\n226.翻转二叉树 #  题目： 翻转二叉树，每一层都要完全翻转\n题解：\n方法1 非递归 不推荐 较为麻烦，容易漏掉\n 层遍历保存每层的状态，反着读出来每层就是翻转结果 但不能改变层遍历的过程，所以要两个栈，栈1保存层遍历，栈2保存该层的反向结果作为下次的before层 遍历栈2，左右节点指向倒着遍历栈1 要注意有可能出现部分空节点的情况，栈1，空位要留出来，所以要用nil来占位  方法2 递归:其实子节点还是属于父节点，只要翻转左右节点位置就行了\n自身递归，“交换”左右子树时记得备份。 代码： golang\n234.回文链表 #  题目： 判断一个链表是否为回文链表\n题解： 法1、最简单，直接遍历一次转换成数组，判断数组是否回文即可 法2、快慢指针（整除器）\n  把剩下的一半变成逆序，再进行比较。注意奇偶情况讨论。递归非递归都行，想起来哪个用哪个，判断完后恢复链表\n  如果要快就边跑边让慢指针翻转链表，结束后也不用恢复\n代码： golang\n  283.移动零 #  题目： 把数组里的零全部移动到结尾\n题解：两个下标，使用类似于选择插入排序的方法，不断扩充非零列，剩余的元素用0填充\n代码： golang\n448.找到所有数组中消失的数字 #  题目： 1-n的数字存储在长度为n的数组里，有的数字重复出现了，所以有的数字没有出现，找出没有出现的数字\n题解： 法1、直接用hash表，比较简单，不过建议还是用法2可以体现水平 法2、用占位方法，遍历，出现的abs(数字)-1作为下标的数字改为负，如果已经是负的就不用改了，最后再遍历一次数组把存储数字为正位置的(下标+1)存储到结果集里\n代码： golang\n461.汉明距离 #  题目： 求两个数字二进制位不同的有多少个\n题解：先亦或，然后%2=1时统计，\u0026gt;\u0026gt;1代表/2去掉一位\n代码： golang\n543.二叉树的直径 #  题目： 求两个叶子之间最大距离\n题解：\n 深度优先dps，必须用递归，递归返回的是左右子树最深深度 维护一个最大值，递归返回后判断左右子树贡献的深度和，与最大值哪个大，更新最大值，这样可以保证直径是当前最大 max(x+y,maxRes) 返回当前子树最大深度return max(x,y)+1  代码： golang\n617.合并二叉树 #  题目： 合并二叉树，同位置都有值就加起来，有一个为空就只合并\n题解：\n 递归，返回条件：其中一个为空返回另一个节点 如果两个都不为空，加起来 处理递归函数，分别传入两棵树的左子树或右子树，赋值给当前节点左右子树 跟437 路径总和III的思想是一样的。  代码： golang\n最后 #  如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群\n我是小熊，关注我，知道更多不知道的技术\n "},{"id":5,"href":"/leetcode/hot100/readme/","title":"Readme","section":"LeetCodes","content":"介绍 #  题目列表请戳 [LeetCode-Hot100列表](https://leetcode-cn.com/problemset/leetcode-hot-100/\n算法 LeetCode Hot 100 思路与代码，请点击相应目录查看\n最后 #  如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群\n"},{"id":6,"href":"/leetcode/hua-wei-ji-shi/","title":"Hua Wei Ji Shi","section":"LeetCodes","content":"华为机试 #  字符串余 #  输入若干字符串和一个数字n，按8切分字符串，长度不足补0\n示例：\n输入：asdf 123456789 输出：asdf0000 12345678 90000000 func splitStr(str string,n int){ zeroStr := \u0026#34;00000000\u0026#34; for len(str)\u0026gt;8{ fmt.Println(str[:8]) str = str[8:] } fmt.Println(str+zeroStr[:8-len(str)]) } 货币汇率兑换算法 #  知道各货币兑换另一种货币的汇率，要求求最大兑换和最小可兑换货币\nUSD - RMB 1:6 RMB - HKD 1:2 HKD - JAN 1:20\n示例：\n输入HKD = 65 最大可兑换 USD=10,RMB=5 最小可兑换 JAN=2600 函数\n// 顺序输入UDB RMB HKD 汇率，比如上面的例子，输入[6 2 20] // moneyType = 0 1 2 3 对应 USD RMB HKD JAN，money对应货币数量 // isMax = true 时求最大可兑换 false 时求最小可兑换 // 返回兑换情况，最大[5,2,1,0]，最小[0,0,0,1300] func xxx(rate []int,moneyType int,money int,isMax bool) []int{ } 解法,代码见 货币汇率兑换算法.go\nfunc xxx(rate []int,moneyType int,money int,isMax bool) []int{ res := make([]int,len(rate)+1) res[moneyType] = money rate = append(rate,1) if isMax{ for i:=moneyType;i\u0026gt;0;i--{ res[i-1] = res[i]/rate[i-1] res[i] = res[i]%rate[i-1] } return res } for i:=moneyType; i \u0026lt; len(res)-1; i++ { res[i+1] = res[i] * rate[i] res[i] = 0 } return res } 货币汇率兑换算法2 #  知道各货币兑换另一种货币的汇率，要求求最大兑换和最小可兑换货币(注意，有可能有的货币无汇率信息)\nUSD - RMB 1:6 HKD - JAN 1:20\n示例：\n输入HKD = 65 最大可兑换 HKD=65 最小可兑换 JAN=2600 输入RMB=65 最大可兑换 USD=10,RMB=5 最小可兑换 RMB=65 函数\n// 顺序输入UDB RMB HKD 汇率，比如上面的例子，输入[6 0 20],0表示不能兑换 // isMax = true 时求最大可兑换 false 时求最小可兑换 // moneyType = 0 1 2 3 对应 USD RMB HKD JAN，money对应货币数量 // 返回兑换情况，输入moneyType=2 money=65 输出最大[0,0,65,0]，最小[0,0,0,1300] // 返回兑换情况，输入moneyType=1 money=65 输出最大[10,5,0,0]，最小[0,65,0,0] func xxx(rate []int,moneyType int,money int,isMax bool) []int{ } 解法，代码见 货币汇率兑换算法2\n螺旋矩阵变体 #  输入一个坐标，直接输出对应的值，比如输入横坐标-4 纵坐标6输出什么（里面是个正方形，边长乘以边长就是结果）\n21 22…… 20 7 8 9 10 19 6 1 2 11 18 5 4 3 12 17 16 15 14 13\n示例\n输入样例 ： 0 0 -1 -1 输出样例 ： 1 5 先去掉内层面积，可以得到起始点值\n内层面积先求内层边长，side := (max-1) * 2 + 1\n内层面积：area := side*side 所以起始点为 begin := area + 1\n可以根据外层最大坐标值算出起始点坐标，(max,max-1)\n从起始点位置开始遍历坐标，规律为下左上右，对应 y- x- y+ x+，同时num++\n当达到边角以后需要转向，需要一个计数器统计当前方向 0 1 2 3 对应 y- x- y+ x+\n可以发现0 2是偶数改变y，1 3是奇数改变x，此时再确定符号\n0 2平移一位变成 -1 1 可以控制y-1或者y+1，1 3平移两位变成-1 1控制x-1或者x+1\n计数器数值变化需要在outSide-1的情况变化一次 所以 / (outSide-1)\n计数器需要在outSide-1的时候就要变化，所以到达outSide-1时必须计数为outSide-1的倍数时 num - begin = 0 所以 num - begin + 1\nfunc getNum(x,y int) int{ if x == y \u0026amp;\u0026amp; x == 0{ return 1 } maxNum := max(abs(x),abs(y)) side := (maxNum - 1) * 2 + 1 begin := side * side + 1 outSide := side + 2 num := begin for cnt,i,j:=0,maxNum,maxNum-1;cnt\u0026lt;4;{ if i == x \u0026amp;\u0026amp; j == y{ return num } if cnt%2 == 0{ j = j + cnt - 1 }else{ i = i + cnt - 2 } num++ cnt = (num - begin + 1) / (outSide - 1) } return num } 测试用例,输出1 2 3 4 5 6 7 8 9\nfmt.Println(getNum(0,0)) fmt.Println(getNum(1,0)) fmt.Println(getNum(1,-1)) fmt.Println(getNum(0,-1)) fmt.Println(getNum(-1,-1)) fmt.Println(getNum(-1,0)) fmt.Println(getNum(-1,1)) fmt.Println(getNum(0,1)) fmt.Println(getNum(1,1)) "},{"id":7,"href":"/leetcode/medium/","title":"Medium","section":"LeetCodes","content":"LeetCode-hot100-medium #  介绍 #  一句话总结算法思路，LeetCode hot100 medium\n按频率排序，排序依据参考 字节跳动后端高频面试题目。\n全部源码可见我的GitHub interview-leetcode\n注：\n有下划线标志的都是超链接。 点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。 点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。\n3.无重复字符的最长子串 #  题目： 在字符串中找一个子串，要求连续无重复字符且最长，只需要返回最大长度\n题解：\n 字符串长度为0直接返回 记录最大子串的长度，用来和新子串长度比较，维护子串的状态还需要记录当前子串的起始位置的下标 使用map来储存字符对应的下标， 只要当前字符出现在map里，同时map里的字符就是子串里的字符时（存储的字符下标大于等于起始位置下标）说明重复，更新子串起始位置为map中记录的重复点+1 else (没有出现在子串里)，子串长度++，判断更新最大长度(注意更新时+1)  代码： golang\n215.数组中的第k个最大元素 #  题目： 数组中的第k个最大元素\n题解： 方法1，堆排序（不推荐）\n 求第K大的数，实际上就是取小根堆的根节点 小根堆的性质，根节点比所有叶子节点更小  注意：这里为什么用堆，是因为堆是一个完全二叉树，而二叉搜索树不自平衡，而且堆的话小根堆直接取根节点就是结果了\n方法2 快速排序变形（快速选择算法）\n 其实就是快排的思路，只是做了下剪枝 只要保证len-k这个位置右侧全部比k大，左侧全部小于等于k，那么len-k位置的数就是第k大 因为我们不知道是哪个数，所以随便取一个数x，最终达到左侧全部\u0026lt;=x，右侧全部\u0026gt;x的效果 把x的下标index和len-k比较，如果小，说明第k大数一定在[index+1,r]；如果大说明第k大数一定在[l,index-1]中 缩小区间，继续随便取一个数，直到正好x的下标就是len-k为止  查找中枢的办法借助快排的思路\n 随机取一个数x，把他和r位置的数对调 维护左侧区间都比x小，所以初始化i为l-1 变量j遍历[l,r) 左闭右开区间，大于x无操作 小于x时候,i++，然后对调i和j位置的数字，这样又可以保证i左侧包括i位置的数都小于x 遍历结束以后i+1位置的数正好是最后一个比i大的数，把他和r对调 返回i+1，也就是中枢位置的下标  时间复杂度：运气好就是一次就找到了On运气不好每个数都找了一次ON^2，算法导论中把每次查找都使用一个随机数，可以显著提高效率，趋近于On，具体为什么可以自己去看\n为什么推荐用快选，因为空间O1，时间On~On^2比堆的时间Onlogn和Ologk更快，但是快排也有局限性\n 快选需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。 堆只需要保存 k 个元素的小根堆。快速排序变形的方法如果不允许修改原数组那就要保存下来所有的数据，所以数据量大时用堆更好  引用： 优劣比较\n代码： golang\n15.三数之和 #  题目： 数组里有没有三个数加起来为0，找出所有可能的情况\n题解：\n 先把数组排序 从小到大遍历这个数组，每次取一个元素，将这个元素的相反数设为target 在每次遍历中，使用双指针对当前元素的后面的所有元素进行处理，找到所有两个元素的和为target，这样，三个元素的和就是 0 双指针的具体处理方式为：头尾各一个指针，每次判断两个指针所指的元素的和与target的大小，如果和小了，左指针右移；如果和大了，右指针左移，直到两个指针相遇  注意：\n 因为不能有重复的结果，所以前后两次遍历取的元素如果相等，要采取跳过的操作 在第三步中，对当前元素的后面的所有元素进行处理的原因是，前面的元素已经找到了所有符合条件的可能，不需要再找  代码： golang 引用： 【LeetCode】15#三数之和\n22.括号生成 #  题目： 数字n代表生成括号的对数,请生成所有可能的并且有效的 括号组合3\n比如：\n输入：n = 3 输出：[\u0026#34;((()))\u0026#34;,\u0026#34;(()())\u0026#34;,\u0026#34;(())()\u0026#34;,\u0026#34;()(())\u0026#34;,\u0026#34;()()()\u0026#34;] 题解：\n 找不同可能性的题目，解题思路优先考虑深度优先dfs 既然是有效的括号组合而且只有小括号，那么只需要维护n个左括号，n个右括号的组合 深度优先，就是类似二叉树的遍历，使用模板  func dfs(根){ dfs(左子) dfs(右子) }  要维护左右括号的个数 因为是有效的括号，要先拼左括号再拼右括号，需要左右括号相等，所以  func dfs(左括号个数，右括号个数，当前字符串){ if 左\u0026gt;右{ return } if 左==右{ append(res,当前字符串) return } if 左\u0026gt;0{ dfs(左-1，右，当前+\u0026#34;(\u0026#34;) } if 右\u0026gt;0{ dfs(左，右-1，当前+\u0026#34;)\u0026#34;) } } 注意：边界n==0不需要查找\n代码： golang\n103.二叉树的锯齿形层序遍历 #  题目： 先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进\n题解：不改变原树结构，层遍历，维护正反bool条件，头插尾插，最终返回二维数组\n代码： golang\n39.组合总合 #  题目： 找出数组里所有和等于target的总合\n题解：回溯，边界是sum大于target剪枝，等于就拿到一个结果\n注意：append一维数组的时候要拷贝下\n拷贝函数参考\nvar tmp []int tmp = append(tmp,curr...) res = append(res,tmp) 代码： golang\n142. 环形链表 II #  题目： 找到交点坐标的下标，无环时返回null\n题解：\n 这不仅仅是返回是否相交，还要找到交点的下标；我们知道可以用双指针相遇时说明相交 找到交点时，快指针正好比慢指针多一圈   设链表共有 a+b+c 个节点，链表头部到链表入口有 a 个节点（不计链表入口节点），相遇时快指针走了a+b+c+b次，慢指针走了a+b次，发件人指针是慢指针的两倍速度,可得\na+b+c+b = 2(a+b) c=a 所以相遇时再加一个头指针一起跑，慢指针继续跑相遇点就是环的起始位置\n代码不写了，比较简单\n300.最长递增子序列 #  题目： 求最长递增子序列的长度，子序列是不连续的\n题解：求最值，不用保存子序列，我们记录数组里每个数作为终点的序列最长长度就好了\n 对每个数都遍历之前的数，只要比当前数小，说明他可以作为终点 因为已经记录了之前数作为终点的序列长度，让序列长度+1就可以 再做下对比，公式如下  max(dp[i],dp[j]+1) 得到所有序列作为终点的最长子序列长度数组以后，遍历下取最值就好了\n代码： golang\n1143.最长公共子序列 #  题目： 求两个数组的最长公共子序列长度\n题解：\n  用二维数组dp记录最长公共子序列长度，dp[i][j] 为当前位置最长公共子序列长度，状态转移方程\n// 其中因为当前字符相等，所以长度各减1的dp[i-1][j-1]表示没有当前字符时字符串的最长公共子序列长度 // 也就是加入text1长度为i，text2长度为j，i j 就是当前长度的最长公共子序列,i-1 j 代表长度为i-1的字符串与j的字符串公共子序列长度 if text1[i] == text2[j] then dp[i][j] = dp[i-1][j-1] + 1 // 长度不一样时对比各自长度-1，作为当前长度最长公共子序列 if text1[i] != text2[j] then dp[i][j] = max(dp[i-1][j],dp[i][j-1])   注意：i-1 和 j-1 会越界，申明时让dp行列len+1\n代码： golang\n59.螺旋矩阵-ii #  题目： 给一个数字n，输出n*n的正方形螺旋矩阵\n题解：生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：\n 定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n； 当 num \u0026lt;= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：  执行 num += 1：得到下一个需要填入的数字； 更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。   使用num \u0026lt;= tar而不是l \u0026lt; r || t \u0026lt; b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。  最终返回 mat 即可。\n 题解来源\n代码： golang\n搜索二维矩阵 #  题目： 递增的二维矩阵，搜索值是否在内部\n题解：方法1，简单搜索\n 以二维数组左下角为原点，建立直角坐标轴。 若当前数字大于了查找数，查找往上移一位。 若当前数字小于了查找数，查找往右移一位。   题解来源\n方法2，二分搜索（独创）\n既然列递增，且行递增，下一行所有数字都比上一行大，可以把二维数组拼接起来，视为递增的一纬度数组来处理\n 取行列长度n1 n2，得到全局数字个数n1*n2 使用二分法，取数字时，mid/n2为行，mid%n2为列即可   我的题解\n代码： golang\n最后 #  如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群\n我是小熊，关注我，知道更多不知道的技术\n "},{"id":8,"href":"/leetcode/other/","title":"Other","section":"LeetCodes","content":"其他高频算法 #  其他高频 #  medium #  120.三角形最小路径和 #  题目： 求三角形的最小路径和\n要求是每一步只能找下一行的相邻节点，也就是当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 题解：从三角形底部向上遍历\n[ [2], [3,4], [6,5,7], [4,1,8,3] ] 相邻结点：与(i, j) 点相邻的结点为 (i + 1, j) 和 (i + 1, j + 1)。  用一个一维度数组dp [n+1]int来存储最终结果，保证每个值都是最优解 方程 min(dp[j],dp[j+1]) + triangle[i][j]  注意：\n代码： golang\n引用： 递归+记忆化+DP\ndifficult #  题目：\n题解：\n注意：\n代码： golang\n"},{"id":9,"href":"/leetcode/readme/","title":"Readme","section":"LeetCodes","content":"面试算法 #  介绍 #  这里是所有的算法题目，建议先刷hot100再刷剑指Offer\n请直接点击相应目录查看\n最后 #  如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群\n"},{"id":10,"href":"/leetcode/shu-ju-jie-gou/","title":"Shu Ju Jie Gou","section":"LeetCodes","content":"数据结构 #  树 #  基本概念 #   树有多个节点(node)，用以储存元素 节点之间的连线称为边(edge) 边的上端节点称为父节点 下端称为子节点 树的深度(depth)是从根节点开始（其深度为1）自顶向下逐层累加的 高度的定义为：从结点x向下到某个叶结点最长简单路径中边的条数 深度是从根节点往下  二叉树 #  常见的二叉树：完全二叉树，满二叉树，二叉搜索树，二叉堆，AVL 树，红黑树，哈夫曼树\n 完全二叉树：若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边（效率高） 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树 二叉搜索树（二叉排序树，二叉查找树）  树中每个节点最多有两个子树，通常称为左子树和右子树 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 它的左右子树仍然是一棵二叉搜索树 (recursive)   平衡树(B树)  排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则； 子节点数：1\u0026lt;非叶节点的子节点数\u0026lt;=M ，且M\u0026gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路, 当M=2则是2叉树, M=3则是3叉） 关键字数：ceil(m/2)-1\u0026lt;=枝节点的关键字数量\u0026lt;=M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2); 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子   B+树  特点  B+树的非叶子节点不保存关键字记录的指针，只进行数据索引（非叶子节点所能保存的关键字大大增加） B+树叶子节点保存父节点的所有关键字记录的指针，数据地址必须要到叶子节点才能获取到（每次数据查询的次数都一样） B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针 非叶子节点的子节点数=关键字数（两种实现，或：非叶节点的关键字数=子节点数-1。Mysql 的B+树是第一种）   与红黑树的比较（访问磁盘数据有更高的性能）   B+ 树有更低的树高\n  磁盘访问原理：操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取\n  为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入\n     平衡二叉树（AVL 树）：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 红黑树  黑色完美平衡：任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点    缓存淘汰策略LRU( Least Recently Used) #   如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。 哈希表+双向链表实现 使用哈希表存储 key，值为链表中的节点，节点中存储值，双向链表来记录节点的顺序，头部为最近访问节点。 **LRU**算法中有两种基本操作  get(key)：查询key对应的节点，如果key存在，将节点移动至链表头部。 set(key, value)： 设置key对应的节点的值。如果key不存在，则新建节点，置于链表开头。如果链表长度超标，则将处于尾部的最后一个节点去掉。如果节点存在，更新节点的值，同时将节点置于链表头部。    "},{"id":11,"href":"/leetcode/suan-fa-mian-shi-zhu-yi/","title":"Suan Fa Mian Shi Zhu Yi","section":"LeetCodes","content":"算法面试注意 #  算法思维 #   进入函数优先考虑边界 如果出现循环，进入循环时考虑break条件和continue条件 使用下标计算长度时，优先考虑区间的开闭 我们应该在做算法的过程总不断的思考和总结共性  面试注意 #  一定要记得常用的函数，现场是没有办法可以查的\n 字符串去左右空格 字符串切割 随机数种子，随机数生成 内置排序函数 int最小值最大值怎么取  以go为例\ns = strings.TrimSpace(s) arr := strings.Split(s,\u0026#34;\u0026#34;) rand.Seed(time.Now().UnixNano()) rand.Int() sort.Int() sort.Slice(x,func(i,j int)bool{ // 降序  return x[i]\u0026gt;x[j] }) math.MaxInt32 math.MinInt32 牛客网面试注意 #  牛客网比较坑，一切输入输出都要自己实现\n还要劳记链表创建代码， 完整代码\npackage main import( \u0026#34;fmt\u0026#34; ) type LinkNode struct{ Val int Next *LinkNode } func createNode(a []int) *LinkNode{ head :=\u0026amp;LinkNode{ 0, nil, } prev := head for i:=0;i\u0026lt;len(a);i++{ node := \u0026amp;LinkNode{ a[i], nil, } prev.Next = node prev = node } return head.Next } 同时要牢记二叉树的创建代码， 完整代码\ntype BTnode struct { Val int Left *BTnode Right *BTnode } func createTree(a []int) *BTnode { if len(a) == 0 || len(a)%2 == 0 { return nil } root := \u0026amp;BTnode{ a[0], nil, nil, } stack := []*BTnode{root} i := 1 for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; i \u0026lt; len(a){ node := stack[0] stack = stack[1:] node.Left = \u0026amp;BTnode{a[i], nil, nil} node.Right = \u0026amp;BTnode{a[i+1], nil, nil} stack = append(stack, node.Left) stack = append(stack, node.Right) i = i + 2 } return root } 常用排序算法 #  常用排序算法在某些公司是会问到的，思路和时间复杂度如果都不知道，对结果的冲击是很大的\n   排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性     冒泡排序 O(n²) O(n²) O(n) O(1) 稳定   直接选择排序 O(n²) O(n²) O(n) O(1) 不稳定   直接插入排序 O(n²) O(n²) O(n) O(1) 稳定   快速排序 O(nlogn) O(n²) O(nlogn) O(nlogn) 不稳定   堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定   希尔排序 O(nlogn) O(ns) O(n) O(1) 不稳定   归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定   计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定   基数排序 O(N*M) O(N*M) O(N*M) O(M) 稳定    "},{"id":12,"href":"/mysql/%E4%B8%BB%E4%BB%8E/mysql%E7%9A%84expire_logs_days%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%BB%E4%BB%8E%E7%8A%B6%E6%80%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/","title":"Mysql的expire Logs Days参数引发的主从状态丢失问题","section":"Mysqls","content":"我在测试主从方案的时候发现状态丢失了，同步用的binlog也不见了(binlog doesn\u0026rsquo;t exist)，非常奇怪，回顾解决以后写在这里供大家参考。\n报错与原因 #  发现错误信息类似于\nSlave: Table 'XXX' doesn't exist Error running query, ......，We stopped at log 'mysql-bin.000036' position 154. 赶快去找，本想看看主数据的这个文件的position 154是什么语句，使用语句\nshow binlog events in \u0026#39;mysql-bin.000036\u0026#39; 居然返回了502。\n又到主库的服务器查看了下binlog的存储情况，发现binlog的编号是从36开始的，前面的不见了！难道设置了参数定期删除binlog？\n于是又来到了my.cnf文件，查看文件之后找到了一个expire_logs_days。经搜索，确定了这个参数就是删除以前binlog文件的“罪魁祸首”。\n到这来，大概明白了为啥主从同步没有成功，因为这是基于binlog的（逐行扫描sql语句进行同步写入），如果binlog文件不全，就无法正确的进行主从同步。\n解决办法 #  这种情况从删除那一天起，至今所有的同步语句全部都丢失了，所以除非可以精确的知道执行了哪些语句，或者那些语句都不重要可以忽略，不然都必须要清理数据库，备份主库，重新手动更新从库来解决。可以参考我的 备份数据库这篇文章的。\n如果你精确的知识执行了哪些语句，需要先停止从库，执行丢失的语句，再进行从库同步设置。\nmysql\u0026gt; stop slave; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u0026gt; reset slave; Query OK, 0 rows affected (0.00 sec) .....执行你的语句 mysql\u0026gt; change master to master_host=\u0026#39;192.168.1.51\u0026#39;, master_user=\u0026#39;replslave\u0026#39;, master_password=\u0026#39;replslave\u0026#39;, master_log_file=\u0026#39;mysql-bin-000002\u0026#39;,master_log_pos=168; Query OK, 0 rows affected (0.11 sec) 如果不知道怎进行从库同步设置，请参考 mariadb/mysql建立主从\n小结 #  1.根据情况设置expire_logs_days，位于mariadb的配置文件中，意思是超时天数，超过这个数值就清理掉过期的binlog 2.还有一个参数叫max_binlog_size，默认是1G，如果设置的太小可能导致大事物被截断，保持默认就好。\n参考： mysql的expire_logs_days参数引发的问题\n"},{"id":13,"href":"/mysql/%E4%B8%BB%E4%BB%8E/relaylog/","title":"Relaylog","section":"Mysqls","content":"前言：MySQL进行主主复制或主从复制的时候会在home目录下面产生相应的relay log，本文档总结这些相关参数的定义及解释.\n1、什么是relay log #   The relay log, like the binary log, consists of a set of numbered files containing events that describe database changes, and an index file that contains the names of all used relay log files. The term \u0026ldquo;relay log file\u0026rdquo; generally denotes an individual numbered file containing database events. The term\u0026quot;relay log\u0026quot; collectively denotes the set of numbered relay log files plus the index file\n 来源： 官网文档\n理解：relay log很多方面都跟binary log差不多。\n区别是：从服务器I/O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致\n2、relay log的相关参数说明 #  通过语句：show variables like '%relay%'``，查看查询到relay`的所有相关参数\nmysql\u0026gt; show variables like \u0026#39;%relay%\u0026#39;; +-----------------------+----------------+  | Variable_name | Value | +-----------------------+----------------+  | max_relay_log_size | relay_log | relay_log_basename | relay_log_index | relay_log_info_file | relay_log_info_repository | relay_log_purge | relay_log_recovery | relay_log_space_limit | sync_relay_log | sync_relay_log_info +-----------------------+----------------+ 参数详细解释：\nmax_relay_log_size\n标记relay log 允许的最大值，如果该值为0，则默认值为max_binlog_size(1G)；如果不为0，则max_relay_log_size则为最大的relay_log文件大小；\nrelay_log\n定义relay_log的位置和名称，如果值为空，则默认位置在数据文件的目录（datadir），文件名为host_name-relay-bin.nnnnnn（By default, relay log file names have the form host_name-relay-bin.nnnnnn in the data directory）；\nrelay_log_index\n同relay_log，定义relay_log的位置和名称；一般和relay-log在同一目录\nrelay_log_info_file\n设置relay-log.info的位置和名称（relay-log.info记录MASTER的binary_log的恢复位置和relay_log的位置）\nrelay_log_purge\n是否自动清空不再需要中继日志时。默认值为1(启用)。\nrelay_log_recovery\n当slave从库宕机后，假如relay-log损坏了，导致一部分中继日志没有处理，则自动放弃所有未执行的relay-log，并且重新从master上获取日志，这样就保证了relay-log的完整性。默认情况下该功能是关闭的，将relay_log_recovery的值设置为 1时，可在slave从库上开启该功能，建议开启。\nrelay_log_space_limit\n防止中继日志写满磁盘，这里设置中继日志最大限额。但此设置存在主库崩溃，从库中继日志不全的情况，不到万不得已，不推荐使用；\nsync_relay_log\n这个参数和sync_binlog是一样的，\n当设置为1时，slave的I/O线程每次接收到master发送过来的binlog日志都要写入系统缓冲区，然后刷入relay log中继日志里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量I/O。\n当设置为0时，并不是马上就刷入中继日志里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘I/O操作。这个值默认是0，可动态修改，建议采用默认值。\nsync_relay_log_info\n这个参数和sync_relay_log参数一样，当设置为1时，slave的I/O线程每次接收到master发送过来的binlog日志都要写入系统缓冲区，然后刷入relay-log.info里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量I/O。当设置为0时，并不是马上就刷入relay-log.info里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘I/O操作。这个值默认是0，可动态修改，建议采用默认值。\n总结 #  以上只是简单的介绍了每个参数的作用，这些参数具体的设置还是需要根据每个用户的实际系统情况进行设置的；\n推荐从库线上环境使用以下配置\n#slave replicate-do-db=cloud log-slave-updates replicate-wild-do-table=cloud.% binlog-ignore-db=mysql slave-skip-errors=1032,1062,1053,1146,2003 #relay log max_relay_log_size = 0； relay_log=$datadir/relay-bin relay_log_purge = 1; relay_log_recovery = 1; sync_relay_log =0； sync_relay_log_info = 0；  cloud是库名，用于跨库同步，如果有多个用逗号隔开 如果是mha环境，则| relay_log_purge 不要开启，设置为0，可以使用 purge_relay_logs 来定期清除  本站整理自：https://blog.51cto.com/douya/1788753\n"},{"id":14,"href":"/mysql/%E4%B8%BB%E4%BB%8E/%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/","title":"主从切换","section":"Mysqls","content":"[TOC]\n1、主库停止应用，确认主库不再有数据生成 #  将主库改为 read_only 模式\nmysql\u0026gt; set global super_read_only=on; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; set global read_only=on; Query OK, 0 rows affected (0.00 sec) 2、查看主备库数据是否一致 #  主库：\nmysql\u0026gt; show master status; +------------------+----------+--------------+------------------+-----------------------------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-----------------------------------------------+ | mysql-bin.000012 | 195 | | | 8876d804-9218-11e8-8eaf-0242ac110002:1-224227 | +------------------+----------+--------------+------------------+-----------------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt; select @@server_uuid; +--------------------------------------+ | @@server_uuid | +--------------------------------------+ | 8876d804-9218-11e8-8eaf-0242ac110002 | +--------------------------------------+ 1 row in set (0.00 sec) 备库\nmysql\u0026gt; show slave status \\G *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 172.17.0.2 Master_User: repl Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000012 Read_Master_Log_Pos: 195 Relay_Log_File: relaylog.000018 Relay_Log_Pos: 409 Relay_Master_Log_File: mysql-bin.000012 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 195 Relay_Log_Space: 672 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 23306 Master_UUID: 8876d804-9218-11e8-8eaf-0242ac110002 Master_Info_File: mysql.slave_master_info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: 8876d804-9218-11e8-8eaf-0242ac110002:1-224227 Executed_Gtid_Set: 8876d804-9218-11e8-8eaf-0242ac110002:1-224227, febb1cb0-922f-11e8-ba72-0242ac110003:1-2 Auto_Position: 1 Replicate_Rewrite_DB: Channel_Name: mysq57-3306 Master_TLS_Version: Master_public_key_path: Get_master_public_key: 0 1 row in set (0.00 sec) #Retrieved_Gtid_Set ，Executed_Gtid_Set这2个值是否和主库的Executed_Gtid_Set 值相等，如果相等，则代表一致 3、备库: 停止 io_thread 和 sql_thread #  mysql\u0026gt; stop slave; Query OK, 0 rows affected (0. 11 sec) 4、备库：记录 binlog 的 POS #  mysql\u0026gt; show master status; +------------------+-----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+-----------+--------------+------------------+-------------------+ | master2-bin. 001 | 162644437 | | | | +------------------+-----------+--------------+------------------+-------------------+ 1 row in set (0. 00 sec) mysql\u0026gt; flush logs; mysql\u0026gt; show master status; +------------------+-----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+-----------+--------------+------------------+-------------------+ | master2-bin. 002 | 163266389 | | | | +------------------+-----------+--------------+------------------+-------------------+ 1 row in set (0. 00 sec) 5、将备库只读模式关闭 #  mysql\u0026gt; show global variables like \u0026#39;%read_only%\u0026#39;; +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | innodb_read_only | OFF | | read_only | ON | | super_read_only | ON | | transaction_read_only | OFF | +-----------------------+-------+ 4 rows in set (0. 01 sec) mysql\u0026gt; set global super_read_only=off; Query OK, 0 rows affected (0. 00 sec) mysql\u0026gt; set global read_only=off; Query OK, 0 rows affected (0. 00 sec) mysql\u0026gt; show global variables like \u0026#39;%read_only%\u0026#39;; +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | innodb_read_only | OFF | | read_only | OFF | | super_read_only | OFF | | transaction_read_only | OFF | +-----------------------+-------+ 4 rows in set (0. 00 sec) 6、新备库执行 change master to 语句, 指向新主库 #  CHANGE MASTER 分 2 种情况，一种是开启了 GTID 模式，一种是未开启 GTID 模式\nGTID 模式:\nCHANGE MASTER TO MASTER_HOST=\u0026#39;oracle2.example.com\u0026#39;, MASTER_USER=\u0026#39;repl\u0026#39;, MASTER_PASSWORD=\u0026#39;password\u0026#39;, MASTER_PORT=3306, MASTER_AUTO_POSITION=1; 未开启 GTID 模式\nCHANGE MASTER TO MASTER_HOST=\u0026#39;oracle2.example.com\u0026#39;, MASTER_USER=\u0026#39;repl\u0026#39;, MASTER_PASSWORD=\u0026#39;password\u0026#39;, MASTER_PORT=3306, MASTER_LOG_FILE=\u0026#39;master2-bin. 002\u0026#39;, MASTER_LOG_POS=163266389; "},{"id":15,"href":"/mysql/%E4%B8%BB%E4%BB%8E/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/","title":"常见故障","section":"Mysqls","content":"【ERROR】1452:无法在外键的表插入或更新参考主键没有的数据。 #  主键在从库不存在时会发生这样的问题，报1452错误。此时可以检查参考的表的主键是否有主库对应的数据，如果有，则插入参考的表相应的数据，再开启复制恢复SQL线程。\n【ERROR】1032:删除或更新从库的数据，从库找不到记录。 #  此时，主库的数据是比从库新的，可以采取从库添加相同的数据再开启复制恢复SQL线程。\n【ERROR】1062:从库插入数据，发生唯一性冲突。 #  此时从库已经有相同主键的数据，如果再插入相同主键值的数据则会报错。可以查看主库的改行数据与从库的要插入数据是否一致，如一致则跳过错误，恢复SQL线程，如不一致，则以主库为准，将从库的该行记录删除，再开启复制。\n【ERROR】1201: Could not initialize master info structure. #  出现这个错误的原因是因为从库之前已经做过主从复制,所以需要先停止从库，再进行从库同步设置。\n具体的解决方法如下：\nmysql\u0026gt; change master to master_host=\u0026#39;192.168.1.51\u0026#39;, master_user=\u0026#39;replslave\u0026#39;, master_password=\u0026#39;replslave\u0026#39;, master_log_file=\u0026#39;mysql-bin-000002\u0026#39;,master_log_pos=168; ERROR 1201 (HY000): Could not initialize master info structure; more error messa ges can be found in the MySQL error log mysql\u0026gt; stop slave; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u0026gt; reset slave; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; change master to master_host=\u0026#39;192.168.1.51\u0026#39;, master_user=\u0026#39;replslave\u0026#39;, master_password=\u0026#39;replslave\u0026#39;, master_log_file=\u0026#39;mysql-bin-000002\u0026#39;,master_log_pos=168; Query OK, 0 rows affected (0.11 sec) 方法来自： CSU-Max\n"},{"id":16,"href":"/mysql/%E4%B8%BB%E4%BB%8E/%E5%BB%BA%E7%AB%8B%E4%B8%BB%E4%BB%8E/","title":"建立主从","section":"Mysqls","content":"前提 #  本方案是两节点主从方案，只要建立好主从，及时数据库挂掉又拉起主从模式不会失效。\n 保证时间同步 保证都安装了mysql/mariadb  建立主从的过程 #  这里介绍的是两节点主从，如果是集群模式，至少需要三个节点，因为偶数个节点是导致脑裂高发的原因（无法确定该同步谁的）。\n 主从服务器节点设置不同的server-id 启用二进制日志和relaylog 主节点创建一个拥有复制权限的用户账号 查询主节点binlog信息 设置从节点同步主节点  停止所有写入 #  在所有服务器上执行此步\n在所有服务器上执行此步\n在所有服务器上执行此步\n停止所有写入是为了防止数据设置同步的过程中数据不一致。\n如果 mariadb 是通过 hosts 文件中的域名进行访问的，那么只需要编辑 /etc/hosts , 把mysql的域名解析删掉就可以停止所有读写，执行以下命令。\n关掉所有读写mysql的服务，你也可以直接用iptables来禁用端口通信（如果应用有自动重连机制的话，否则只能重启应用了）\n等待 1 分钟，依次进入集群中所有的 mariadb ，查看进程状态，确保没有额外的读写操作( command 列除了 show processlist 外没有多余的 sleep 和 query )。\nMariaDB [(none)]\u0026gt; show processlist; 备份与导入 #  首先，你需要保证所有的节点数据一致，在升级过程中万一升级失败能及时的恢复数据。\n请参考本小册 备份数据库\n添加一个专门用来同步的用户 #  在从节点中的 mariadb 执行以下命令，如果全部输出 ok，则继续。\n/usr/local/mariadb/bin/mysql -A -e \u0026#34;GRANT replication slave ON *.* TO \u0026#39;rep\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; flush privileges;\u0026#34; mysql -A -urep -p123456 -e \u0026#34;select \u0026#39;ok\u0026#39;;\u0026#34; 停止所有节点 #  执行以下命令停止\n/usr/local/mariadb/bin/mysqladmin shutdown 此时节点应该自动停止了，检查是否没有 mariadb 和 mysql 进程，如果有按需求判断是否停掉(kill)。\nps -ef | grep -E \u0026#34;mariadb|mysql\u0026#34; 更新 mysql 配置（从节点） #  先创建relaylog日志存储的目录，用来防止同步波动缓存同步信息。（注意，请设置成你自己的数据目录）\nmkdir /data/mariadb/relaylog chown -R mysql.mysql /data/mariadb/relaylog/ 添加配置到 [mysqld] 配置节中（注意现在不启动），该配置表示我们只同步 cloud 库和其下的表，如果要同步更多的库和表可以用逗号分隔，追加。\n如果想了解各个参数是什么含义可以到本小册 relaylog里看\nvim /etc/my.cnf.d/server.cnf # 添加内容如下 replicate-do-db=cloud #cloud是你想同步的库名，如果有多个请用逗号隔开 log-slave-updates replicate-wild-do-table=cloud.% #cloud是你想同步的库名，cloud.% 代表这个库下面的所有表，如果有多个请用逗号隔开 binlog-ignore-db=mysql # 忽略mysql库 max_relay_log_size = 0 relay_log=/data/mariadb/relaylog/relay-bin #请设置成正确的目录，上面刚刚创建的那个，最后的relay-bin是文件前缀 relay_log_purge = 1 relay_log_recovery = 1 sync_relay_log =0 sync_relay_log_info = 0 slave-skip-errors=1032,1062,1053,1146,2003 参考添加成功的图片\n 启动主节点并获取主节点信息 #  如果你的目录不同请自行修改\nmkdir -p /var/run/mariadb; chown -R mysql:mysql /var/run/mariadb; /usr/local/mariadb/bin/mysqld_safe --datadir=/data/mariadb/data --pid-file=/var/run/mariadb/mariadb.pid \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 获取同步主节点的关键信息\n进入主节点数据库中，执行命令\nunlock tables; show master status; 得到同步主节点的关键信息\n 启动从节点并设置同步信息 #  mkdir -p /var/run/mariadb; chown -R mysql:mysql /var/run/mariadb; /usr/local/mariadb/bin/mysqld_safe --datadir=/data/mariadb/data --pid-file=/var/run/mariadb/mariadb.pid \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 建立主从结构\n进入从节点的数据库，指定主库信息，完成主从关系建立（注意：下面命令中的【主节点 ip 地址】别忘记替换，使用 eth0 本地网卡的 ip ，不要使用浮动 ip ，也不要使用 vip ）\n账号和密码就是我们刚刚设置的，\nunlock tables; CHANGE MASTER TO MASTER_HOST=\u0026#39;主节点的ip地址\u0026#39;, MASTER_PORT=3306, MASTER_USER=\u0026#39;rep\u0026#39;, MASTER_PASSWORD=\u0026#39;123456\u0026#39;, MASTER_LOG_FILE=\u0026#39;mysql-bin.000171\u0026#39;, MASTER_LOG_POS=33105258; start slave; #开始同步 查看 slave 的状态，注意查看 slave 的进程状态，下面红色方框中圈起来的是两个 Yes 就表示状态正常了，注意等待主库复制的延迟秒数变为 0 Seconds_Behind_Master: 0\nshow slave status \\G  the end\n可能遇到的坑 #  请根据你的业务写入速度和同步速度，设置好主节点的binlog大小和过期时间，具体设置方法请参考本小册 mysql 正确清理 binlog 日志的两种方法中的方法二、通过设置 binlog 过期的时间，使系统自动删除 binlog 文件。\n如果你想建立互为主从 #  如果你想建立互为主从，那么你可以把主节点当作从节点，把从节点当作主节点，从本文的\n 添加一个专门用来同步的用户开始重新执行，直到最后一步。\n"},{"id":17,"href":"/mysql/%E4%B8%BB%E4%BB%8E/%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%88%87%E6%8D%A2%E4%B8%BA%E4%BA%92%E4%B8%BA%E4%B8%BB%E4%BB%8E/","title":"集群方案切换为互为主从","section":"Mysqls","content":"文档目标 #  由于集群模式容易出现脑裂，恢复起来速度慢，难度大，不稳定，所以采用主从模式托管，容易恢复，更加稳定，同时建立成功主从模式以后，及时关机再重启也不会丢失主从状态。\n通过本文档可以把mariadb或mysql从三节点集群模式切换为互为主从（成环）\n 相对于集群的好处就是不会发生脑裂，故障恢复相对比较容易 坏处是如果挂掉一个节点时，剩下的两个节点就会变成主从模式，如果应用读写到从节点，那么数据就不同步了，需要等待恢复以后才能自动同步（所以我们要控制，挂掉一个节点后，让读写正确的切换到主节点上，可能要keepalived、haproxy的配合）  [TOC]\n0、检查是否是集群状态 #  ps: 监测当前是否是集群模式, 而且整个集群的所有服务器正常，如果不是 ON ，则停止操作，并联系管理员。\n在集群中所有服务器上执行\nMariaDB [(none)]\u0026gt; show global variables like \u0026#39;%wsrep_on%\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | wsrep_on | ON | +---------------+-------+ 1 row in set (0.00 sec) 1、停止所有写入 #  在集群所有服务器上执行此步\n在集群所有服务器上执行此步\n在集群所有服务器上执行此步\n如果 mariadb 是通过 hosts 文件中的域名进行访问的，那么只需要编辑 /etc/hosts , 把 mysql.cloud.local 的域名解析删掉就可以停止所有读写，执行以下命令。\ncp /etc/hosts /etc/hosts.bak sed -i \u0026#34;/mysql.cloud.local/d\u0026#34; /etc/hosts 等待1分钟，依次进入集群中所有的 mariadb ，查看进程状态，确保没有额外的读写操作( command 列除了 show processlist 外没有多余的 sleep 和 query )。\nMariaDB [(none)]\u0026gt; show processlist; 2、添加一个专门用来同步的用户 #  在节点1中的 mariadb 执行以下命令，如果全部输出ok，则继续。\n/usr/local/mariadb/bin/mysql -A -e \u0026#34;GRANT replication slave ON *.* TO \u0026#39;rep\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; flush privileges;\u0026#34; mysql -A -urep -p123456 -e \u0026#34;select \u0026#39;ok\u0026#39;;\u0026#34; 依次在第二台、第三台上重复此操作\n3、设置所有集群中的节点为只读。 #  进入节点1中的 mariadb 执行以下命令\nflush table with read lock; 依次在第二台、第三台上顺序重复此操作\n4、停止集群 #  如果你使用的是supervisor守护mariadb，则\nsupervisorctl stop mariadb 如果你使用的是systemctl托管，则\nsystemctl stop mariadb 此时节点应该自动停止了，检查是否没有 mariadb 和 mysql 进程，如果有按需求判断是否停掉。\nps -ef | grep -E \u0026#34;mariadb|mysql\u0026#34; 如果没有停止，则执行以下命令停止\n/usr/local/mariadb/bin/mysqladmin shutdown 依次在第二台、第三台上顺序重复 4、停止集群操作\n5、配置集群中每个节点为单点 #  执行下面命令改为单点（注意现在不启动），执行完检查是不是变成了 wsrep_on=OFF\nsed -i \u0026#34;s/^wsrep_on=.*/wsrep_on=OFF/g\u0026#34; /etc/my.cnf.d/server.cnf 创建relaylog日志存储的目录，用来防止同步波动缓存同步信息。\nmkdir /data/mariadb/relaylog chown -R mysql.mysql /data/mariadb/relaylog/ 添加配置到 [mysqld] 配置节中（注意现在不启动），该配置表示我们只同步 cloud 库和其下的表，如果要同步更多的库和表可以用逗号分隔，追加。\n如果想了解各个参数是什么含义可以到本小册 relaylog里看\nvim /etc/my.cnf.d/server.cnf # 添加内容如下 replicate-do-db=cloud #cloud是你想同步的库名，如果有多个请用逗号隔开 log-slave-updates replicate-wild-do-table=cloud.% #cloud是你想同步的库名，cloud.% 代表这个库下面的所有表，如果有多个请用逗号隔开 binlog-ignore-db=mysql # 忽略mysql库 max_relay_log_size = 0 relay_log=/data/mariadb/relaylog/relay-bin #请设置成正确的目录，上面刚刚创建的那个，最后的relay-bin是文件前缀 relay_log_purge = 1 relay_log_recovery = 1 sync_relay_log =0 sync_relay_log_info = 0 slave-skip-errors=1032,1062,1053,1146,2003 参考添加成功的图片\n 依次在第二台、第三台上顺序重复 5、配置集群中每个节点为单点操作\n6、建立 2同步3 主从结构 #  假如是三节点主从，我们使用 1同步2 ， 2同步3 , 3同步1 的方案，现在三台机器上的 mariadb 都是停止状态的。\n2同步3 ，所以 3 是主节点， 2 是从节点。\n逆序启动，并建立主从\n启动节点3\nmkdir -p /var/run/mariadb; chown -R mysql:mysql /var/run/mariadb; /usr/local/mariadb/bin/mysqld_safe --datadir=/data/mariadb/data --pid-file=/var/run/mariadb/mariadb.pid \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 获取同步主节点的关键信息\n进入主【节点3】数据库中，执行命令\nunlock tables; show master status; 得到同步主节点的关键信息\n 启动节点2\nmkdir -p /var/run/mariadb; chown -R mysql:mysql /var/run/mariadb; /usr/local/mariadb/bin/mysqld_safe --datadir=/data/mariadb/data --pid-file=/var/run/mariadb/mariadb.pid \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 建立主从结构\n进入从【节点2】中的数据库，指定主库信息，完成主从关系建立（注意：节点3的ip地址别忘记替换，使用 eth0 本地网卡的 ip ，不要使用浮动 ip ，也不要使用 vip ）\nunlock tables; CHANGE MASTER TO MASTER_HOST=\u0026#39;节点3的ip地址\u0026#39;, MASTER_PORT=3306, MASTER_USER=\u0026#39;rep\u0026#39;, MASTER_PASSWORD=\u0026#39;123456\u0026#39;, MASTER_LOG_FILE=\u0026#39;mysql-bin.000171\u0026#39;, MASTER_LOG_POS=33105258; start slave; #开始同步 查看slave的状态，注意查看slave的进程状态，下面红色方框中圈起来的是两个 Yes 就表示状态正常了，注意等待主库复制的延迟秒数变为0 Seconds_Behind_Master: 0\nshow slave status \\G  7、测试 2同步3 主从同步状态 #  进入主节点3的数据库中，执行sql命令，创建一个测试表。\nuse cloud; CREATE TABLE IF NOT EXISTS `testrep` ( `xx_id` INT UNSIGNED AUTO_INCREMENT, PRIMARY KEY ( `xx_id` ) )ENGINE=InnoDB DEFAULT CHARSET=utf8; show tables like \u0026#34;testrep\u0026#34;; 结果如下则创建成功\nMariaDB [cloud]\u0026gt; show tables like \u0026#34;testrep\u0026#34;; +---------------------------+ | Tables_in_cloud (testrep) | +---------------------------+ | testrep | +---------------------------+ 1 row in set (0.00 sec) 进入从节点2的数据库上，再执行查询命令查看同步状态，如果同上面结果一样则表示主从建立成功\nuse cloud; show tables like \u0026#34;testrep\u0026#34;; 8、建立 1同步2 主从结构 #  同上面类似，只不过是在 1 和 2 节点上执行而已。\n要注意四个点！！！\n 重复 6 和 7 两步，把【主节点3】和【从节点2】换成【主节点2】和【从节点1】 注意此时节点2已经启动了 不要再重复启动节点 unlock tables; 重复执行无所谓 步骤【 7 主从同步状态】不要再重复创建测试表了，主从建立成功后直接查看【从节点 1 】中是否有 testrep 表就可以了  9、建立 3同步1 主从结构 #  同上面类似，只不过是在 3 和 1 节点上执行而已。\n要注意四个点！！！\n 重复 1.6 即可，把【主节点3】和【从节点2】换成【主节点1】和【从节点3】 注意此时所有节点都已经启动了 不要再重复启动节点  测试同步状态\n在节点1上执行命令\nMariaDB [(none)]\u0026gt; use cloud; Database changed MariaDB [cloud]\u0026gt; drop table testrep; Query OK, 0 rows affected (0.01 sec) MariaDB [cloud]\u0026gt; show tables like \u0026#34;testrep\u0026#34;; Empty set (0.00 sec) 在节点3和节点2和执行以下命令，如果结果都是 Empty set ，表示三节点主从模式建立成功。\nMariaDB [cloud]\u0026gt; show tables like \u0026#34;testrep\u0026#34;; Empty set (0.00 sec) 10、恢复域名解析 #  在全部服务器上执行\ncp /etc/hosts.bak /etc/hosts "},{"id":18,"href":"/mysql/%E8%BF%90%E7%BB%B4/mysql%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86binlog%E6%97%A5%E5%BF%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/","title":"Mysql正确清理binlog日志的两种方法","section":"Mysqls","content":"前言 #  MySQL 中的 binlog 日志记录了数据库中数据的变动，便于对数据的基于时间点和基于位置的恢复，但是 binlog 也会日渐增大，占用很大的磁盘空间，因此，要对 binlog 使用正确安全的方法清理掉一部分没用的日志\n方法一、手动清理 binlog #  清理前的准备：\n查看主库和从库正在使用的 binlog 是哪个文件\nshow master status \\G show slave status \\G 在删除 binlog 日志之前，首先对 binlog 日志备份，以防万一\n开始动手删除 binlog： 删除指定日期以前的日志索引中 binlog 日志文件\npurge master logs before\u0026#39;2016-09-01 17:20:00\u0026#39;; 或 删除指定日志文件的日志索引中 binlog 日志文件\npurge master logs to\u0026#39;mysql-bin.000022\u0026#39;;  注意：时间和文件名一定不可以写错，尤其是时间中的年和文件名中的序号，以防不小心将正在使用的 binlog 删除！！！\u0026gt; 切勿删除正在使用的 binlog！！！ 使用该语法，会将对应的文件和 mysql-bin.index 中的对应路径删除。\n方法二、通过设置 binlog 过期的时间，使系统自动删除 binlog 文件 #  临时生效\nmysql\u0026gt; show variables like \u0026#39;expire_logs_days\u0026#39;; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | expire_logs_days | 0 | +------------------+-------+ mysql\u0026gt; set global expire_logs_days = 30; #设置binlog多少天过期 长期生效需要修改配置文件\nvim /etc/my.cnf 内容 expire_logs_days=3 #代表3天 max_binlog_size = 1073741824 #默认是1G 注意：\n过期时间设置的要适当，对于主从复制，要看从库的延迟决定过期时间，避免主库 binlog 还未传到从库便因过期而删除，导致主从不一致！！！\n本站整理自： mysql 正确清理 binlog 日志的两种方法\n"},{"id":19,"href":"/mysql/%E8%BF%90%E7%BB%B4/%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"备份数据库","section":"Mysqls","content":"备份数据库 #  主库锁表\nflush table with read lock; 备份数据库（会有压缩，测试数据 11G，得到备份文件 227M）\n 其中 max_allowed_packet 和 net_buffer_length 两个参数是用来加速的，可以查看从库数据 如果 root 有密码请加上参数例如 -uroot -proot   /usr/local/mariadb/bin/mysqldump --max_allowed_packet=33554432 --net_buffer_length=8192 --events -A -B |gzip \u0026gt;/server/backup/mysql_bak.$(date +%F).sql.gz PS: 如果上面的命令报错如下\nCouldn\u0026#39;t execute \u0026#39;show events\u0026#39;: Cannot proceed because system tables used by Event Scheduler were found damaged at server start (1577) 请执行命令(如果 root 有密码请加上参数例如 -uroot -proot )\n/usr/local/mariadb/bin/mysql_upgrade 备份结束后，解锁主库，恢复读写\nunlock tables; 拷贝到从库中\n 注意日期一定有所不同，如果端口不是默认的请叫参数 -P 端口号 注意确保 /root 目录有足够的空间，如果空间不够请切换目录  scp /server/backup/mysql_bak.2020-06-04.sql.gz monitor-host02:/root 从库 #  进入备份文件目录，解压(11G 的库，sql 文件只有 1.2G,注意空间比例)\ncd /root gzip -d mysql_bak.2020-06-04.sql.gz 导入数据\n 注意始终从库中不可以有写入 请先测试mysql -A是否可以进入数据库  mysql -A \u0026lt; mysql_bak.2020-06-04.sql \u0026amp; 实际上这种方式遇到特别大的数据还是很慢，可以考虑使用xtrabackup来自动备份数据库。\n"},{"id":20,"href":"/mysql/%E8%BF%90%E7%BB%B4/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/","title":"忘记密码","section":"Mysqls","content":"root 用户无法免密登陆，同时又忘记了密码?\n/usr/local/mariadb/bin/mysqladmin -u有权限的用户名 -p密码 shutdown /usr/local/mariadb/bin/mysqld_safe --skip-grant-tables \u0026amp; mysql -A -e \u0026#34;update mysql.user set password=password(\u0026#39;root\u0026#39;) where user=\u0026#39;root\u0026#39;\u0026#34;; mysql -A -e \u0026#34;flush privileges;\u0026#34; /usr/local/mariadb/bin/mysqladmin shutdown mkdir -p /var/run/mariadb; chown -R mysql:mysql /var/run/mariadb; /usr/local/mariadb/bin/mysqld_safe --datadir=/data/mariadb/data --pid-file=/var/run/mariadb/mariadb.pid \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; "},{"id":21,"href":"/mysql/%E8%BF%90%E7%BB%B4/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"注意事项","section":"Mysqls","content":"注意事项 #  mysql.sock不要放在tmp目录下面 #  执行命令，更改mariadb.sock文件位置，防止/tmp目录下文件被删除导致挂掉\nsed -i \u0026#34;s/\\/tmp\\/mariadb.sock/\\/data\\/mariadb\\/mariadb.sock/g\u0026#34; /etc/my.cnf.d/client.cnf sed -i \u0026#34;s/\\/tmp\\/mariadb.sock/\\/data\\/mariadb\\/mariadb.sock/g\u0026#34; /etc/my.cnf 修改完确认上面命令中的两个文件是不是都成功修改了mariadb.sock的目录，为/data/mariadb/mariadb.sock，如果没有手动修改。\n"},{"id":22,"href":"/mysql/%E8%BF%90%E7%BB%B4/%E9%87%8D%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95/","title":"重建mysql数据库的方法","section":"Mysqls","content":"本操作是高危操作，会导致所有数据丢掉，用来恢复无法恢复的mysql，重建以后再导入备份好的数据。\n1、停止MySql数据库的运行 2、删除mysql/var里面的所有数据库，这里是数据目录，具体请查看/etc/my.cnf的配置 3、进入mysql/bin目录下，执行./mysql_install_db命令 此时会在mysql/var目录下创建两个目录文件mysql、test 4、修改mysql、test两个目录及目录下所有文件的权限：\nchown mysql:mysql -R mysql test 注意这里一定要加上-R参数，否则启动会报错 5、启动数据库\n./mysqld_safe --user=mysql \u0026amp; 6、修改root密码\nmysql/bin/mysqladmin -u root password \u0026#34;yourpasswd\u0026#34; 这样，就完成了MySql数据库的重建了。关于停止MySql的运行，直接用启动MYSQL服务命令也行，也可以用停止进程的方法。启动数据库也可以直接用启动MYSQL服务的命令来启动。\n"},{"id":23,"href":"/mysql/%E9%9B%86%E7%BE%A4/%E5%BF%AB%E9%80%9F%E6%8B%89%E8%B5%B7/","title":"快速拉起","section":"Mysqls","content":"当Mariadb集群因故障重启时，有时会遇到Mariadb Galera Cluster集群无法正常启动的情况。有很多方式能将数据库拉起，但是如何做到快速启动，又不丢失数据呢？\n找到数据最新的节点 #  对比三个节点日志中的New cluster view: global state状态，可知道那个节点中的数据是最新的。\n[mysql@test45 logs]$ grep \u0026#34;New cluster view\u0026#34; mariadb.log |awk -F: \u0026#39;END { print $1\u0026#34;:\u0026#34;$2\u0026#34;:\u0026#34;$3 $6\u0026#34;:\u0026#34;$7}\u0026#39; 180518 14:59:00 [Note] WSREP 874d8e7e-5980-11e8-8c23-83493ba049c2:\u0026lt;span style=\u0026#34;color:#ff0000;\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;2840\u0026lt;/strong\u0026gt;\u0026lt;/span\u0026gt;, view# 3 [mysql@test44 logs]$ grep \u0026#34;New cluster view\u0026#34; mariadb.log |awk -F: \u0026#39;END { print $1\u0026#34;:\u0026#34;$2\u0026#34;:\u0026#34;$3 $6\u0026#34;:\u0026#34;$7}\u0026#39; 180518 15:55:03 [Note] WSREP 874d8e7e-5980-11e8-8c23-83493ba049c2:\u0026lt;strong\u0026gt;\u0026lt;span style=\u0026#34;color:#ff0000;\u0026#34;\u0026gt;3068\u0026lt;/span\u0026gt;\u0026lt;/strong\u0026gt;, view# 4 [mysql@test43 logs]$ grep \u0026#34;New cluster view\u0026#34; mariadb.log |awk -F: \u0026#39;END { print $1\u0026#34;:\u0026#34;$2\u0026#34;:\u0026#34;$3 $6\u0026#34;:\u0026#34;$7}\u0026#39; 180518 15:55:41 [Note] WSREP 874d8e7e-5980-11e8-8c23-83493ba049c2:\u0026lt;strong\u0026gt;\u0026lt;span style=\u0026#34;color:#ff0000;\u0026#34;\u0026gt;3111\u0026lt;/span\u0026gt;\u0026lt;/strong\u0026gt;, view# -1 得知三个节点数据的状态 ：3111\u0026gt;3068\u0026gt;2840\n所以 [mysql@test43 logs] 上的节点上的数据是最新的。\n修改最新节点上的grastate.dat文件 #  修改这个最新节点上的grastate.dat文件，文件目录可能有所不同，他位于Mariadb的数据文件目录，即datadir\n[mysql@test43 script]$more grastate.dat # GALERA saved state version: 2.1 uuid: 874d8e7e-5980-11e8-8c23-83493ba049c2 seqno: -1 safe_to_bootstrap: 0 修改为：\n[mysql@test43 data]$ vim ../data/grastate.dat # GALERA saved state version: 2.1 uuid: 874d8e7e-5980-11e8-8c23-83493ba049c2 seqno: 3111 safe_to_bootstrap: 1 将seqno设置为3111（这是上面取到的，不是固定的）。\nsafe_to_bootstrap设置为 1\n注意：在启动数据库前，最好对数据目录做备份，以防万一出问题可以还原事故现场。\n按顺序启动节点 #  1. 在【mysql@test43】节点以 wsrep_new_cluster 的方式启动 mysql\nmysqld_safe --defaults-file=/data/conf/my.cnf --user=mysql --wsrep_new_cluster \u0026amp; 2.以正常方式启动其它两个节点\nmysqld_safe --defaults-file=/data/conf/my.cnf --user=mysql\u0026amp; 根据这两个节点数据的情况，会自动做SST 或IST.\ndocker 方式 #  如果数据库是以docker拉起的，可以修改my.cnf配置文件中的wsrep_cluster_address参数，启动mysql。\n如将\nwsrep_cluster_address = gcomm://172.x.x.100:4567,172.x.x.101::4567,172.x.x.102::4567 调整为：\nwsrep_cluster_address = gcomm:// 再\ndocker start mariadb 待集群正常启动后，切记还恢复wsrep_cluster_address 参数设置。\n引用： Mariadb Galera Cluster 故障快速拉起\n留给你的问题 #  如果要写一个集群自动恢复的脚本，你有什么思路吗？\n记得\n 免密 小心丢数据 快速恢复  "},{"id":24,"href":"/readme/","title":"Readme","section":"","content":"interview-leetcode🔥 #  interview-leetcode 项目旨在快速复习找到工作，包括高频算法和真实面试问题问答，当然这些基本知识，也是工程师的学习素养，全部掌握对于工作来说也会有极大的帮助。\n \n  如果这个项目能为您带来帮助，我将感到非常荣幸！😁 如果您也对这个项目感兴趣，请点击一下 🌟Star 以示鼓励， 项目会 持续更新，谢谢你的支持。  成员结构 #  这是一群爱学习的互联网人，联合起来完成了这个知识库的维护\n 编程伐木累线上组织的成员来源于各个公司和各大高校，在群里我们可以一起:\n  认识各大公司一线开发者，和他们进行交流分享 获得内推机会，我们的成员来自国内众多一线互联网公司、还有专业的人力资源在线答疑 讨论最新互联网前沿知识和目前的趋势 反馈本书遇到的问题，共同改善内容质量 成为本书的编辑者，为手册贡献更多优质的内容 日常分享算法、Go等语言、工程、架构、运维等技术内容 群内分享工作经验、职场感悟、学习方法、商业、投资、协作、管理等方面的想法   成为组织的一员，可在群内在线答疑交流、以及反馈知识库中的问题。\n算法 #  刷题平台： LeetCode中国\n  算法面试注意  数据结构  LeetCode-hot100-easy  LeetCode-hot100-medium  LeetCode-hot100-difficult  其他高频算法  华为机试  面试高频问题大全 #  面试高频问题，是技术交流群每日一问讨论并总结得出，复习的时候注意反思节奏，用过没，是什么，哪个更好，为什么可以这样，是怎么实现的\n  面试高频问题-操作系统  面试高频问题-linux  面试高频问题-go  面试高频问题-redis  面试高频问题-mysql  面试高频问题-网络  面试高频问题-docker  面试高频问题-k8s  TODO面试高频问题-前端 TODO面试高频问题-mongoDB  项目一般问什么  面试高频问题-待解答  更多内容见电子书 leetcode.coding3min.com\n如何参与协作？ #  写作规范参考： 中文技术文档的写作规范\n 如果你不会使用git，参考 每天三分钟玩转Git 如果有想法和创意，请提 issue或者进群提 如果想贡献代码，请提 PR 算法刷题请使用vscode LeetCode 插件，自动创建文件、手动提交测试 如果发现错误，可以在电子书右上角直接点击编辑，会自动fork，修改完毕后手动提出pr  License #   本仓库的内容除了少量引用，引用内容会做标注，其余都是原创，在您引用本仓库内容或者对内容进行修改演绎时，请署名并以相同方式共享，谢谢。\n转载文章请在开头明显处标明该页面地址，公众号等其它转载请联系 coding3min@foxmail.com，或加我微信。\n最后 #  如果文中有误，欢迎提pr或者issue，一旦合并或采纳作为贡献奖励可以联系我直接无门槛加入 技术交流群\n致谢 #  感谢以下人员对本仓库做出的贡献 💖\n"},{"id":25,"href":"/todo/","title":"Todo","section":"","content":"待解答 #  介绍 #  此处是未解答的问题列表，欢迎挑战，可以提 issue 和 pr , 解答时提issue直接粘贴题目发起起问题即可\n前端 #  react中的diff算法是什么，为什么要做diff算法，key有什么用 #  提问：小雨\n回答-橙子： 如果有问题请更正我，谢谢！ key 这个答案很简单就两个作用1. 为了高效，， key 相当于一个标记， 快速的能够比较出现在节点和之前节点的区别，比如你一个数组， 你有下标就能更快的找到，diff算法里面就提到了先比较key， 如果没有key ， 那undefiend == undefined ,这样就会产生第二个问题， 容易就地复用所以key的第二个作用就是为了避免就地复用， 举个简单例子， 你写一个循环， 循环里面有每一个元素都有一个checkbox， 有一个他对应的文案， 这时候你进行一个排序， 没有key 你会发现内容排序变了，但是选中的checkbox 并没有跟着内容一起动\ndiff 算法我不会react 所以不能确定是否和vue 一样， 如果有需要vue的diff 算法解释请联系我\n闭包与Hooks设计有什么联系？ #  提问：小雨\njava #  hashmap和treemap的区别 #  go #  hashmap是怎么实现O1算法的时间复杂度的 #  为什么数组删除和插入是O（n） #  redis #  Redis 原理与调优经验 #  有用过哪些数据结构 #  zset 是怎么使用的 #  介绍一下持久化aof rdb #  分片是如何存储 #  mysql #  mysql的事物隔离级别有哪些 默认的事物隔离级别是什么？ #  mysql 数据库 undolog和binlog的区别是什么？ #  mysql 回表和覆盖索引是什么？ #  回表就是普通索引，定位id，再通过聚簇索引定位到数据，覆盖索引就是把单索引升级成联合索引，将多个列一起做索引，能防止回表\nmysql insert需不需要加锁？ #  mysql主从的实现原理 #  无主键插入重复记录可以成功吗？ #  字符串作主键来建立索引和数字作主键有什么区别？ #  mysql用id自增好，还是字符串主键好，为什么，插入效率有什么区别 #  怎么保证重试时不重复插入 #  慢SQL优化 #  网络 #  网络模式 epoll sleep，哪种会比较快一点，为什么会快一点 #  一个TCP连接同一时间可以发起多少个HTTP1.1的请求？浏览器是怎么提高图片渲染并发 #  回答-橙子： 如果有问题请更正我，谢谢！ 一个tcp 只能同时发起一个http请求，其他的要发需要等待， html , js, css 优先级高于图片， 在http 1.1 中同一个域名下可以建立6个持久连接（connect: keep-alive）， 如果有n个域名资源， 那就可以 同时建立 n*6 个连接， 如果全部占用， 那后面的资源就需要等待， 浏览器是怎么提高图片渲染并发： 这里应该可以是提高所有资源的并发感觉可以貌似是一样的， 有两种解决方案1， 资源放在不同域名下 2. 升级http1.1 到2.0 , 2.0 中没有这种建立tcp 连接的限制\nHTTP常见状态码有哪些，都什么作用 #  http中的keepalived是什么 #  回答-橙子： 如果有问题请更正我，谢谢！ keep-alive 是http1.1 中出现的， 是为了减少建立tcp连接， 建立一次tcp 连接不断开中间可以有多个http 请求， 但必须是按顺序的\npost和put在语义上有什么区别？ #  计算机网络http、spdy是什么？ #  回答-橙子： 如果有问题请更正我，谢谢！ http: 超文本传输协议， 解释来说就是在计算机世界里两点之间传输 图片， html , 视频等超文本数据的约定和规范， http 是一个协议。\n如何避免劫持 #  听说过哪些网络攻击方式，简单介绍一下 #  回答-橙子： 如果有问题请更正我，谢谢！ 后续我自己用自己的话描述会补充全， xss csrf sql 注入\nTLS是哪一层 #  HTTPS的连接流程是怎样；HTTPS的加密方式 #  对称加密和非对称加密都有 回答-橙子： 如果有问题请更正我，谢谢！ 补充楼上 对称加密 是加密url ， 非对称加密是加密key 后续会补充解释和一张图\nDNS的过程，DNS劫持是什么 #  linux #  怎么看负载、网络流量、磁盘io、进程监控 #  为什么磁盘io会飙升 #  某个进程偶现CPU高，如何排查是哪里出现问题了 #  linux文件权限有多少位，都是什么含义 #  proc的存储都是文件吗？ #  proc是怎么实现的，如果让你实现一个你会怎么做？ #  k8s #  overlay和underlay网络的区别？ #  pod里面存储的使用方式？ #  service的原理是什么？ #  stateful升级时要注意什么？ #  对象存储 #  对象存储是怎么存储数据的？ #  熟悉Linux系统、网络TCP/IP、QUIC等协议； 熟悉CDN原理和技术,调度系统架构，有CDN缓存与调度系统经验者优先； 熟悉TCP/IP和HTTP等协议栈，熟悉DNS/HTTPDNS/302调度原理\nnginx 的处理过程、工作在几层，怎么达到负载均衡的效果 ansible和saltstack的区别 获取子进程的ID docker的四种网络模式 k8s有哪个资源类型 k8s的滚动更新、亲和反亲和、自动伸缩 k8s中什么机制可以确保成功启动，但不一定是可用的（探针？） 什么是cdn? 怎么监控TCP网络，比如丢包、或者连接状态 网络监控有哪些指标 网络协议，比如说 HTTP对头阻塞，TCP阻塞控制 告警优先级排序，假如域名访问不通怎么判断是否宕机还是其他原因 如果这些告警是从多个不同的告警平台，怎么让告警收敛？（回调） cdn团队，保障SRE\n"},{"id":26,"href":"/tools/components/readme/","title":"Readme","section":"Tools","content":"这里存放了前端的各种组件\ncanvas #  20行代码实现代码雨效果 code-rain "},{"id":27,"href":"/tools/mac/readme/","title":"Readme","section":"Tools","content":"程序员的mac一些小技巧\n小问题 #  brew install卡 暂时禁止自动更新，关闭窗口后失效\nexport HOMEBREW_NO_AUTO_UPDATE=true 命令替代 #  tree命令\nalias tree=\u0026#34;find . -print | sed -e \u0026#39;s;[^/]*/;|____;g;s;____|; |;g\u0026#39;\u0026#34; "},{"id":28,"href":"/tools/mark-markdown-ppt/example/","title":"Example","section":"Tools","content":" Marp for VS Code方法 #  一种用markdown写ppt的vscode插件marp #  这款ppt就是我用“写”出来的，用来展示效果。\n 幻灯片1\n asdf asdf   幻灯片2\n asdf asdf    左中右组合方式 #    在其中一张图片后加入属性 vertical 将使图片纵向组合。 #   设置左图右文 #    文字 文字 命令    单独看图片 #  可以看到图片已经放到右边了，非常舒服\n prometheus #  此处的图片加了阴影drop-shadow\n  引用 #    技术分享之工具推荐-jeremyxu  marp官方文档  Marp：用 Markdown「写」PPT 的新选择  官方github  谢谢 #  "},{"id":29,"href":"/tools/mark-markdown-ppt/readme/","title":"Readme","section":"Tools","content":"一种用markdown写PPT的方法，再也不用费劲排版了 #  本文原创首发于 一种用markdown写PPT的方法，再也不用费劲排版了\n示例:\n 源文件 example.md 生成ppt example.pptx  前言 #  今天看 jeremyxu 的技术点滴，发现分享了一个 markdown 写 PPT 的插件，惊为天人，先来看看官方效果图。\n 再看看 jeremyxu 写的效果，我学完了都没学会是怎么写的，直到看了他 项目样例我才算是真的学会了。\n 参考 marp 官方文档可以很快学会用法，但是用的时候去翻比较麻烦，我提炼了常用的语法，最后做了一个 PPT 练手，才算是学会了，现在分享出来以便以后翻阅。\nmarp 是个什么？ #  日常工作生活中常常会用到 ppt, 但是 ppt 有时候做起来非常浪费时间，如果不用关心排版，可以专注内容自动排版岂不妙哉？\n正好 markdown 就是解决排版的一种语言，有好心人自发开发了一个做 ppt 的利器，只用关注内容，简单分隔一下，稍微改一下样式就可以用了。\n安装和上手 #  下载个 VSCode, 天然支持 markdown ，然后在左侧的插件栏中搜索并安装 Marp for VS Code 就可以开始了。为了获得更好的 Markdown 编辑体验，大家不妨再安装一个叫做 Markdown All in One 的插件。\n使用 Markdown 输出一份最简单的幻灯片，只需要让编辑器知道两点即可：它是幻灯片（不是文档）以及它该在哪里分页，通过如下代码做到：\n--- marp: true --- 幻灯片1 1. asdf 2. asdf --- 幻灯片2 * asdf * asdf 效果如下\n 编辑完成后，通过编辑器右上角的 Marp 图标按钮就可以调出 Export slide deck... 命令并导出幻灯片了。 Marp 插件目前支持导出 HTML 和 PDF 格式，另外可以将首页导出为 PNG 或 JPEG 格式的图片。\n优化样式 #  当然没有漂亮是样式是不行的，好在可以简单设置呈现，为此我专门做了一个 ppt\n 有三款主题可以选择，可以参考 themes，有的主题只能居中，我选了一个可居中也可居左的主题。\n--- marp: true theme: gaia footer: \u0026#39;机智的小熊 2020-06-18\u0026#39; paginate: true style: | section a { font-size: 30px; } ---  footer 代表是页尾， header 代表页首 paginate 是否在右下角标页码 style 自定义全局样式，插件所有的样式参考 官网提供的样式  首页配置 #   在当前页面头部，用 html 中的注释语法\n\u0026lt;!-- _class: lead gaia _paginate: false --\u0026gt;  _class 当前页面设置 lead gaia 样式（居中），如果前面不加下划线会影响所有页面 _paginate 屏蔽右下角页码 其他更详细语法参考 官网手册  首页内容如下\n![w:160](图片链接) # Marp for VS Code方法 ## 一种用markdown写ppt的vscode插件marp  这款ppt就是我用“写”出来的，用来展示效果。 图片设置 #  更改长宽 #  ![width:200px](image.jpg) ![height:300px](image.jpg) ![w:200px h:30cm](image.jpg) 图片滤镜（Image Filter） #  基于 CSS 的 filter 属性，Marp 可以对图片进行一些基于模糊、亮度、对比度等的操作，如：\n![blur:15px](image.png) ![brightness:0.5](image.png) ![contract:150%](image.png) 参考 更多 p 图命令\n背景图片 #  针对幻灯片的背景图片， Marp 提供了简单的方式将某张图片设为背景，在方括号中写入 bg 即可\n![bg](background.png) 同时通过在 bg 后追加图片的格式属性，如 [bg fit] ，可以具体设置背景图片的缩放方式。其中 cover 表示充满页面， fit 表示拉伸以适应页面， auto 为不做缩放使用原图片比例。\n其他图片详细语法, 参考 官网文档调整大小、滤镜，图片作背景的布局、尺寸、分割\n更改布局 #  背景图片布局 #   ![bg](images/9BBDF9.png) ![bg](images/2EC0F9.png) ![bg](images/B95F89.png) 在其中一张图片后加入属性 vertical 将使图片纵向组合。\n ![bg vertical](images/9BBDF9.png) ![bg](images/2EC0F9.png) ![bg](images/B95F89.png) 更新图片与文字位置 #  有时候想左文右图，或者左图右文的布局，可以设置背景图片的位置\n 参考 更多背景图片文字排版命令\n假如你想加一张完整图片做展示，而不是要上面的样式，可以自行调整图片大小实现\n![bg right w:15cm](images/prometheuslogo.png)  如果是上下排布的长图就不需要加bg了，直接放上去就好了。\n### prometheus  此处的图片加阴影`drop-shadow` ![width:30cm height:9cm drop-shadow](images/prometheus.png)  常用语法汇总 #   color: red 设置字体颜色 paginate: true 显示页码, _paginate: false 屏蔽当前页面页码 有三款主题可以选择，可以参考 themes  官网提供的样式  官网提供的语法汇总  更多 p 图命令  官网文档调整大小、滤镜，图片作背景的布局、尺寸、分割  更多背景图片文字排版命令  引用 #    技术分享之工具推荐-jeremyxu  marp 官方文档  Marp：用 Markdown「写」PPT 的新选择  官方 github  jeremyxu的github样例  "},{"id":30,"href":"/tools/readme/","title":"Readme","section":"Tools","content":"实用工具 #     工具名称 技术栈关键字 备注     markdown写PPT工具 vscode、markdown、ppt vscode的插件，从此不用再关心ppt排版   命令行自动演示工具 linux、demo 讲课、分享的时候假装在现场输入命令的作弊工具    运维工具 #     工具名称 技术栈关键字 备注     消耗CPU资源的脚本 shell、cpu 可设置占用多少cpu    前端组件库 #     分类 组件与效果 技术栈关键字 备注     背景 20行代码实现代码雨效果 canvas     "},{"id":31,"href":"/tools/scripts/devops/killcpu/readme/","title":"Readme","section":"Tools","content":"使用方法很简单，参数3表示消耗3颗CPU的资源，运行后，会有一堆 kill 命令，方便 kill 进程：\n[root@test02 ~]# ./killcpu.sh 3 kill 30104 ; kill 30106 ; kill 30108 ; [root@test02 ~]# top  top - 15:27:31 up 264 days, 23:39, 4 users, load average: 0.86, 0.25, 0.19 Tasks: 185 total, 5 running, 180 sleeping, 0 stopped, 0 zombie Cpu0 : 100.0% us, 0.0% sy, 0.0% ni, 0.0% id, 0.0% wa, 0.0% hi, 0.0% si Cpu1 : 0.0% us, 0.0% sy, 0.0% ni, 100.0% id, 0.0% wa, 0.0% hi, 0.0% si Cpu2 : 100.0% us, 0.0% sy, 0.0% ni, 0.0% id, 0.0% wa, 0.0% hi, 0.0% si Cpu3 : 100.0% us, 0.0% sy, 0.0% ni, 0.0% id, 0.0% wa, 0.0% hi, 0.0% si Mem: 8165004k total, 8095880k used, 69124k free, 53672k buffers Swap: 2031608k total, 103548k used, 1928060k free, 6801364k cached "},{"id":32,"href":"/tools/scripts/show-demo-magic/readme/","title":"Readme","section":"Tools","content":"报错？网卡？演示的时候别再尴尬，试试 demo-magic 假输入命令工具\n本文原创首发于 报错？网卡？演示的时候别再尴尬，试试 demo-magic 假输入命令工具\n简介 #  演示的时候要准确的输入很多命令，有时候会遭遇网比较卡，半天没反应，或者命令报错的尴尬，特别在大分享，众多人等待的情况下，只能面对面，干瞪眼。\n所以 demo-magic 就是解决这个问题的，他可以模拟你的输入输出，看起来就像现场打字一样，你还可以调整打字速度，可以随时暂定继续，满足演示的需要。\n如下图，就是全自动的，我特意让他在下载东西的时候停顿了1秒，在登陆的时候特意等待我按回车。\n 用法 #  先到 github上把demo-magic.sh下载下来，放到任意目录里。\n我的目录结构\n. |____tools | |____demo-magic.sh |____cache | |____ls-al-cache.txt | |____install-pv-cache.txt |____run.sh  demo-magic.sh 就是下载好的脚本 cache 用来保存准备好的输出 run.sh 测试脚本（假演示脚本）  这个工具 用法非常非常简单，简单到一看就会的程度。\n#/bin/bash # include demo-magic . ./tools/demo-magic.sh -n # Will wait max 1 seconds until user presses PROMPT_TIMEOUT=1 TYPE_SPEED=10 # hide the evidence clear p \u0026#34;ls -al\u0026#34; cat cache/ls-al-cache.txt p \u0026#34;brew install pv\u0026#34; wait cat cache/install-pv-cache.txt # Will wait until user presses enter PROMPT_TIMEOUT=0 p \u0026#34;ssh 123.123.111.666\u0026#34; echo password\\(ENTER\\): wait echo login success "},{"id":33,"href":"/%E5%85%A5%E8%81%8C%E5%90%8E/","title":"入职后","section":"","content":"快速熟悉一个项目的方法 #  不知道你有没有经历过一个五年或者更长工作年限的开发人员半路加入团队的情况，可能第一两个星期他会问一些业务或者技术问题，不过一两个月他就可能在指导那些初级开发人员了。\n什么原因呢？因为他已经从过往经验里面总结出来一些套路了。\n项目的共性 #   绝大部分业务系统，核心功能都是由增删改查组成，然后通过通信、运算和人机交互串起来的，系统的复杂度主要体现在系统规模、性能、稳定性、业务流程、通信等方面。（部分工具类、基础架构类系统可能不一样） 绝大部份系统，都是遵循某种或几种设计模式分层进行开发的，最最常见的也就是MVC了。其他请参考一下设计模式教程。  快速熟悉新的项目的套路。 #   先搞清楚新的系统是搞什么的，就问简单几个问题，谁在用这个系统？用这个系统做什么？然后自己根据这些问题去文档找答案。 弄清楚系统是怎么分层、分模块的，每层、每个模块都用到了什么技术和框架，之间是怎么通信的。有架构设计文档的话学习一下最好，没用过的技术先查查资料知道个大概。 把开发环境搭起来，通过几个典型的功能弄清楚系统里面增删改查、通信、用户交互是怎么实现的。最简单的方法是根据系统的分层，先从前端到数据库把代码疏通一下，搞不清楚的话打开debug模式一步一步走一下。 经过上面三个步骤基本上就可以改几个bug和照葫芦画瓢做个功能了。后面重点关注那些没用过的技术和组件：先搞清它的目的、背景、实现原理和功能列表，再照着文档做几个demo，平常工作时把它的文档建个快捷方式，随手查询学习一下。 平常开发过程中如果遇到问题首先要相信：  1）绝大部分自己遇到的问题很多人已经遇到过并且解决了 。 2）绝大部分自己遇到的问题在当前系统里面已经有了答案。 3）绝大部分自己遇到的问题在你用的框架和组件里面都有现成的解决方案。\n对于规模比较大的系统或者系统集合，其实你平时工作接触到的也就是其中的一个系统或者模块，先把自己接触的部分搞定就行了。  对于老系统要注意 #  对于老系统，首先建议看一下 在感觉项目代码的构架不行的时候, 你们会怎么办?\n 老系统其实满是宝藏，里面有很多你可以借鉴和学习的东西。 老系统也满是坑，一个看起来毫不悬念的代码改了以后可能会引发地震。 很多你看着不爽的代码其实都是有道理的。 不要在老系统里面继续挖坑。 看不懂的代码不要动。 在你力所能及的范围内让老系统变的更美好。  上面这个套路应该符合百分之七八十的项目，可以试试看。\n引用： 程序员如何快速上手一个自己不太熟悉的新项目？有什么技巧？\n"}]